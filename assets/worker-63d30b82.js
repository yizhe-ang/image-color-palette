var Mn=Object.defineProperty;var En=(Ie,Ee,Re)=>Ee in Ie?Mn(Ie,Ee,{enumerable:!0,configurable:!0,writable:!0,value:Re}):Ie[Ee]=Re;var Be=(Ie,Ee,Re)=>(En(Ie,typeof Ee!="symbol"?Ee+"":Ee,Re),Re),Yt=(Ie,Ee,Re)=>{if(!Ee.has(Ie))throw TypeError("Cannot "+Re)};var Je=(Ie,Ee,Re)=>(Yt(Ie,Ee,"read from private field"),Re?Re.call(Ie):Ee.get(Ie)),Ht=(Ie,Ee,Re)=>{if(Ee.has(Ie))throw TypeError("Cannot add the same private member more than once");Ee instanceof WeakSet?Ee.add(Ie):Ee.set(Ie,Re)},Vt=(Ie,Ee,Re,nt)=>(Yt(Ie,Ee,"write to private field"),nt?nt.call(Ie,Re):Ee.set(Ie,Re),Re);var Xt=(Ie,Ee,Re)=>(Yt(Ie,Ee,"access private method"),Re);(function(){var Ie,Ee,Kt,nt,ze;"use strict";function _mergeNamespaces(d,t){return t.forEach(function(i){i&&typeof i!="string"&&!Array.isArray(i)&&Object.keys(i).forEach(function(r){if(r!=="default"&&!(r in d)){var o=Object.getOwnPropertyDescriptor(i,r);Object.defineProperty(d,r,o.get?o:{enumerable:!0,get:function(){return i[r]}})}})}),Object.freeze(d)}function dispatchCallback(d,t){d&&d(t)}function reverseDictionary(d){return Object.fromEntries(Object.entries(d).map(([t,i])=>[i,t]))}const Callable=class{constructor(){let d=function(...t){return d._call(...t)};return Object.setPrototypeOf(d,new.target.prototype)}_call(...d){throw Error("Must implement _call method in subclass")}};function isString(d){return typeof d=="string"||d instanceof String}function isTypedArray(d){var t,i,r;return((r=(i=(t=d==null?void 0:d.prototype)==null?void 0:t.__proto__)==null?void 0:i.constructor)==null?void 0:r.name)==="TypedArray"}function isIntegralNumber(d){return Number.isInteger(d)||typeof d=="bigint"}function exists(d){return d!=null}function calculateDimensions(d){const t=[];let i=d;for(;Array.isArray(i);)t.push(i.length),i=i[0];return t}function mergeArrays(...d){return Array.prototype.concat.apply([],d)}function calculateReflectOffset(d,t){return Math.abs((d+t)%(2*t)-t)}var sharp={},ONNX_NODE=Object.freeze({__proto__:null,default:sharp}),commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(d){return d&&d.__esModule&&Object.prototype.hasOwnProperty.call(d,"default")?d.default:d}function getAugmentedNamespace(d){if(d.__esModule)return d;var t=d.default;if(typeof t=="function"){var i=function r(){if(this instanceof r){var o=[null];o.push.apply(o,arguments);var l=Function.bind.apply(t,o);return new l}return t.apply(this,arguments)};i.prototype=t.prototype}else i={};return Object.defineProperty(i,"__esModule",{value:!0}),Object.keys(d).forEach(function(r){var o=Object.getOwnPropertyDescriptor(d,r);Object.defineProperty(i,r,o.get?o:{enumerable:!0,get:function(){return d[r]}})}),i}var ortWeb_minExports={},ortWeb_min$1={get exports(){return ortWeb_minExports},set exports(d){ortWeb_minExports=d}};const backends={},backendsSortedByPriority=[],registerBackend=(d,t,i)=>{if(t&&typeof t.init=="function"&&typeof t.createSessionHandler=="function"){const r=backends[d];if(r===void 0)backends[d]={backend:t,priority:i};else{if(r.priority>i)return;if(r.priority===i&&r.backend!==t)throw new Error(`cannot register backend "${d}" using priority ${i}`)}if(i>=0){const o=backendsSortedByPriority.indexOf(d);o!==-1&&backendsSortedByPriority.splice(o,1);for(let l=0;l<backendsSortedByPriority.length;l++)if(backends[backendsSortedByPriority[l]].priority<=i){backendsSortedByPriority.splice(l,0,d);return}backendsSortedByPriority.push(d)}return}throw new TypeError("not a valid backend")},resolveBackend=async d=>{const t=d.length===0?backendsSortedByPriority:d,i=[];for(const r of t){const o=backends[r];if(o){if(o.initialized)return o.backend;if(o.aborted)continue;const l=!!o.initPromise;try{return l||(o.initPromise=o.backend.init()),await o.initPromise,o.initialized=!0,o.backend}catch(a){l||i.push({name:r,err:a}),o.aborted=!0}finally{delete o.initPromise}}}throw new Error(`no available backend found. ERR: ${i.map(r=>`[${r.name}] ${r.err}`).join(", ")}`)};class EnvImpl{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);this.logLevelInternal=t}}get logLevel(){return this.logLevelInternal}}const env$2=new EnvImpl,isBigInt64ArrayAvailable=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",isBigUint64ArrayAvailable=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function",NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64")),isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"));const calculateSize=d=>{let t=1;for(let i=0;i<d.length;i++){const r=d[i];if(typeof r!="number"||!Number.isSafeInteger(r))throw new TypeError(`dims[${i}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${r}`);t*=r}return t};let Tensor$2=class ft{constructor(t,i,r){let o,l,a;if(typeof t=="string")if(o=t,a=r,t==="string"){if(!Array.isArray(i))throw new TypeError("A string tensor's data must be a string array.");l=i}else{const p=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(i))l=p.from(i);else if(i instanceof p)l=i;else throw new TypeError(`A ${o} tensor's data must be type of ${p}`)}else if(a=i,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const p=typeof t[0];if(p==="string")o="string",l=t;else if(p==="boolean")o="bool",l=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else{const p=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=p,l=t}if(a===void 0)a=[l.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");const f=calculateSize(a);if(f!==l.length)throw new Error(`Tensor's size(${f}) does not match data length(${l.length}).`);this.dims=a,this.type=o,this.data=l,this.size=f}static bufferToTensor(t,i){if(t===void 0)throw new Error("Image buffer must be defined");if(i.height===void 0||i.width===void 0)throw new Error("Image height and width must be defined");const{height:r,width:o}=i,l=i.norm;let a,f;l===void 0||l.mean===void 0?a=255:a=l.mean,l===void 0||l.bias===void 0?f=0:f=l.bias;const p=i.bitmapFormat!==void 0?i.bitmapFormat:"RGBA",h=i.tensorFormat!==void 0&&i.tensorFormat!==void 0?i.tensorFormat:"RGB",c=r*o,n=h==="RGBA"?new Float32Array(c*4):new Float32Array(c*3);let e=4,s=0,u=1,m=2,b=3,g=0,_=c,y=c*2,v=-1;p==="RGB"&&(e=3,s=0,u=1,m=2,b=-1),h==="RGBA"?v=c*3:h==="RBG"?(g=0,y=c,_=c*2):h==="BGR"&&(y=0,_=c,g=c*2);for(let M=0;M<c;M++,s+=e,m+=e,u+=e,b+=e)n[g++]=(t[s]+f)/a,n[_++]=(t[u]+f)/a,n[y++]=(t[m]+f)/a,v!==-1&&b!==-1&&(n[v++]=(t[b]+f)/a);return h==="RGBA"?new ft("float32",n,[1,4,r,o]):new ft("float32",n,[1,3,r,o])}static async fromImage(t,i){const r=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,l=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,a=typeof String<"u"&&(t instanceof String||typeof t=="string");let f,p={};if(r){const h=document.createElement("canvas"),c=h.getContext("2d");if(c!=null){let n=t.naturalHeight,e=t.naturalWidth;if(i!==void 0&&i.resizedHeight!==void 0&&i.resizedWidth!==void 0&&(n=i.resizedHeight,e=i.resizedWidth),i!==void 0){if(p=i,i.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(p.tensorFormat="RGBA",i.height!==void 0&&i.height!==n)throw new Error("Image input config height doesn't match HTMLImageElement height");if(p.height=n,i.width!==void 0&&i.width!==e)throw new Error("Image input config width doesn't match HTMLImageElement width");p.width=e}else p.tensorFormat="RGBA",p.height=n,p.width=e;h.width=e,h.height=n,c.drawImage(t,0,0,e,n),f=c.getImageData(0,0,e,n).data}else throw new Error("Can not access image data")}else if(o){const h="RGBA";let c,n;if(i!==void 0&&i.resizedWidth!==void 0&&i.resizedHeight!==void 0?(c=i.resizedHeight,n=i.resizedWidth):(c=t.height,n=t.width),i!==void 0){if(p=i,i.bitmapFormat!==void 0&&i.bitmapFormat!==h)throw new Error("Image input config format must be RGBA for ImageData");p.bitmapFormat="RGBA"}else p.bitmapFormat="RGBA";if(p.height=c,p.width=n,i!==void 0){const e=document.createElement("canvas");e.width=n,e.height=c;const s=e.getContext("2d");if(s!=null)s.putImageData(t,0,0),f=s.getImageData(0,0,n,c).data;else throw new Error("Can not access image data")}else f=t.data}else if(l){if(i===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(i.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const h=document.createElement("canvas").getContext("2d");if(h!=null){const c=t.height,n=t.width;if(h.drawImage(t,0,0,n,c),f=h.getImageData(0,0,n,c).data,i!==void 0){if(i.height!==void 0&&i.height!==c)throw new Error("Image input config height doesn't match ImageBitmap height");if(p.height=c,i.width!==void 0&&i.width!==n)throw new Error("Image input config width doesn't match ImageBitmap width");p.width=n}else p.height=c,p.width=n;return ft.bufferToTensor(f,p)}else throw new Error("Can not access image data")}else{if(a)return new Promise((h,c)=>{const n=document.createElement("canvas"),e=n.getContext("2d");if(!t||!e)return c();const s=new Image;s.crossOrigin="Anonymous",s.src=t,s.onload=()=>{n.width=s.width,n.height=s.height,e.drawImage(s,0,0,n.width,n.height);const u=e.getImageData(0,0,n.width,n.height);if(i!==void 0){if(i.height!==void 0&&i.height!==n.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(p.height=n.height,i.width!==void 0&&i.width!==n.width)throw new Error("Image input config width doesn't match ImageBitmap width");p.width=n.width}else p.height=n.height,p.width=n.width;h(ft.bufferToTensor(u.data,p))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(f!==void 0)return ft.bufferToTensor(f,p);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(t){var i,r;const o=document.createElement("canvas").getContext("2d");let l;if(o!=null){const a=this.dims[3],f=this.dims[2],p=this.dims[1],h=t!==void 0&&t.format!==void 0?t.format:"RGB",c=t!==void 0&&((i=t.norm)===null||i===void 0?void 0:i.mean)!==void 0?t.norm.mean:255,n=t!==void 0&&((r=t.norm)===null||r===void 0?void 0:r.bias)!==void 0?t.norm.bias:0,e=f*a;if(t!==void 0){if(t.height!==void 0&&t.height!==f)throw new Error("Image output config height doesn't match tensor height");if(t.width!==void 0&&t.width!==a)throw new Error("Image output config width doesn't match tensor width");if(t.format!==void 0&&p===4&&t.format!=="RGBA"||p===3&&t.format!=="RGB"&&t.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const s=4;let u=0,m=1,b=2,g=3,_=0,y=e,v=e*2,w=-1;h==="RGBA"?(_=0,y=e,v=e*2,w=e*3):h==="RGB"?(_=0,y=e,v=e*2):h==="RBG"&&(_=0,v=e,y=e*2),l=o.createImageData(a,f);for(let M=0;M<f*a;u+=s,m+=s,b+=s,g+=s,M++)l.data[u]=(this.data[_++]-n)*c,l.data[m]=(this.data[y++]-n)*c,l.data[b]=(this.data[v++]-n)*c,l.data[g]=w===-1?255:(this.data[w++]-n)*c}else throw new Error("Can not access image data");return l}reshape(t){return new ft(this.type,this.data,t)}};const Tensor$1=Tensor$2;let InferenceSession$2=class xn{constructor(t){this.handler=t}async run(t,i,r){const o={};let l={};if(typeof t!="object"||t===null||t instanceof Tensor$1||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof i=="object"){if(i===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(i instanceof Tensor$1)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(i)){if(i.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(const h of i){if(typeof h!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(h)===-1)throw new RangeError(`'fetches' contains invalid output name: ${h}.`);o[h]=null}if(typeof r=="object"&&r!==null)l=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{let h=!1;const c=Object.getOwnPropertyNames(i);for(const n of this.outputNames)if(c.indexOf(n)!==-1){const e=i[n];(e===null||e instanceof Tensor$1)&&(h=!0,a=!1,o[n]=e)}if(h){if(typeof r=="object"&&r!==null)l=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else l=i}}else if(typeof i<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const h of this.inputNames)if(typeof t[h]>"u")throw new Error(`input '${h}' is missing in 'feeds'.`);if(a)for(const h of this.outputNames)o[h]=null;const f=await this.handler.run(t,o,l),p={};for(const h in f)Object.hasOwnProperty.call(f,h)&&(p[h]=new Tensor$1(f[h].type,f[h].data,f[h].dims));return p}static async create(t,i,r,o){let l,a={};if(typeof t=="string"){if(l=t,typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(l=t,typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){const n=t;let e=0,s=t.byteLength;if(typeof i=="object"&&i!==null)a=i;else if(typeof i=="number"){if(e=i,!Number.isSafeInteger(e))throw new RangeError("'byteOffset' must be an integer.");if(e<0||e>=n.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${n.byteLength}).`);if(s=t.byteLength-e,typeof r=="number"){if(s=r,!Number.isSafeInteger(s))throw new RangeError("'byteLength' must be an integer.");if(s<=0||e+s>n.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${n.byteLength-e}].`);if(typeof o=="object"&&o!==null)a=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof i<"u")throw new TypeError("'options' must be an object.");l=new Uint8Array(n,e,s)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const p=(a.executionProviders||[]).map(n=>typeof n=="string"?n:n.name),c=await(await resolveBackend(p)).createSessionHandler(l,a);return new xn(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession$1=InferenceSession$2;var lib=Object.freeze({__proto__:null,InferenceSession:InferenceSession$1,Tensor:Tensor$1,env:env$2,registerBackend}),require$$0$1=getAugmentedNamespace(lib);/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(d,t){module.exports=t(require$$0$1)})(self,__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(d,t,i)=>{var r,o=(r=(r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(l){function a(){return U.buffer!=Q&&Ae(U.buffer),se}function f(){return U.buffer!=Q&&Ae(U.buffer),te}function p(){return U.buffer!=Q&&Ae(U.buffer),ae}function h(){return U.buffer!=Q&&Ae(U.buffer),ne}function c(){return U.buffer!=Q&&Ae(U.buffer),ce}var n,e,s;l=l||{},n||(n=l!==void 0?l:{}),n.ready=new Promise(function(E,A){e=E,s=A});var u,m,b,g,_,y,v=Object.assign({},n),w="./this.program",M=(E,A)=>{throw A},S=typeof window=="object",O=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=n.ENVIRONMENT_IS_PTHREAD||!1,I="";function F(E){return n.locateFile?n.locateFile(E,I):I+E}if(x){let E;I=O?i(908).dirname(I)+"/":"//",y=()=>{_||(g=i(1384),_=i(908))},u=function(A,D){return y(),A=_.normalize(A),g.readFileSync(A,D?void 0:"utf8")},b=A=>((A=u(A,!0)).buffer||(A=new Uint8Array(A)),A),m=(A,D,L)=>{y(),A=_.normalize(A),g.readFile(A,function(z,q){z?L(z):D(q.buffer)})},1<process.argv.length&&(w=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(A){if(!(A instanceof it))throw A}),process.on("unhandledRejection",function(A){throw A}),M=(A,D)=>{if(Xe())throw process.exitCode=A,D;D instanceof it||R("exiting due to exception: "+D),process.exit(A)},n.inspect=function(){return"[Emscripten Module object]"};try{E=i(9925)}catch(A){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),A}i.g.Worker=E.Worker}else(S||O)&&(O?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),r&&(I=r),I=I.indexOf("blob:")!==0?I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):"",x||(u=E=>{var A=new XMLHttpRequest;return A.open("GET",E,!1),A.send(null),A.responseText},O&&(b=E=>{var A=new XMLHttpRequest;return A.open("GET",E,!1),A.responseType="arraybuffer",A.send(null),new Uint8Array(A.response)}),m=(E,A,D)=>{var L=new XMLHttpRequest;L.open("GET",E,!0),L.responseType="arraybuffer",L.onload=()=>{L.status==200||L.status==0&&L.response?A(L.response):D()},L.onerror=D,L.send(null)}));x&&typeof performance>"u"&&(i.g.performance=i(6953).performance);var C=console.log.bind(console),N=console.warn.bind(console);x&&(y(),C=E=>g.writeSync(1,E+`
`),N=E=>g.writeSync(2,E+`
`));var B,k=n.print||C,R=n.printErr||N;Object.assign(n,v),v=null,n.thisProgram&&(w=n.thisProgram),n.quit&&(M=n.quit),n.wasmBinary&&(B=n.wasmBinary);var X=n.noExitRuntime||!1;typeof WebAssembly!="object"&&_e("no native wasm support detected");var U,K,Q,se,te,ae,ne,ce,oe=!1,De=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function $e(E,A,D){var L=(A>>>=0)+D;for(D=A;E[D]&&!(D>=L);)++D;if(16<D-A&&E.buffer&&De)return De.decode(E.buffer instanceof SharedArrayBuffer?E.slice(A,D):E.subarray(A,D));for(L="";A<D;){var z=E[A++];if(128&z){var q=63&E[A++];if((224&z)==192)L+=String.fromCharCode((31&z)<<6|q);else{var Z=63&E[A++];65536>(z=(240&z)==224?(15&z)<<12|q<<6|Z:(7&z)<<18|q<<12|Z<<6|63&E[A++])?L+=String.fromCharCode(z):(z-=65536,L+=String.fromCharCode(55296|z>>10,56320|1023&z))}}else L+=String.fromCharCode(z)}return L}function Te(E,A){return(E>>>=0)?$e(f(),E,A):""}function Ne(E,A,D,L){if(!(0<L))return 0;var z=D>>>=0;L=D+L-1;for(var q=0;q<E.length;++q){var Z=E.charCodeAt(q);if(55296<=Z&&57343>=Z&&(Z=65536+((1023&Z)<<10)|1023&E.charCodeAt(++q)),127>=Z){if(D>=L)break;A[D++>>>0]=Z}else{if(2047>=Z){if(D+1>=L)break;A[D++>>>0]=192|Z>>6}else{if(65535>=Z){if(D+2>=L)break;A[D++>>>0]=224|Z>>12}else{if(D+3>=L)break;A[D++>>>0]=240|Z>>18,A[D++>>>0]=128|Z>>12&63}A[D++>>>0]=128|Z>>6&63}A[D++>>>0]=128|63&Z}}return A[D>>>0]=0,D-z}function Fe(E){for(var A=0,D=0;D<E.length;++D){var L=E.charCodeAt(D);127>=L?A++:2047>=L?A+=2:55296<=L&&57343>=L?(A+=4,++D):A+=3}return A}function Ae(E){Q=E,n.HEAP8=se=new Int8Array(E),n.HEAP16=new Int16Array(E),n.HEAP32=ae=new Int32Array(E),n.HEAPU8=te=new Uint8Array(E),n.HEAPU16=new Uint16Array(E),n.HEAPU32=ne=new Uint32Array(E),n.HEAPF32=new Float32Array(E),n.HEAPF64=ce=new Float64Array(E)}T&&(Q=n.buffer);var Se=n.INITIAL_MEMORY||16777216;if(T)U=n.wasmMemory,Q=n.buffer;else if(n.wasmMemory)U=n.wasmMemory;else if(!((U=new WebAssembly.Memory({initial:Se/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");U&&(Q=U.buffer),Se=Q.byteLength,Ae(Q);var Ue,Ge=[],He=[],Ze=[],rt=[];function Xe(){return X||!1}function Ye(){var E=n.preRun.shift();Ge.unshift(E)}var Pe,qe=0,et=null;function _e(E){throw T?postMessage({cmd:"onAbort",arg:E}):n.onAbort&&n.onAbort(E),R(E="Aborted("+E+")"),oe=!0,E=new WebAssembly.RuntimeError(E+". Build with -sASSERTIONS for more info."),s(E),E}function _t(){return Pe.startsWith("data:application/octet-stream;base64,")}function pt(){var E=Pe;try{if(E==Pe&&B)return new Uint8Array(B);if(b)return b(E);throw"both async and sync fetching of the wasm failed"}catch(A){_e(A)}}Pe="ort-wasm-threaded.wasm",_t()||(Pe=F(Pe));var Ft={};function it(E){this.name="ExitStatus",this.message="Program terminated with exit("+E+")",this.status=E}function mt(E){(E=le.Vb[E])||_e(),le.mc(E)}function gt(E){var A=le.Cc();if(!A)return 6;le.ac.push(A),le.Vb[E.Ub]=A,A.Ub=E.Ub;var D={cmd:"run",start_routine:E.Ic,arg:E.zc,pthread_ptr:E.Ub};return A.$b=()=>{D.time=performance.now(),A.postMessage(D,E.Nc)},A.loaded&&(A.$b(),delete A.$b),0}function Ve(E){if(T)return ee(1,1,E);Xe()||(le.oc(),n.onExit&&n.onExit(E),oe=!0),M(E,new it(E))}function ut(E,A){if(!A&&T)throw Nt(E),"unwind";Xe()||T||(rn(),lt(Ze),nn(0),zt[1].length&&Ut(1,10),zt[2].length&&Ut(2,10),le.oc()),Ve(E)}var le={Yb:[],ac:[],qc:[],Vb:{},fc:function(){T&&le.Ec()},Pc:function(){},Ec:function(){le.receiveObjectTransfer=le.Gc,le.threadInitTLS=le.pc,le.setExitStatus=le.nc,X=!1},nc:function(){},oc:function(){for(var E of Object.values(le.Vb))le.mc(E);for(E of le.Yb)E.terminate();le.Yb=[]},mc:function(E){var A=E.Ub;delete le.Vb[A],le.Yb.push(E),le.ac.splice(le.ac.indexOf(E),1),E.Ub=0,qt(A)},Gc:function(){},pc:function(){le.qc.forEach(E=>E())},Fc:function(E,A){E.onmessage=D=>{var L=(D=D.data).cmd;if(E.Ub&&(le.Bc=E.Ub),D.targetThread&&D.targetThread!=Rt()){var z=le.Vb[D.Qc];z?z.postMessage(D,D.transferList):R('Internal error! Worker sent a message "'+L+'" to target pthread '+D.targetThread+", but that thread no longer exists!")}else L==="processProxyingQueue"?j(D.queue):L==="spawnThread"?gt(D):L==="cleanupThread"?mt(D.thread):L==="killThread"?(D=D.thread,L=le.Vb[D],delete le.Vb[D],L.terminate(),qt(D),le.ac.splice(le.ac.indexOf(L),1),L.Ub=0):L==="cancelThread"?le.Vb[D.thread].postMessage({cmd:"cancel"}):L==="loaded"?(E.loaded=!0,A&&A(E),E.$b&&(E.$b(),delete E.$b)):L==="print"?k("Thread "+D.threadId+": "+D.text):L==="printErr"?R("Thread "+D.threadId+": "+D.text):L==="alert"?alert("Thread "+D.threadId+": "+D.text):D.target==="setimmediate"?E.postMessage(D):L==="onAbort"?n.onAbort&&n.onAbort(D.arg):L&&R("worker sent an unknown command "+L);le.Bc=void 0},E.onerror=D=>{throw R("worker sent an error! "+D.filename+":"+D.lineno+": "+D.message),D},x&&(E.on("message",function(D){E.onmessage({data:D})}),E.on("error",function(D){E.onerror(D)}),E.on("detachedExit",function(){})),E.postMessage({cmd:"load",urlOrBlob:n.mainScriptUrlOrBlob||r,wasmMemory:U,wasmModule:K})},yc:function(){var E=F("ort-wasm-threaded.worker.js");le.Yb.push(new Worker(E))},Cc:function(){return le.Yb.length==0&&(le.yc(),le.Fc(le.Yb[0])),le.Yb.pop()}};function lt(E){for(;0<E.length;)E.shift()(n)}function $t(E){var A=me();return E=E(),pe(A),E}function Nt(E){if(T)return ee(2,0,E);try{ut(E)}catch(A){A instanceof it||A=="unwind"||M(1,A)}}n.PThread=le,n.establishStackSpace=function(){var E=Rt(),A=p()[E+44>>2>>>0];E=p()[E+48>>2>>>0],un(A,A-E),pe(A)};var ot=[];function xe(E){var A=ot[E];return A||(E>=ot.length&&(ot.length=E+1),ot[E]=A=Ue.get(E)),A}n.invokeEntryPoint=function(E,A){E=xe(E)(A),Xe()?le.nc(E):ln(E)};var ct,yt,ht=[],de=0,ue=0;function he(E){this.Zb=E,this.Sb=E-24,this.xc=function(A){h()[this.Sb+4>>2>>>0]=A},this.bc=function(){return h()[this.Sb+4>>2>>>0]},this.wc=function(A){h()[this.Sb+8>>2>>>0]=A},this.Dc=function(){return h()[this.Sb+8>>2>>>0]},this.rc=function(){p()[this.Sb>>2>>>0]=0},this.hc=function(A){A=A?1:0,a()[this.Sb+12>>0>>>0]=A},this.uc=function(){return a()[this.Sb+12>>0>>>0]!=0},this.ic=function(A){A=A?1:0,a()[this.Sb+13>>0>>>0]=A},this.kc=function(){return a()[this.Sb+13>>0>>>0]!=0},this.fc=function(A,D){this.cc(0),this.xc(A),this.wc(D),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(p(),this.Sb>>2,1)},this.Hc=function(){return Atomics.sub(p(),this.Sb>>2,1)===1},this.cc=function(A){h()[this.Sb+16>>2>>>0]=A},this.tc=function(){return h()[this.Sb+16>>2>>>0]},this.vc=function(){if(cn(this.bc()))return h()[this.Zb>>2>>>0];var A=this.tc();return A!==0?A:this.Zb}}function wt(E){return tn(new he(E).Sb)}function dt(E,A,D,L){return T?ee(3,1,E,A,D,L):vt(E,A,D,L)}function vt(E,A,D,L){if(typeof SharedArrayBuffer>"u")return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var z=[];return T&&z.length===0?dt(E,A,D,L):(E={Ic:D,Ub:E,zc:L,Nc:z},T?(E.Oc="spawnThread",postMessage(E,z),0):gt(E))}function xt(E,A,D){return T?ee(4,1,E,A,D):0}function Tt(E,A){if(T)return ee(5,1,E,A)}function St(E,A){if(T)return ee(6,1,E,A)}function Mt(E,A,D){if(T)return ee(7,1,E,A,D)}function Et(E,A,D){return T?ee(8,1,E,A,D):0}function Ot(E,A){if(T)return ee(9,1,E,A)}function At(E,A,D){if(T)return ee(10,1,E,A,D)}function Pt(E,A,D,L){if(T)return ee(11,1,E,A,D,L)}function It(E,A,D,L){if(T)return ee(12,1,E,A,D,L)}function Dt(E,A,D,L){if(T)return ee(13,1,E,A,D,L)}function Ct(E){if(T)return ee(14,1,E)}function P(E,A){if(T)return ee(15,1,E,A)}function $(E,A,D){if(T)return ee(16,1,E,A,D)}function j(E){Atomics.store(p(),E>>2,1),Rt()&&an(E),Atomics.compareExchange(p(),E>>2,1,0)}function V(E){return h()[E>>>2]+4294967296*p()[E+4>>>2]}function G(E,A,D,L,z,q){return T?ee(17,1,E,A,D,L,z,q):-52}function H(E,A,D,L,z,q){if(T)return ee(18,1,E,A,D,L,z,q)}function J(E){var A=Fe(E)+1,D=Gt(A);return D&&Ne(E,a(),D,A),D}function re(E,A,D){function L(ye){return(ye=ye.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ye[1]:"GMT"}if(T)return ee(19,1,E,A,D);var z=new Date().getFullYear(),q=new Date(z,0,1),Z=new Date(z,6,1);z=q.getTimezoneOffset();var ie=Z.getTimezoneOffset(),be=Math.max(z,ie);p()[E>>2>>>0]=60*be,p()[A>>2>>>0]=Number(z!=ie),E=L(q),A=L(Z),E=J(E),A=J(A),ie<z?(h()[D>>2>>>0]=E,h()[D+4>>2>>>0]=A):(h()[D>>2>>>0]=A,h()[D+4>>2>>>0]=E)}function ee(E,A){var D=arguments.length-2,L=arguments;return $t(()=>{for(var z=Wt(8*D),q=z>>3,Z=0;Z<D;Z++){var ie=L[2+Z];c()[q+Z>>>0]=ie}return sn(E,D,z,A)})}n.executeNotifiedProxyingQueue=j,yt=x?()=>{var E=process.hrtime();return 1e3*E[0]+E[1]/1e6}:T?()=>performance.now()-n.__performance_now_clock_drift:()=>performance.now();var fe,Me=[],je={};function Le(){if(!fe){var E,A={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:w||"./this.program"};for(E in je)je[E]===void 0?delete A[E]:A[E]=je[E];var D=[];for(E in A)D.push(E+"="+A[E]);fe=D}return fe}function W(E,A){if(T)return ee(20,1,E,A);var D=0;return Le().forEach(function(L,z){var q=A+D;for(z=h()[E+4*z>>2>>>0]=q,q=0;q<L.length;++q)a()[z++>>0>>>0]=L.charCodeAt(q);a()[z>>0>>>0]=0,D+=L.length+1}),0}function we(E,A){if(T)return ee(21,1,E,A);var D=Le();h()[E>>2>>>0]=D.length;var L=0;return D.forEach(function(z){L+=z.length+1}),h()[A>>2>>>0]=L,0}function Oe(E){return T?ee(22,1,E):52}function Ke(E,A,D,L){return T?ee(23,1,E,A,D,L):52}function st(E,A,D,L,z){return T?ee(24,1,E,A,D,L,z):70}var zt=[null,[],[]];function Ut(E,A){var D=zt[E];A===0||A===10?((E===1?k:R)($e(D,0)),D.length=0):D.push(A)}function Qt(E,A,D,L){if(T)return ee(25,1,E,A,D,L);for(var z=0,q=0;q<D;q++){var Z=h()[A>>2>>>0],ie=h()[A+4>>2>>>0];A+=8;for(var be=0;be<ie;be++)Ut(E,f()[Z+be>>>0]);z+=ie}return h()[L>>2>>>0]=z,0}var We=0;function Lt(E){return E%4==0&&(E%100!=0||E%400==0)}var Jt=[31,29,31,30,31,30,31,31,30,31,30,31],Zt=[31,28,31,30,31,30,31,31,30,31,30,31];function en(E,A,D,L){function z(Y,ve,Ce){for(Y=typeof Y=="number"?Y.toString():Y||"";Y.length<ve;)Y=Ce[0]+Y;return Y}function q(Y,ve){return z(Y,ve,"0")}function Z(Y,ve){function Ce(bt){return 0>bt?-1:0<bt?1:0}var at;return(at=Ce(Y.getFullYear()-ve.getFullYear()))===0&&(at=Ce(Y.getMonth()-ve.getMonth()))===0&&(at=Ce(Y.getDate()-ve.getDate())),at}function ie(Y){switch(Y.getDay()){case 0:return new Date(Y.getFullYear()-1,11,29);case 1:return Y;case 2:return new Date(Y.getFullYear(),0,3);case 3:return new Date(Y.getFullYear(),0,2);case 4:return new Date(Y.getFullYear(),0,1);case 5:return new Date(Y.getFullYear()-1,11,31);case 6:return new Date(Y.getFullYear()-1,11,30)}}function be(Y){var ve=Y.Wb;for(Y=new Date(new Date(Y.Xb+1900,0,1).getTime());0<ve;){var Ce=Y.getMonth(),at=(Lt(Y.getFullYear())?Jt:Zt)[Ce];if(!(ve>at-Y.getDate())){Y.setDate(Y.getDate()+ve);break}ve-=at-Y.getDate()+1,Y.setDate(1),11>Ce?Y.setMonth(Ce+1):(Y.setMonth(0),Y.setFullYear(Y.getFullYear()+1))}return Ce=new Date(Y.getFullYear()+1,0,4),ve=ie(new Date(Y.getFullYear(),0,4)),Ce=ie(Ce),0>=Z(ve,Y)?0>=Z(Ce,Y)?Y.getFullYear()+1:Y.getFullYear():Y.getFullYear()-1}var ye=p()[L+40>>2>>>0];for(var ke in L={Lc:p()[L>>2>>>0],Kc:p()[L+4>>2>>>0],dc:p()[L+8>>2>>>0],jc:p()[L+12>>2>>>0],ec:p()[L+16>>2>>>0],Xb:p()[L+20>>2>>>0],Tb:p()[L+24>>2>>>0],Wb:p()[L+28>>2>>>0],Rc:p()[L+32>>2>>>0],Jc:p()[L+36>>2>>>0],Mc:ye?Te(ye):""},D=Te(D),ye={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})D=D.replace(new RegExp(ke,"g"),ye[ke]);var tt="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Qe="January February March April May June July August September October November December".split(" ");for(ke in ye={"%a":function(Y){return tt[Y.Tb].substring(0,3)},"%A":function(Y){return tt[Y.Tb]},"%b":function(Y){return Qe[Y.ec].substring(0,3)},"%B":function(Y){return Qe[Y.ec]},"%C":function(Y){return q((Y.Xb+1900)/100|0,2)},"%d":function(Y){return q(Y.jc,2)},"%e":function(Y){return z(Y.jc,2," ")},"%g":function(Y){return be(Y).toString().substring(2)},"%G":function(Y){return be(Y)},"%H":function(Y){return q(Y.dc,2)},"%I":function(Y){return(Y=Y.dc)==0?Y=12:12<Y&&(Y-=12),q(Y,2)},"%j":function(Y){for(var ve=0,Ce=0;Ce<=Y.ec-1;ve+=(Lt(Y.Xb+1900)?Jt:Zt)[Ce++]);return q(Y.jc+ve,3)},"%m":function(Y){return q(Y.ec+1,2)},"%M":function(Y){return q(Y.Kc,2)},"%n":function(){return`
`},"%p":function(Y){return 0<=Y.dc&&12>Y.dc?"AM":"PM"},"%S":function(Y){return q(Y.Lc,2)},"%t":function(){return"	"},"%u":function(Y){return Y.Tb||7},"%U":function(Y){return q(Math.floor((Y.Wb+7-Y.Tb)/7),2)},"%V":function(Y){var ve=Math.floor((Y.Wb+7-(Y.Tb+6)%7)/7);if(2>=(Y.Tb+371-Y.Wb-2)%7&&ve++,ve)ve==53&&((Ce=(Y.Tb+371-Y.Wb)%7)==4||Ce==3&&Lt(Y.Xb)||(ve=1));else{ve=52;var Ce=(Y.Tb+7-Y.Wb-1)%7;(Ce==4||Ce==5&&Lt(Y.Xb%400-1))&&ve++}return q(ve,2)},"%w":function(Y){return Y.Tb},"%W":function(Y){return q(Math.floor((Y.Wb+7-(Y.Tb+6)%7)/7),2)},"%y":function(Y){return(Y.Xb+1900).toString().substring(2)},"%Y":function(Y){return Y.Xb+1900},"%z":function(Y){var ve=0<=(Y=Y.Jc);return Y=Math.abs(Y)/60,(ve?"+":"-")+String("0000"+(Y/60*100+Y%60)).slice(-4)},"%Z":function(Y){return Y.Mc},"%%":function(){return"%"}},D=D.replace(/%%/g,"\0\0"),ye)D.includes(ke)&&(D=D.replace(new RegExp(ke,"g"),ye[ke](L)));return ke=function(Y){var ve=Array(Fe(Y)+1);return Ne(Y,ve,0,ve.length),ve}(D=D.replace(/\0\0/g,"%")),ke.length>A?0:(function(Y,ve){a().set(Y,ve>>>0)}(ke,E),ke.length-1)}le.fc();var Tn=[null,Ve,Nt,dt,xt,Tt,St,Mt,Et,Ot,At,Pt,It,Dt,Ct,P,$,G,H,re,W,we,Oe,Ke,st,Qt],Sn={b:function(E){return Gt(E+24)+24},n:function(E){return(E=new he(E)).uc()||(E.hc(!0),de--),E.ic(!1),ht.push(E),E.sc(),E.vc()},ma:function(E){throw R("Unexpected exception thrown, this is not properly supported - aborting"),oe=!0,E},x:function(){ge(0);var E=ht.pop();if(E.Hc()&&!E.kc()){var A=E.Dc();A&&xe(A)(E.Zb),wt(E.Zb)}ue=0},e:function(){var E=ue;if(!E)return We=0;var A=new he(E);A.cc(E);var D=A.bc();if(!D)return We=0,E;for(var L=Array.prototype.slice.call(arguments),z=0;z<L.length;z++){var q=L[z];if(q===0||q===D)break;if(Bt(q,D,A.Sb+16))return We=q,E}return We=D,E},l:function(){var E=ue;if(!E)return We=0;var A=new he(E);A.cc(E);var D=A.bc();if(!D)return We=0,E;for(var L=Array.prototype.slice.call(arguments),z=0;z<L.length;z++){var q=L[z];if(q===0||q===D)break;if(Bt(q,D,A.Sb+16))return We=q,E}return We=D,E},h:function(){var E=ue;if(!E)return We=0;var A=new he(E);A.cc(E);var D=A.bc();if(!D)return We=0,E;for(var L=Array.prototype.slice.call(arguments),z=0;z<L.length;z++){var q=L[z];if(q===0||q===D)break;if(Bt(q,D,A.Sb+16))return We=q,E}return We=D,E},t:wt,M:function(){var E=ht.pop();E||_e("no exception to throw");var A=E.Zb;throw E.kc()||(ht.push(E),E.ic(!0),E.hc(!1),de++),ue=A,A},c:function(E,A,D){throw new he(E).fc(A,D),ue=E,de++,E},pa:function(){return de},Fa:function(E){on(E,!O,1,!S),le.pc()},T:function(E){T?postMessage({cmd:"cleanupThread",thread:E}):mt(E)},xa:vt,j:function(E){throw ue||(ue=E),E},H:xt,Ma:Tt,ua:St,wa:Mt,oa:Et,Ka:Ot,Ca:At,Ja:Pt,V:It,va:Dt,sa:Ct,La:P,ta:$,Ta:function(){},X:function(){_e("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){_e("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(E,A,D,L){if(E==A)setTimeout(()=>j(L));else if(T)postMessage({targetThread:E,cmd:"processProxyingQueue",queue:L});else{if(!(E=le.Vb[E]))return;E.postMessage({cmd:"processProxyingQueue",queue:L})}return 1},Ea:function(){return-1},Pa:function(E,A){E=new Date(1e3*V(E)),p()[A>>2>>>0]=E.getUTCSeconds(),p()[A+4>>2>>>0]=E.getUTCMinutes(),p()[A+8>>2>>>0]=E.getUTCHours(),p()[A+12>>2>>>0]=E.getUTCDate(),p()[A+16>>2>>>0]=E.getUTCMonth(),p()[A+20>>2>>>0]=E.getUTCFullYear()-1900,p()[A+24>>2>>>0]=E.getUTCDay(),E=(E.getTime()-Date.UTC(E.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,p()[A+28>>2>>>0]=E},Qa:function(E,A){E=new Date(1e3*V(E)),p()[A>>2>>>0]=E.getSeconds(),p()[A+4>>2>>>0]=E.getMinutes(),p()[A+8>>2>>>0]=E.getHours(),p()[A+12>>2>>>0]=E.getDate(),p()[A+16>>2>>>0]=E.getMonth(),p()[A+20>>2>>>0]=E.getFullYear()-1900,p()[A+24>>2>>>0]=E.getDay();var D=new Date(E.getFullYear(),0,1),L=(E.getTime()-D.getTime())/864e5|0;p()[A+28>>2>>>0]=L,p()[A+36>>2>>>0]=-60*E.getTimezoneOffset(),L=new Date(E.getFullYear(),6,1).getTimezoneOffset(),E=0|(L!=(D=D.getTimezoneOffset())&&E.getTimezoneOffset()==Math.min(D,L)),p()[A+32>>2>>>0]=E},Ra:function(E){var A=new Date(p()[E+20>>2>>>0]+1900,p()[E+16>>2>>>0],p()[E+12>>2>>>0],p()[E+8>>2>>>0],p()[E+4>>2>>>0],p()[E>>2>>>0],0),D=p()[E+32>>2>>>0],L=A.getTimezoneOffset(),z=new Date(A.getFullYear(),0,1),q=new Date(A.getFullYear(),6,1).getTimezoneOffset(),Z=z.getTimezoneOffset(),ie=Math.min(Z,q);return 0>D?p()[E+32>>2>>>0]=Number(q!=Z&&ie==L):0<D!=(ie==L)&&(q=Math.max(Z,q),A.setTime(A.getTime()+6e4*((0<D?ie:q)-L))),p()[E+24>>2>>>0]=A.getDay(),D=(A.getTime()-z.getTime())/864e5|0,p()[E+28>>2>>>0]=D,p()[E>>2>>>0]=A.getSeconds(),p()[E+4>>2>>>0]=A.getMinutes(),p()[E+8>>2>>>0]=A.getHours(),p()[E+12>>2>>>0]=A.getDate(),p()[E+16>>2>>>0]=A.getMonth(),A.getTime()/1e3|0},Aa:G,Ba:H,Sa:function E(A,D,L){E.Ac||(E.Ac=!0,re(A,D,L))},y:function(){_e("")},U:function(){if(!x&&!O){var E="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";ct||(ct={}),ct[E]||(ct[E]=1,x&&(E="warning: "+E),R(E))}},ra:function(){return 4294901760},B:yt,Ia:function(E,A,D){f().copyWithin(E>>>0,A>>>0,A+D>>>0)},F:function(){return x?i(3993).cpus().length:navigator.hardwareConcurrency},Da:function(E,A,D){Me.length=A,D>>=3;for(var L=0;L<A;L++)Me[L]=c()[D+L>>>0];return(0>E?Ft[-E-1]:Tn[E]).apply(null,Me)},qa:function(E){var A=f().length;if((E>>>=0)<=A||4294901760<E)return!1;for(var D=1;4>=D;D*=2){var L=A*(1+.2/D);L=Math.min(L,E+100663296);var z=Math;L=Math.max(E,L),z=z.min.call(z,4294901760,L+(65536-L%65536)%65536);e:{try{U.grow(z-Q.byteLength+65535>>>16),Ae(U.buffer);var q=1;break e}catch{}q=void 0}if(q)return!0}return!1},Na:function(){throw"unwind"},Ga:W,Ha:we,J:ut,I:Oe,S:Ke,ga:st,R:Qt,d:function(){return We},na:function E(A,D){E.lc||(E.lc=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var z=new Uint8Array(1);return()=>(crypto.getRandomValues(z),z[0])}if(x)try{var q=i(Object(function(){var Z=new Error("Cannot find module 'crypto'");throw Z.code="MODULE_NOT_FOUND",Z}()));return()=>q.randomBytes(1)[0]}catch{}return()=>_e("randomDevice")}());for(var L=0;L<D;L++)a()[A+L>>0>>>0]=E.lc();return 0},ia:function(E,A,D){var L=me();try{return xe(E)(A,D)}catch(z){if(pe(L),z!==z+0)throw z;ge(1,0)}},ja:function(E,A,D){var L=me();try{return xe(E)(A,D)}catch(z){if(pe(L),z!==z+0)throw z;ge(1,0)}},K:function(E){var A=me();try{return xe(E)()}catch(D){if(pe(A),D!==D+0)throw D;ge(1,0)}},f:function(E,A){var D=me();try{return xe(E)(A)}catch(L){if(pe(D),L!==L+0)throw L;ge(1,0)}},P:function(E,A,D){var L=me();try{return xe(E)(A,D)}catch(z){if(pe(L),z!==z+0)throw z;ge(1,0)}},Q:function(E,A,D){var L=me();try{return xe(E)(A,D)}catch(z){if(pe(L),z!==z+0)throw z;ge(1,0)}},k:function(E,A,D){var L=me();try{return xe(E)(A,D)}catch(z){if(pe(L),z!==z+0)throw z;ge(1,0)}},p:function(E,A,D,L){var z=me();try{return xe(E)(A,D,L)}catch(q){if(pe(z),q!==q+0)throw q;ge(1,0)}},q:function(E,A,D,L,z){var q=me();try{return xe(E)(A,D,L,z)}catch(Z){if(pe(q),Z!==Z+0)throw Z;ge(1,0)}},N:function(E,A,D,L,z,q){var Z=me();try{return xe(E)(A,D,L,z,q)}catch(ie){if(pe(Z),ie!==ie+0)throw ie;ge(1,0)}},s:function(E,A,D,L,z,q){var Z=me();try{return xe(E)(A,D,L,z,q)}catch(ie){if(pe(Z),ie!==ie+0)throw ie;ge(1,0)}},w:function(E,A,D,L,z,q,Z){var ie=me();try{return xe(E)(A,D,L,z,q,Z)}catch(be){if(pe(ie),be!==be+0)throw be;ge(1,0)}},L:function(E,A,D,L,z,q,Z,ie){var be=me();try{return xe(E)(A,D,L,z,q,Z,ie)}catch(ye){if(pe(be),ye!==ye+0)throw ye;ge(1,0)}},E:function(E,A,D,L,z,q,Z,ie,be,ye,ke,tt){var Qe=me();try{return xe(E)(A,D,L,z,q,Z,ie,be,ye,ke,tt)}catch(Y){if(pe(Qe),Y!==Y+0)throw Y;ge(1,0)}},aa:function(E,A,D,L,z,q,Z,ie){var be=me();try{return yn(E,A,D,L,z,q,Z,ie)}catch(ye){if(pe(be),ye!==ye+0)throw ye;ge(1,0)}},_:function(E,A,D,L,z,q,Z){var ie=me();try{return dn(E,A,D,L,z,q,Z)}catch(be){if(pe(ie),be!==be+0)throw be;ge(1,0)}},Z:function(E,A,D,L,z){var q=me();try{return wn(E,A,D,L,z)}catch(Z){if(pe(q),Z!==Z+0)throw Z;ge(1,0)}},ca:function(E,A,D,L){var z=me();try{return bn(E,A,D,L)}catch(q){if(pe(z),q!==q+0)throw q;ge(1,0)}},$:function(E){var A=me();try{return hn(E)}catch(D){if(pe(A),D!==D+0)throw D;ge(1,0)}},ba:function(E,A){var D=me();try{return _n(E,A)}catch(L){if(pe(D),L!==L+0)throw L;ge(1,0)}},Y:function(E,A,D){var L=me();try{return fn(E,A,D)}catch(z){if(pe(L),z!==z+0)throw z;ge(1,0)}},g:function(E){var A=me();try{xe(E)()}catch(D){if(pe(A),D!==D+0)throw D;ge(1,0)}},r:function(E,A){var D=me();try{xe(E)(A)}catch(L){if(pe(D),L!==L+0)throw L;ge(1,0)}},i:function(E,A,D){var L=me();try{xe(E)(A,D)}catch(z){if(pe(L),z!==z+0)throw z;ge(1,0)}},ha:function(E,A,D,L){var z=me();try{xe(E)(A,D,L)}catch(q){if(pe(z),q!==q+0)throw q;ge(1,0)}},m:function(E,A,D,L){var z=me();try{xe(E)(A,D,L)}catch(q){if(pe(z),q!==q+0)throw q;ge(1,0)}},v:function(E,A,D,L,z){var q=me();try{xe(E)(A,D,L,z)}catch(Z){if(pe(q),Z!==Z+0)throw Z;ge(1,0)}},u:function(E,A,D,L,z,q){var Z=me();try{xe(E)(A,D,L,z,q)}catch(ie){if(pe(Z),ie!==ie+0)throw ie;ge(1,0)}},O:function(E,A,D,L,z,q,Z){var ie=me();try{xe(E)(A,D,L,z,q,Z)}catch(be){if(pe(ie),be!==be+0)throw be;ge(1,0)}},A:function(E,A,D,L,z,q,Z,ie){var be=me();try{xe(E)(A,D,L,z,q,Z,ie)}catch(ye){if(pe(be),ye!==ye+0)throw ye;ge(1,0)}},ka:function(E,A,D,L,z,q,Z,ie,be){var ye=me();try{xe(E)(A,D,L,z,q,Z,ie,be)}catch(ke){if(pe(ye),ke!==ke+0)throw ke;ge(1,0)}},C:function(E,A,D,L,z,q,Z,ie,be,ye,ke){var tt=me();try{xe(E)(A,D,L,z,q,Z,ie,be,ye,ke)}catch(Qe){if(pe(tt),Qe!==Qe+0)throw Qe;ge(1,0)}},D:function(E,A,D,L,z,q,Z,ie,be,ye,ke,tt,Qe,Y,ve,Ce){var at=me();try{xe(E)(A,D,L,z,q,Z,ie,be,ye,ke,tt,Qe,Y,ve,Ce)}catch(bt){if(pe(at),bt!==bt+0)throw bt;ge(1,0)}},fa:function(E,A,D,L,z,q,Z,ie){var be=me();try{pn(E,A,D,L,z,q,Z,ie)}catch(ye){if(pe(be),ye!==ye+0)throw ye;ge(1,0)}},da:function(E,A,D,L,z,q,Z,ie,be,ye,ke,tt){var Qe=me();try{gn(E,A,D,L,z,q,Z,ie,be,ye,ke,tt)}catch(Y){if(pe(Qe),Y!==Y+0)throw Y;ge(1,0)}},ea:function(E,A,D,L,z,q){var Z=me();try{mn(E,A,D,L,z,q)}catch(ie){if(pe(Z),ie!==ie+0)throw ie;ge(1,0)}},o:function(E){return E},a:U||n.wasmMemory,G:function(E){We=E},la:en,z:function(E,A,D,L){return en(E,A,D,L)}};(function(){function E(z,q){n.asm=z.exports,le.qc.push(n.asm.sb),Ue=n.asm.ub,He.unshift(n.asm.Va),K=q,T||(qe--,n.monitorRunDependencies&&n.monitorRunDependencies(qe),qe==0&&et&&(z=et,et=null,z()))}function A(z){E(z.instance,z.module)}function D(z){return function(){if(!B&&(S||O)){if(typeof fetch=="function"&&!Pe.startsWith("file://"))return fetch(Pe,{credentials:"same-origin"}).then(function(q){if(!q.ok)throw"failed to load wasm binary file at '"+Pe+"'";return q.arrayBuffer()}).catch(function(){return pt()});if(m)return new Promise(function(q,Z){m(Pe,function(ie){q(new Uint8Array(ie))},Z)})}return Promise.resolve().then(function(){return pt()})}().then(function(q){return WebAssembly.instantiate(q,L)}).then(function(q){return q}).then(z,function(q){R("failed to asynchronously prepare wasm: "+q),_e(q)})}var L={a:Sn};if(T||(qe++,n.monitorRunDependencies&&n.monitorRunDependencies(qe)),n.instantiateWasm)try{return n.instantiateWasm(L,E)}catch(z){return R("Module.instantiateWasm callback failed with error: "+z),!1}(B||typeof WebAssembly.instantiateStreaming!="function"||_t()||Pe.startsWith("file://")||x||typeof fetch!="function"?D(A):fetch(Pe,{credentials:"same-origin"}).then(function(z){return WebAssembly.instantiateStreaming(z,L).then(A,function(q){return R("wasm streaming compile failed: "+q),R("falling back to ArrayBuffer instantiation"),D(A)})})).catch(s)})(),n.___wasm_call_ctors=function(){return(n.___wasm_call_ctors=n.asm.Va).apply(null,arguments)},n._OrtInit=function(){return(n._OrtInit=n.asm.Wa).apply(null,arguments)},n._OrtCreateSessionOptions=function(){return(n._OrtCreateSessionOptions=n.asm.Xa).apply(null,arguments)},n._OrtAppendExecutionProvider=function(){return(n._OrtAppendExecutionProvider=n.asm.Ya).apply(null,arguments)},n._OrtAddSessionConfigEntry=function(){return(n._OrtAddSessionConfigEntry=n.asm.Za).apply(null,arguments)},n._OrtReleaseSessionOptions=function(){return(n._OrtReleaseSessionOptions=n.asm._a).apply(null,arguments)},n._OrtCreateSession=function(){return(n._OrtCreateSession=n.asm.$a).apply(null,arguments)},n._OrtReleaseSession=function(){return(n._OrtReleaseSession=n.asm.ab).apply(null,arguments)},n._OrtGetInputCount=function(){return(n._OrtGetInputCount=n.asm.bb).apply(null,arguments)},n._OrtGetOutputCount=function(){return(n._OrtGetOutputCount=n.asm.cb).apply(null,arguments)},n._OrtGetInputName=function(){return(n._OrtGetInputName=n.asm.db).apply(null,arguments)},n._OrtGetOutputName=function(){return(n._OrtGetOutputName=n.asm.eb).apply(null,arguments)},n._OrtFree=function(){return(n._OrtFree=n.asm.fb).apply(null,arguments)},n._OrtCreateTensor=function(){return(n._OrtCreateTensor=n.asm.gb).apply(null,arguments)},n._OrtGetTensorData=function(){return(n._OrtGetTensorData=n.asm.hb).apply(null,arguments)},n._OrtReleaseTensor=function(){return(n._OrtReleaseTensor=n.asm.ib).apply(null,arguments)},n._OrtCreateRunOptions=function(){return(n._OrtCreateRunOptions=n.asm.jb).apply(null,arguments)},n._OrtAddRunConfigEntry=function(){return(n._OrtAddRunConfigEntry=n.asm.kb).apply(null,arguments)},n._OrtReleaseRunOptions=function(){return(n._OrtReleaseRunOptions=n.asm.lb).apply(null,arguments)},n._OrtRun=function(){return(n._OrtRun=n.asm.mb).apply(null,arguments)},n._OrtEndProfiling=function(){return(n._OrtEndProfiling=n.asm.nb).apply(null,arguments)};var Rt=n._pthread_self=function(){return(Rt=n._pthread_self=n.asm.ob).apply(null,arguments)},Gt=n._malloc=function(){return(Gt=n._malloc=n.asm.pb).apply(null,arguments)},tn=n._free=function(){return(tn=n._free=n.asm.qb).apply(null,arguments)},nn=n._fflush=function(){return(nn=n._fflush=n.asm.rb).apply(null,arguments)};n.__emscripten_tls_init=function(){return(n.__emscripten_tls_init=n.asm.sb).apply(null,arguments)};var rn=n.___funcs_on_exit=function(){return(rn=n.___funcs_on_exit=n.asm.tb).apply(null,arguments)},on=n.__emscripten_thread_init=function(){return(on=n.__emscripten_thread_init=n.asm.vb).apply(null,arguments)};n.__emscripten_thread_crashed=function(){return(n.__emscripten_thread_crashed=n.asm.wb).apply(null,arguments)};var jt,sn=n._emscripten_run_in_main_runtime_thread_js=function(){return(sn=n._emscripten_run_in_main_runtime_thread_js=n.asm.xb).apply(null,arguments)},an=n.__emscripten_proxy_execute_task_queue=function(){return(an=n.__emscripten_proxy_execute_task_queue=n.asm.yb).apply(null,arguments)},qt=n.__emscripten_thread_free_data=function(){return(qt=n.__emscripten_thread_free_data=n.asm.zb).apply(null,arguments)},ln=n.__emscripten_thread_exit=function(){return(ln=n.__emscripten_thread_exit=n.asm.Ab).apply(null,arguments)},ge=n._setThrew=function(){return(ge=n._setThrew=n.asm.Bb).apply(null,arguments)},un=n._emscripten_stack_set_limits=function(){return(un=n._emscripten_stack_set_limits=n.asm.Cb).apply(null,arguments)},me=n.stackSave=function(){return(me=n.stackSave=n.asm.Db).apply(null,arguments)},pe=n.stackRestore=function(){return(pe=n.stackRestore=n.asm.Eb).apply(null,arguments)},Wt=n.stackAlloc=function(){return(Wt=n.stackAlloc=n.asm.Fb).apply(null,arguments)},Bt=n.___cxa_can_catch=function(){return(Bt=n.___cxa_can_catch=n.asm.Gb).apply(null,arguments)},cn=n.___cxa_is_pointer_type=function(){return(cn=n.___cxa_is_pointer_type=n.asm.Hb).apply(null,arguments)},hn=n.dynCall_j=function(){return(hn=n.dynCall_j=n.asm.Ib).apply(null,arguments)},dn=n.dynCall_iiiiij=function(){return(dn=n.dynCall_iiiiij=n.asm.Jb).apply(null,arguments)},fn=n.dynCall_jii=function(){return(fn=n.dynCall_jii=n.asm.Kb).apply(null,arguments)},pn=n.dynCall_viiiiij=function(){return(pn=n.dynCall_viiiiij=n.asm.Lb).apply(null,arguments)},mn=n.dynCall_vjji=function(){return(mn=n.dynCall_vjji=n.asm.Mb).apply(null,arguments)},gn=n.dynCall_viiijjjii=function(){return(gn=n.dynCall_viiijjjii=n.asm.Nb).apply(null,arguments)},bn=n.dynCall_iij=function(){return(bn=n.dynCall_iij=n.asm.Ob).apply(null,arguments)},_n=n.dynCall_ji=function(){return(_n=n.dynCall_ji=n.asm.Pb).apply(null,arguments)},yn=n.dynCall_iiiiiij=function(){return(yn=n.dynCall_iiiiiij=n.asm.Qb).apply(null,arguments)},wn=n.dynCall_iiij=function(){return(wn=n.dynCall_iiij=n.asm.Rb).apply(null,arguments)};function vn(){function E(){if(!jt&&(jt=!0,n.calledRun=!0,!oe)&&(T||lt(He),e(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),!T)){if(n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;){var A=n.postRun.shift();rt.unshift(A)}lt(rt)}}if(!(0<qe))if(T)e(n),T||lt(He),postMessage({cmd:"loaded"});else{if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)Ye();lt(Ge),0<qe||(n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),E()},1)):E())}}if(n.UTF8ToString=Te,n.stringToUTF8=function(E,A,D){return Ne(E,f(),A,D)},n.lengthBytesUTF8=Fe,n.keepRuntimeAlive=Xe,n.wasmMemory=U,n.stackSave=me,n.stackRestore=pe,n.stackAlloc=Wt,n.ExitStatus=it,n.PThread=le,et=function E(){jt||vn(),jt||(et=E)},n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);0<n.preInit.length;)n.preInit.pop()();return vn(),l.ready});d.exports=o},932:(d,t,i)=>{var r,o=(r=(r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(l){var a,f,p;l=l||{},a||(a=l!==void 0?l:{}),a.ready=new Promise(function(P,$){f=P,p=$});var h,c,n,e,s,u,m=Object.assign({},a),b="./this.program",g=(P,$)=>{throw $},_=typeof window=="object",y=typeof importScripts=="function",v=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w="";v?(w=y?i(908).dirname(w)+"/":"//",u=()=>{s||(e=i(1384),s=i(908))},h=function(P,$){return u(),P=s.normalize(P),e.readFileSync(P,$?void 0:"utf8")},n=P=>((P=h(P,!0)).buffer||(P=new Uint8Array(P)),P),c=(P,$,j)=>{u(),P=s.normalize(P),e.readFile(P,function(V,G){V?j(V):$(G.buffer)})},1<process.argv.length&&(b=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(P){if(!(P instanceof He))throw P}),process.on("unhandledRejection",function(P){throw P}),g=(P,$)=>{if(x||0<De)throw process.exitCode=P,$;$ instanceof He||O("exiting due to exception: "+$),process.exit(P)},a.inspect=function(){return"[Emscripten Module object]"}):(_||y)&&(y?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),r&&(w=r),w=w.indexOf("blob:")!==0?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",h=P=>{var $=new XMLHttpRequest;return $.open("GET",P,!1),$.send(null),$.responseText},y&&(n=P=>{var $=new XMLHttpRequest;return $.open("GET",P,!1),$.responseType="arraybuffer",$.send(null),new Uint8Array($.response)}),c=(P,$,j)=>{var V=new XMLHttpRequest;V.open("GET",P,!0),V.responseType="arraybuffer",V.onload=()=>{V.status==200||V.status==0&&V.response?$(V.response):j()},V.onerror=j,V.send(null)});var M,S=a.print||console.log.bind(console),O=a.printErr||console.warn.bind(console);Object.assign(a,m),m=null,a.thisProgram&&(b=a.thisProgram),a.quit&&(g=a.quit),a.wasmBinary&&(M=a.wasmBinary);var x=a.noExitRuntime||!1;typeof WebAssembly!="object"&&Ae("no native wasm support detected");var T,I,F,C,N,B,k=!1,R=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function X(P,$,j){var V=($>>>=0)+j;for(j=$;P[j]&&!(j>=V);)++j;if(16<j-$&&P.buffer&&R)return R.decode(P.subarray($,j));for(V="";$<j;){var G=P[$++];if(128&G){var H=63&P[$++];if((224&G)==192)V+=String.fromCharCode((31&G)<<6|H);else{var J=63&P[$++];65536>(G=(240&G)==224?(15&G)<<12|H<<6|J:(7&G)<<18|H<<12|J<<6|63&P[$++])?V+=String.fromCharCode(G):(G-=65536,V+=String.fromCharCode(55296|G>>10,56320|1023&G))}}else V+=String.fromCharCode(G)}return V}function U(P,$){return(P>>>=0)?X(C,P,$):""}function K(P,$,j,V){if(!(0<V))return 0;var G=j>>>=0;V=j+V-1;for(var H=0;H<P.length;++H){var J=P.charCodeAt(H);if(55296<=J&&57343>=J&&(J=65536+((1023&J)<<10)|1023&P.charCodeAt(++H)),127>=J){if(j>=V)break;$[j++>>>0]=J}else{if(2047>=J){if(j+1>=V)break;$[j++>>>0]=192|J>>6}else{if(65535>=J){if(j+2>=V)break;$[j++>>>0]=224|J>>12}else{if(j+3>=V)break;$[j++>>>0]=240|J>>18,$[j++>>>0]=128|J>>12&63}$[j++>>>0]=128|J>>6&63}$[j++>>>0]=128|63&J}}return $[j>>>0]=0,j-G}function Q(P){for(var $=0,j=0;j<P.length;++j){var V=P.charCodeAt(j);127>=V?$++:2047>=V?$+=2:55296<=V&&57343>=V?($+=4,++j):$+=3}return $}function se(){var P=T.buffer;I=P,a.HEAP8=F=new Int8Array(P),a.HEAP16=new Int16Array(P),a.HEAP32=N=new Int32Array(P),a.HEAPU8=C=new Uint8Array(P),a.HEAPU16=new Uint16Array(P),a.HEAPU32=B=new Uint32Array(P),a.HEAPF32=new Float32Array(P),a.HEAPF64=new Float64Array(P)}var te,ae=[],ne=[],ce=[],oe=[],De=0;function $e(){var P=a.preRun.shift();ae.unshift(P)}var Te,Ne=0,Fe=null;function Ae(P){throw a.onAbort&&a.onAbort(P),O(P="Aborted("+P+")"),k=!0,P=new WebAssembly.RuntimeError(P+". Build with -sASSERTIONS for more info."),p(P),P}function Se(){return Te.startsWith("data:application/octet-stream;base64,")}if(Te="ort-wasm.wasm",!Se()){var Ue=Te;Te=a.locateFile?a.locateFile(Ue,w):w+Ue}function Ge(){var P=Te;try{if(P==Te&&M)return new Uint8Array(M);if(n)return n(P);throw"both async and sync fetching of the wasm failed"}catch($){Ae($)}}function He(P){this.name="ExitStatus",this.message="Program terminated with exit("+P+")",this.status=P}function Ze(P){for(;0<P.length;)P.shift()(a)}var rt=[],Xe=0,Ye=0;function Pe(P){this.Db=P,this.zb=P-24,this.Ub=function($){B[this.zb+4>>2>>>0]=$},this.Eb=function(){return B[this.zb+4>>2>>>0]},this.Sb=function($){B[this.zb+8>>2>>>0]=$},this.Wb=function(){return B[this.zb+8>>2>>>0]},this.Tb=function(){N[this.zb>>2>>>0]=0},this.Ib=function($){F[this.zb+12>>0>>>0]=$?1:0},this.Pb=function(){return F[this.zb+12>>0>>>0]!=0},this.Jb=function($){F[this.zb+13>>0>>>0]=$?1:0},this.Lb=function(){return F[this.zb+13>>0>>>0]!=0},this.Rb=function($,j){this.Fb(0),this.Ub($),this.Sb(j),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){N[this.zb>>2>>>0]+=1},this.Xb=function(){var $=N[this.zb>>2>>>0];return N[this.zb>>2>>>0]=$-1,$===1},this.Fb=function($){B[this.zb+16>>2>>>0]=$},this.Ob=function(){return B[this.zb+16>>2>>>0]},this.Qb=function(){if(vt(this.Eb()))return B[this.Db>>2>>>0];var $=this.Ob();return $!==0?$:this.Db}}function qe(P){return ct(new Pe(P).zb)}var et=[];function _e(P){var $=et[P];return $||(P>=et.length&&(et.length=P+1),et[P]=$=te.get(P)),$}function _t(P){var $=Q(P)+1,j=xe($);return j&&K(P,F,j,$),j}var pt={};function Ft(){if(!it){var P,$={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"};for(P in pt)pt[P]===void 0?delete $[P]:$[P]=pt[P];var j=[];for(P in $)j.push(P+"="+$[P]);it=j}return it}var it,mt=[null,[],[]];function gt(P,$){var j=mt[P];$===0||$===10?((P===1?S:O)(X(j,0)),j.length=0):j.push($)}var Ve=0;function ut(P){return P%4==0&&(P%100!=0||P%400==0)}var le=[31,29,31,30,31,30,31,31,30,31,30,31],lt=[31,28,31,30,31,30,31,31,30,31,30,31];function $t(P,$,j,V){function G(W,we,Oe){for(W=typeof W=="number"?W.toString():W||"";W.length<we;)W=Oe[0]+W;return W}function H(W,we){return G(W,we,"0")}function J(W,we){function Oe(st){return 0>st?-1:0<st?1:0}var Ke;return(Ke=Oe(W.getFullYear()-we.getFullYear()))===0&&(Ke=Oe(W.getMonth()-we.getMonth()))===0&&(Ke=Oe(W.getDate()-we.getDate())),Ke}function re(W){switch(W.getDay()){case 0:return new Date(W.getFullYear()-1,11,29);case 1:return W;case 2:return new Date(W.getFullYear(),0,3);case 3:return new Date(W.getFullYear(),0,2);case 4:return new Date(W.getFullYear(),0,1);case 5:return new Date(W.getFullYear()-1,11,31);case 6:return new Date(W.getFullYear()-1,11,30)}}function ee(W){var we=W.Bb;for(W=new Date(new Date(W.Cb+1900,0,1).getTime());0<we;){var Oe=W.getMonth(),Ke=(ut(W.getFullYear())?le:lt)[Oe];if(!(we>Ke-W.getDate())){W.setDate(W.getDate()+we);break}we-=Ke-W.getDate()+1,W.setDate(1),11>Oe?W.setMonth(Oe+1):(W.setMonth(0),W.setFullYear(W.getFullYear()+1))}return Oe=new Date(W.getFullYear()+1,0,4),we=re(new Date(W.getFullYear(),0,4)),Oe=re(Oe),0>=J(we,W)?0>=J(Oe,W)?W.getFullYear()+1:W.getFullYear():W.getFullYear()-1}var fe=N[V+40>>2>>>0];for(var Me in V={$b:N[V>>2>>>0],Zb:N[V+4>>2>>>0],Gb:N[V+8>>2>>>0],Kb:N[V+12>>2>>>0],Hb:N[V+16>>2>>>0],Cb:N[V+20>>2>>>0],Ab:N[V+24>>2>>>0],Bb:N[V+28>>2>>>0],bc:N[V+32>>2>>>0],Yb:N[V+36>>2>>>0],ac:fe?U(fe):""},j=U(j),fe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})j=j.replace(new RegExp(Me,"g"),fe[Me]);var je="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Le="January February March April May June July August September October November December".split(" ");for(Me in fe={"%a":function(W){return je[W.Ab].substring(0,3)},"%A":function(W){return je[W.Ab]},"%b":function(W){return Le[W.Hb].substring(0,3)},"%B":function(W){return Le[W.Hb]},"%C":function(W){return H((W.Cb+1900)/100|0,2)},"%d":function(W){return H(W.Kb,2)},"%e":function(W){return G(W.Kb,2," ")},"%g":function(W){return ee(W).toString().substring(2)},"%G":function(W){return ee(W)},"%H":function(W){return H(W.Gb,2)},"%I":function(W){return(W=W.Gb)==0?W=12:12<W&&(W-=12),H(W,2)},"%j":function(W){for(var we=0,Oe=0;Oe<=W.Hb-1;we+=(ut(W.Cb+1900)?le:lt)[Oe++]);return H(W.Kb+we,3)},"%m":function(W){return H(W.Hb+1,2)},"%M":function(W){return H(W.Zb,2)},"%n":function(){return`
`},"%p":function(W){return 0<=W.Gb&&12>W.Gb?"AM":"PM"},"%S":function(W){return H(W.$b,2)},"%t":function(){return"	"},"%u":function(W){return W.Ab||7},"%U":function(W){return H(Math.floor((W.Bb+7-W.Ab)/7),2)},"%V":function(W){var we=Math.floor((W.Bb+7-(W.Ab+6)%7)/7);if(2>=(W.Ab+371-W.Bb-2)%7&&we++,we)we==53&&((Oe=(W.Ab+371-W.Bb)%7)==4||Oe==3&&ut(W.Cb)||(we=1));else{we=52;var Oe=(W.Ab+7-W.Bb-1)%7;(Oe==4||Oe==5&&ut(W.Cb%400-1))&&we++}return H(we,2)},"%w":function(W){return W.Ab},"%W":function(W){return H(Math.floor((W.Bb+7-(W.Ab+6)%7)/7),2)},"%y":function(W){return(W.Cb+1900).toString().substring(2)},"%Y":function(W){return W.Cb+1900},"%z":function(W){var we=0<=(W=W.Yb);return W=Math.abs(W)/60,(we?"+":"-")+String("0000"+(W/60*100+W%60)).slice(-4)},"%Z":function(W){return W.ac},"%%":function(){return"%"}},j=j.replace(/%%/g,"\0\0"),fe)j.includes(Me)&&(j=j.replace(new RegExp(Me,"g"),fe[Me](V)));return Me=function(W){var we=Array(Q(W)+1);return K(W,we,0,we.length),we}(j=j.replace(/\0\0/g,"%")),Me.length>$?0:(F.set(Me,P>>>0),Me.length-1)}var Nt={a:function(P){return xe(P+24)+24},m:function(P){return(P=new Pe(P)).Pb()||(P.Ib(!0),Xe--),P.Jb(!1),rt.push(P),P.Nb(),P.Qb()},ia:function(P){throw O("Unexpected exception thrown, this is not properly supported - aborting"),k=!0,P},w:function(){de(0);var P=rt.pop();if(P.Xb()&&!P.Lb()){var $=P.Wb();$&&_e($)(P.Db),qe(P.Db)}Ye=0},d:function(){var P=Ye;if(!P)return Ve=0;var $=new Pe(P);$.Fb(P);var j=$.Eb();if(!j)return Ve=0,P;for(var V=Array.prototype.slice.call(arguments),G=0;G<V.length;G++){var H=V[G];if(H===0||H===j)break;if(dt(H,j,$.zb+16))return Ve=H,P}return Ve=j,P},k:function(){var P=Ye;if(!P)return Ve=0;var $=new Pe(P);$.Fb(P);var j=$.Eb();if(!j)return Ve=0,P;for(var V=Array.prototype.slice.call(arguments),G=0;G<V.length;G++){var H=V[G];if(H===0||H===j)break;if(dt(H,j,$.zb+16))return Ve=H,P}return Ve=j,P},g:function(){var P=Ye;if(!P)return Ve=0;var $=new Pe(P);$.Fb(P);var j=$.Eb();if(!j)return Ve=0,P;for(var V=Array.prototype.slice.call(arguments),G=0;G<V.length;G++){var H=V[G];if(H===0||H===j)break;if(dt(H,j,$.zb+16))return Ve=H,P}return Ve=j,P},s:qe,L:function(){var P=rt.pop();P||Ae("no exception to throw");var $=P.Db;throw P.Lb()||(rt.push(P),P.Jb(!0),P.Ib(!1),Xe++),Ye=$,$},b:function(P,$,j){throw new Pe(P).Rb($,j),Ye=P,Xe++,P},la:function(){return Xe},i:function(P){throw Ye||(Ye=P),P},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){Ae("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){Ae("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(P,$){P=new Date(1e3*(B[P>>>2]+4294967296*N[P+4>>>2])),N[$>>2>>>0]=P.getUTCSeconds(),N[$+4>>2>>>0]=P.getUTCMinutes(),N[$+8>>2>>>0]=P.getUTCHours(),N[$+12>>2>>>0]=P.getUTCDate(),N[$+16>>2>>>0]=P.getUTCMonth(),N[$+20>>2>>>0]=P.getUTCFullYear()-1900,N[$+24>>2>>>0]=P.getUTCDay(),N[$+28>>2>>>0]=(P.getTime()-Date.UTC(P.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(P,$){P=new Date(1e3*(B[P>>>2]+4294967296*N[P+4>>>2])),N[$>>2>>>0]=P.getSeconds(),N[$+4>>2>>>0]=P.getMinutes(),N[$+8>>2>>>0]=P.getHours(),N[$+12>>2>>>0]=P.getDate(),N[$+16>>2>>>0]=P.getMonth(),N[$+20>>2>>>0]=P.getFullYear()-1900,N[$+24>>2>>>0]=P.getDay();var j=new Date(P.getFullYear(),0,1);N[$+28>>2>>>0]=(P.getTime()-j.getTime())/864e5|0,N[$+36>>2>>>0]=-60*P.getTimezoneOffset();var V=new Date(P.getFullYear(),6,1).getTimezoneOffset();j=j.getTimezoneOffset(),N[$+32>>2>>>0]=0|(V!=j&&P.getTimezoneOffset()==Math.min(j,V))},Fa:function(P){var $=new Date(N[P+20>>2>>>0]+1900,N[P+16>>2>>>0],N[P+12>>2>>>0],N[P+8>>2>>>0],N[P+4>>2>>>0],N[P>>2>>>0],0),j=N[P+32>>2>>>0],V=$.getTimezoneOffset(),G=new Date($.getFullYear(),0,1),H=new Date($.getFullYear(),6,1).getTimezoneOffset(),J=G.getTimezoneOffset(),re=Math.min(J,H);return 0>j?N[P+32>>2>>>0]=Number(H!=J&&re==V):0<j!=(re==V)&&(H=Math.max(J,H),$.setTime($.getTime()+6e4*((0<j?re:H)-V))),N[P+24>>2>>>0]=$.getDay(),N[P+28>>2>>>0]=($.getTime()-G.getTime())/864e5|0,N[P>>2>>>0]=$.getSeconds(),N[P+4>>2>>>0]=$.getMinutes(),N[P+8>>2>>>0]=$.getHours(),N[P+12>>2>>>0]=$.getDate(),N[P+16>>2>>>0]=$.getMonth(),$.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function P($,j,V){P.Vb||(P.Vb=!0,function(G,H,J){function re(Le){return(Le=Le.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Le[1]:"GMT"}var ee=new Date().getFullYear(),fe=new Date(ee,0,1),Me=new Date(ee,6,1);ee=fe.getTimezoneOffset();var je=Me.getTimezoneOffset();N[G>>2>>>0]=60*Math.max(ee,je),N[H>>2>>>0]=Number(ee!=je),G=re(fe),H=re(Me),G=_t(G),H=_t(H),je<ee?(B[J>>2>>>0]=G,B[J+4>>2>>>0]=H):(B[J>>2>>>0]=H,B[J+4>>2>>>0]=G)}($,j,V))},B:function(){Ae("")},ma:function(){return 4294901760},I:v?()=>{var P=process.hrtime();return 1e3*P[0]+P[1]/1e6}:()=>performance.now(),xa:function(P,$,j){C.copyWithin(P>>>0,$>>>0,$+j>>>0)},G:function(P){var $=C.length;if(4294901760<(P>>>=0))return!1;for(var j=1;4>=j;j*=2){var V=$*(1+.2/j);V=Math.min(V,P+100663296);var G=Math;V=Math.max(P,V),G=G.min.call(G,4294901760,V+(65536-V%65536)%65536);e:{try{T.grow(G-I.byteLength+65535>>>16),se();var H=1;break e}catch{}H=void 0}if(H)return!0}return!1},va:function(P,$){var j=0;return Ft().forEach(function(V,G){var H=$+j;for(G=B[P+4*G>>2>>>0]=H,H=0;H<V.length;++H)F[G++>>0>>>0]=V.charCodeAt(H);F[G>>0>>>0]=0,j+=V.length+1}),0},wa:function(P,$){var j=Ft();B[P>>2>>>0]=j.length;var V=0;return j.forEach(function(G){V+=G.length+1}),B[$>>2>>>0]=V,0},ba:function(P){x||0<De||(ht(),Ze(ce),yt(0),mt[1].length&&gt(1,10),mt[2].length&&gt(2,10)),x||0<De||(a.onExit&&a.onExit(P),k=!0),g(P,new He(P))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(P,$,j,V){for(var G=0,H=0;H<j;H++){var J=B[$>>2>>>0],re=B[$+4>>2>>>0];$+=8;for(var ee=0;ee<re;ee++)gt(P,C[J+ee>>>0]);G+=re}return B[V>>2>>>0]=G,0},c:function(){return Ve},ja:function P($,j){P.Mb||(P.Mb=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var G=new Uint8Array(1);return()=>(crypto.getRandomValues(G),G[0])}if(v)try{var H=i(Object(function(){var J=new Error("Cannot find module 'crypto'");throw J.code="MODULE_NOT_FOUND",J}()));return()=>H.randomBytes(1)[0]}catch{}return()=>Ae("randomDevice")}());for(var V=0;V<j;V++)F[$+V>>0>>>0]=P.Mb();return 0},ea:function(P,$,j){var V=ue();try{return _e(P)($,j)}catch(G){if(he(V),G!==G+0)throw G;de(1,0)}},fa:function(P,$,j){var V=ue();try{return _e(P)($,j)}catch(G){if(he(V),G!==G+0)throw G;de(1,0)}},J:function(P){var $=ue();try{return _e(P)()}catch(j){if(he($),j!==j+0)throw j;de(1,0)}},e:function(P,$){var j=ue();try{return _e(P)($)}catch(V){if(he(j),V!==V+0)throw V;de(1,0)}},N:function(P,$,j){var V=ue();try{return _e(P)($,j)}catch(G){if(he(V),G!==G+0)throw G;de(1,0)}},O:function(P,$,j){var V=ue();try{return _e(P)($,j)}catch(G){if(he(V),G!==G+0)throw G;de(1,0)}},j:function(P,$,j){var V=ue();try{return _e(P)($,j)}catch(G){if(he(V),G!==G+0)throw G;de(1,0)}},o:function(P,$,j,V){var G=ue();try{return _e(P)($,j,V)}catch(H){if(he(G),H!==H+0)throw H;de(1,0)}},p:function(P,$,j,V,G){var H=ue();try{return _e(P)($,j,V,G)}catch(J){if(he(H),J!==J+0)throw J;de(1,0)}},M:function(P,$,j,V,G,H){var J=ue();try{return _e(P)($,j,V,G,H)}catch(re){if(he(J),re!==re+0)throw re;de(1,0)}},r:function(P,$,j,V,G,H){var J=ue();try{return _e(P)($,j,V,G,H)}catch(re){if(he(J),re!==re+0)throw re;de(1,0)}},v:function(P,$,j,V,G,H,J){var re=ue();try{return _e(P)($,j,V,G,H,J)}catch(ee){if(he(re),ee!==ee+0)throw ee;de(1,0)}},K:function(P,$,j,V,G,H,J,re){var ee=ue();try{return _e(P)($,j,V,G,H,J,re)}catch(fe){if(he(ee),fe!==fe+0)throw fe;de(1,0)}},D:function(P,$,j,V,G,H,J,re,ee,fe,Me,je){var Le=ue();try{return _e(P)($,j,V,G,H,J,re,ee,fe,Me,je)}catch(W){if(he(Le),W!==W+0)throw W;de(1,0)}},X:function(P,$,j,V,G,H,J,re){var ee=ue();try{return It(P,$,j,V,G,H,J,re)}catch(fe){if(he(ee),fe!==fe+0)throw fe;de(1,0)}},V:function(P,$,j,V,G,H,J){var re=ue();try{return Tt(P,$,j,V,G,H,J)}catch(ee){if(he(re),ee!==ee+0)throw ee;de(1,0)}},U:function(P,$,j,V,G){var H=ue();try{return Dt(P,$,j,V,G)}catch(J){if(he(H),J!==J+0)throw J;de(1,0)}},Z:function(P,$,j,V){var G=ue();try{return At(P,$,j,V)}catch(H){if(he(G),H!==H+0)throw H;de(1,0)}},W:function(P){var $=ue();try{return xt(P)}catch(j){if(he($),j!==j+0)throw j;de(1,0)}},Y:function(P,$){var j=ue();try{return Pt(P,$)}catch(V){if(he(j),V!==V+0)throw V;de(1,0)}},T:function(P,$,j){var V=ue();try{return St(P,$,j)}catch(G){if(he(V),G!==G+0)throw G;de(1,0)}},f:function(P){var $=ue();try{_e(P)()}catch(j){if(he($),j!==j+0)throw j;de(1,0)}},q:function(P,$){var j=ue();try{_e(P)($)}catch(V){if(he(j),V!==V+0)throw V;de(1,0)}},h:function(P,$,j){var V=ue();try{_e(P)($,j)}catch(G){if(he(V),G!==G+0)throw G;de(1,0)}},da:function(P,$,j,V){var G=ue();try{_e(P)($,j,V)}catch(H){if(he(G),H!==H+0)throw H;de(1,0)}},l:function(P,$,j,V){var G=ue();try{_e(P)($,j,V)}catch(H){if(he(G),H!==H+0)throw H;de(1,0)}},t:function(P,$,j,V,G){var H=ue();try{_e(P)($,j,V,G)}catch(J){if(he(H),J!==J+0)throw J;de(1,0)}},u:function(P,$,j,V,G,H){var J=ue();try{_e(P)($,j,V,G,H)}catch(re){if(he(J),re!==re+0)throw re;de(1,0)}},x:function(P,$,j,V,G,H,J){var re=ue();try{_e(P)($,j,V,G,H,J)}catch(ee){if(he(re),ee!==ee+0)throw ee;de(1,0)}},z:function(P,$,j,V,G,H,J,re){var ee=ue();try{_e(P)($,j,V,G,H,J,re)}catch(fe){if(he(ee),fe!==fe+0)throw fe;de(1,0)}},ga:function(P,$,j,V,G,H,J,re,ee){var fe=ue();try{_e(P)($,j,V,G,H,J,re,ee)}catch(Me){if(he(fe),Me!==Me+0)throw Me;de(1,0)}},A:function(P,$,j,V,G,H,J,re,ee,fe,Me){var je=ue();try{_e(P)($,j,V,G,H,J,re,ee,fe,Me)}catch(Le){if(he(je),Le!==Le+0)throw Le;de(1,0)}},C:function(P,$,j,V,G,H,J,re,ee,fe,Me,je,Le,W,we,Oe){var Ke=ue();try{_e(P)($,j,V,G,H,J,re,ee,fe,Me,je,Le,W,we,Oe)}catch(st){if(he(Ke),st!==st+0)throw st;de(1,0)}},aa:function(P,$,j,V,G,H,J,re){var ee=ue();try{Mt(P,$,j,V,G,H,J,re)}catch(fe){if(he(ee),fe!==fe+0)throw fe;de(1,0)}},_:function(P,$,j,V,G,H,J,re,ee,fe,Me,je){var Le=ue();try{Ot(P,$,j,V,G,H,J,re,ee,fe,Me,je)}catch(W){if(he(Le),W!==W+0)throw W;de(1,0)}},$:function(P,$,j,V,G,H){var J=ue();try{Et(P,$,j,V,G,H)}catch(re){if(he(J),re!==re+0)throw re;de(1,0)}},n:function(P){return P},F:function(P){Ve=P},ha:$t,y:function(P,$,j,V){return $t(P,$,j,V)}};(function(){function P(G){a.asm=G.exports,T=a.asm.Ka,se(),te=a.asm.ib,ne.unshift(a.asm.La),Ne--,a.monitorRunDependencies&&a.monitorRunDependencies(Ne),Ne==0&&Fe&&(G=Fe,Fe=null,G())}function $(G){P(G.instance)}function j(G){return function(){if(!M&&(_||y)){if(typeof fetch=="function"&&!Te.startsWith("file://"))return fetch(Te,{credentials:"same-origin"}).then(function(H){if(!H.ok)throw"failed to load wasm binary file at '"+Te+"'";return H.arrayBuffer()}).catch(function(){return Ge()});if(c)return new Promise(function(H,J){c(Te,function(re){H(new Uint8Array(re))},J)})}return Promise.resolve().then(function(){return Ge()})}().then(function(H){return WebAssembly.instantiate(H,V)}).then(function(H){return H}).then(G,function(H){O("failed to asynchronously prepare wasm: "+H),Ae(H)})}var V={a:Nt};if(Ne++,a.monitorRunDependencies&&a.monitorRunDependencies(Ne),a.instantiateWasm)try{return a.instantiateWasm(V,P)}catch(G){return O("Module.instantiateWasm callback failed with error: "+G),!1}(M||typeof WebAssembly.instantiateStreaming!="function"||Se()||Te.startsWith("file://")||v||typeof fetch!="function"?j($):fetch(Te,{credentials:"same-origin"}).then(function(G){return WebAssembly.instantiateStreaming(G,V).then($,function(H){return O("wasm streaming compile failed: "+H),O("falling back to ArrayBuffer instantiation"),j($)})})).catch(p)})(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.La).apply(null,arguments)},a._OrtInit=function(){return(a._OrtInit=a.asm.Ma).apply(null,arguments)},a._OrtCreateSessionOptions=function(){return(a._OrtCreateSessionOptions=a.asm.Na).apply(null,arguments)},a._OrtAppendExecutionProvider=function(){return(a._OrtAppendExecutionProvider=a.asm.Oa).apply(null,arguments)},a._OrtAddSessionConfigEntry=function(){return(a._OrtAddSessionConfigEntry=a.asm.Pa).apply(null,arguments)},a._OrtReleaseSessionOptions=function(){return(a._OrtReleaseSessionOptions=a.asm.Qa).apply(null,arguments)},a._OrtCreateSession=function(){return(a._OrtCreateSession=a.asm.Ra).apply(null,arguments)},a._OrtReleaseSession=function(){return(a._OrtReleaseSession=a.asm.Sa).apply(null,arguments)},a._OrtGetInputCount=function(){return(a._OrtGetInputCount=a.asm.Ta).apply(null,arguments)},a._OrtGetOutputCount=function(){return(a._OrtGetOutputCount=a.asm.Ua).apply(null,arguments)},a._OrtGetInputName=function(){return(a._OrtGetInputName=a.asm.Va).apply(null,arguments)},a._OrtGetOutputName=function(){return(a._OrtGetOutputName=a.asm.Wa).apply(null,arguments)},a._OrtFree=function(){return(a._OrtFree=a.asm.Xa).apply(null,arguments)},a._OrtCreateTensor=function(){return(a._OrtCreateTensor=a.asm.Ya).apply(null,arguments)},a._OrtGetTensorData=function(){return(a._OrtGetTensorData=a.asm.Za).apply(null,arguments)},a._OrtReleaseTensor=function(){return(a._OrtReleaseTensor=a.asm._a).apply(null,arguments)},a._OrtCreateRunOptions=function(){return(a._OrtCreateRunOptions=a.asm.$a).apply(null,arguments)},a._OrtAddRunConfigEntry=function(){return(a._OrtAddRunConfigEntry=a.asm.ab).apply(null,arguments)},a._OrtReleaseRunOptions=function(){return(a._OrtReleaseRunOptions=a.asm.bb).apply(null,arguments)},a._OrtRun=function(){return(a._OrtRun=a.asm.cb).apply(null,arguments)},a._OrtEndProfiling=function(){return(a._OrtEndProfiling=a.asm.db).apply(null,arguments)};var ot,xe=a._malloc=function(){return(xe=a._malloc=a.asm.eb).apply(null,arguments)},ct=a._free=function(){return(ct=a._free=a.asm.fb).apply(null,arguments)},yt=a._fflush=function(){return(yt=a._fflush=a.asm.gb).apply(null,arguments)},ht=a.___funcs_on_exit=function(){return(ht=a.___funcs_on_exit=a.asm.hb).apply(null,arguments)},de=a._setThrew=function(){return(de=a._setThrew=a.asm.jb).apply(null,arguments)},ue=a.stackSave=function(){return(ue=a.stackSave=a.asm.kb).apply(null,arguments)},he=a.stackRestore=function(){return(he=a.stackRestore=a.asm.lb).apply(null,arguments)},wt=a.stackAlloc=function(){return(wt=a.stackAlloc=a.asm.mb).apply(null,arguments)},dt=a.___cxa_can_catch=function(){return(dt=a.___cxa_can_catch=a.asm.nb).apply(null,arguments)},vt=a.___cxa_is_pointer_type=function(){return(vt=a.___cxa_is_pointer_type=a.asm.ob).apply(null,arguments)},xt=a.dynCall_j=function(){return(xt=a.dynCall_j=a.asm.pb).apply(null,arguments)},Tt=a.dynCall_iiiiij=function(){return(Tt=a.dynCall_iiiiij=a.asm.qb).apply(null,arguments)},St=a.dynCall_jii=function(){return(St=a.dynCall_jii=a.asm.rb).apply(null,arguments)},Mt=a.dynCall_viiiiij=function(){return(Mt=a.dynCall_viiiiij=a.asm.sb).apply(null,arguments)},Et=a.dynCall_vjji=function(){return(Et=a.dynCall_vjji=a.asm.tb).apply(null,arguments)},Ot=a.dynCall_viiijjjii=function(){return(Ot=a.dynCall_viiijjjii=a.asm.ub).apply(null,arguments)},At=a.dynCall_iij=function(){return(At=a.dynCall_iij=a.asm.vb).apply(null,arguments)},Pt=a.dynCall_ji=function(){return(Pt=a.dynCall_ji=a.asm.wb).apply(null,arguments)},It=a.dynCall_iiiiiij=function(){return(It=a.dynCall_iiiiiij=a.asm.xb).apply(null,arguments)},Dt=a.dynCall_iiij=function(){return(Dt=a.dynCall_iiij=a.asm.yb).apply(null,arguments)};function Ct(){function P(){if(!ot&&(ot=!0,a.calledRun=!0,!k)){if(Ze(ne),f(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var $=a.postRun.shift();oe.unshift($)}Ze(oe)}}if(!(0<Ne)){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)$e();Ze(ae),0<Ne||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),P()},1)):P())}}if(a.UTF8ToString=U,a.stringToUTF8=function(P,$,j){return K(P,C,$,j)},a.lengthBytesUTF8=Q,a.stackSave=ue,a.stackRestore=he,a.stackAlloc=wt,Fe=function P(){ot||Ct(),ot||(Fe=P)},a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return Ct(),l.ready});d.exports=o},4537:d=>{d.exports=function(t,i){for(var r=new Array(arguments.length-1),o=0,l=2,a=!0;l<arguments.length;)r[o++]=arguments[l++];return new Promise(function(f,p){r[o]=function(h){if(a)if(a=!1,h)p(h);else{for(var c=new Array(arguments.length-1),n=0;n<c.length;)c[n++]=arguments[n];f.apply(null,c)}};try{t.apply(i||null,r)}catch(h){a&&(a=!1,p(h))}})}},7419:(d,t)=>{var i=t;i.length=function(f){var p=f.length;if(!p)return 0;for(var h=0;--p%4>1&&f.charAt(p)==="=";)++h;return Math.ceil(3*f.length)/4-h};for(var r=new Array(64),o=new Array(123),l=0;l<64;)o[r[l]=l<26?l+65:l<52?l+71:l<62?l-4:l-59|43]=l++;i.encode=function(f,p,h){for(var c,n=null,e=[],s=0,u=0;p<h;){var m=f[p++];switch(u){case 0:e[s++]=r[m>>2],c=(3&m)<<4,u=1;break;case 1:e[s++]=r[c|m>>4],c=(15&m)<<2,u=2;break;case 2:e[s++]=r[c|m>>6],e[s++]=r[63&m],u=0}s>8191&&((n||(n=[])).push(String.fromCharCode.apply(String,e)),s=0)}return u&&(e[s++]=r[c],e[s++]=61,u===1&&(e[s++]=61)),n?(s&&n.push(String.fromCharCode.apply(String,e.slice(0,s))),n.join("")):String.fromCharCode.apply(String,e.slice(0,s))};var a="invalid encoding";i.decode=function(f,p,h){for(var c,n=h,e=0,s=0;s<f.length;){var u=f.charCodeAt(s++);if(u===61&&e>1)break;if((u=o[u])===void 0)throw Error(a);switch(e){case 0:c=u,e=1;break;case 1:p[h++]=c<<2|(48&u)>>4,c=u,e=2;break;case 2:p[h++]=(15&c)<<4|(60&u)>>2,c=u,e=3;break;case 3:p[h++]=(3&c)<<6|u,e=0}}if(e===1)throw Error(a);return h-n},i.test=function(f){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(f)}},9211:d=>{function t(){this._listeners={}}d.exports=t,t.prototype.on=function(i,r,o){return(this._listeners[i]||(this._listeners[i]=[])).push({fn:r,ctx:o||this}),this},t.prototype.off=function(i,r){if(i===void 0)this._listeners={};else if(r===void 0)this._listeners[i]=[];else for(var o=this._listeners[i],l=0;l<o.length;)o[l].fn===r?o.splice(l,1):++l;return this},t.prototype.emit=function(i){var r=this._listeners[i];if(r){for(var o=[],l=1;l<arguments.length;)o.push(arguments[l++]);for(l=0;l<r.length;)r[l].fn.apply(r[l++].ctx,o)}return this}},945:d=>{function t(a){return typeof Float32Array<"u"?function(){var f=new Float32Array([-0]),p=new Uint8Array(f.buffer),h=p[3]===128;function c(u,m,b){f[0]=u,m[b]=p[0],m[b+1]=p[1],m[b+2]=p[2],m[b+3]=p[3]}function n(u,m,b){f[0]=u,m[b]=p[3],m[b+1]=p[2],m[b+2]=p[1],m[b+3]=p[0]}function e(u,m){return p[0]=u[m],p[1]=u[m+1],p[2]=u[m+2],p[3]=u[m+3],f[0]}function s(u,m){return p[3]=u[m],p[2]=u[m+1],p[1]=u[m+2],p[0]=u[m+3],f[0]}a.writeFloatLE=h?c:n,a.writeFloatBE=h?n:c,a.readFloatLE=h?e:s,a.readFloatBE=h?s:e}():function(){function f(h,c,n,e){var s=c<0?1:0;if(s&&(c=-c),c===0)h(1/c>0?0:2147483648,n,e);else if(isNaN(c))h(2143289344,n,e);else if(c>34028234663852886e22)h((s<<31|2139095040)>>>0,n,e);else if(c<11754943508222875e-54)h((s<<31|Math.round(c/1401298464324817e-60))>>>0,n,e);else{var u=Math.floor(Math.log(c)/Math.LN2);h((s<<31|u+127<<23|8388607&Math.round(c*Math.pow(2,-u)*8388608))>>>0,n,e)}}function p(h,c,n){var e=h(c,n),s=2*(e>>31)+1,u=e>>>23&255,m=8388607&e;return u===255?m?NaN:s*(1/0):u===0?1401298464324817e-60*s*m:s*Math.pow(2,u-150)*(m+8388608)}a.writeFloatLE=f.bind(null,i),a.writeFloatBE=f.bind(null,r),a.readFloatLE=p.bind(null,o),a.readFloatBE=p.bind(null,l)}(),typeof Float64Array<"u"?function(){var f=new Float64Array([-0]),p=new Uint8Array(f.buffer),h=p[7]===128;function c(u,m,b){f[0]=u,m[b]=p[0],m[b+1]=p[1],m[b+2]=p[2],m[b+3]=p[3],m[b+4]=p[4],m[b+5]=p[5],m[b+6]=p[6],m[b+7]=p[7]}function n(u,m,b){f[0]=u,m[b]=p[7],m[b+1]=p[6],m[b+2]=p[5],m[b+3]=p[4],m[b+4]=p[3],m[b+5]=p[2],m[b+6]=p[1],m[b+7]=p[0]}function e(u,m){return p[0]=u[m],p[1]=u[m+1],p[2]=u[m+2],p[3]=u[m+3],p[4]=u[m+4],p[5]=u[m+5],p[6]=u[m+6],p[7]=u[m+7],f[0]}function s(u,m){return p[7]=u[m],p[6]=u[m+1],p[5]=u[m+2],p[4]=u[m+3],p[3]=u[m+4],p[2]=u[m+5],p[1]=u[m+6],p[0]=u[m+7],f[0]}a.writeDoubleLE=h?c:n,a.writeDoubleBE=h?n:c,a.readDoubleLE=h?e:s,a.readDoubleBE=h?s:e}():function(){function f(h,c,n,e,s,u){var m=e<0?1:0;if(m&&(e=-e),e===0)h(0,s,u+c),h(1/e>0?0:2147483648,s,u+n);else if(isNaN(e))h(0,s,u+c),h(2146959360,s,u+n);else if(e>17976931348623157e292)h(0,s,u+c),h((m<<31|2146435072)>>>0,s,u+n);else{var b;if(e<22250738585072014e-324)h((b=e/5e-324)>>>0,s,u+c),h((m<<31|b/4294967296)>>>0,s,u+n);else{var g=Math.floor(Math.log(e)/Math.LN2);g===1024&&(g=1023),h(4503599627370496*(b=e*Math.pow(2,-g))>>>0,s,u+c),h((m<<31|g+1023<<20|1048576*b&1048575)>>>0,s,u+n)}}}function p(h,c,n,e,s){var u=h(e,s+c),m=h(e,s+n),b=2*(m>>31)+1,g=m>>>20&2047,_=4294967296*(1048575&m)+u;return g===2047?_?NaN:b*(1/0):g===0?5e-324*b*_:b*Math.pow(2,g-1075)*(_+4503599627370496)}a.writeDoubleLE=f.bind(null,i,0,4),a.writeDoubleBE=f.bind(null,r,4,0),a.readDoubleLE=p.bind(null,o,0,4),a.readDoubleBE=p.bind(null,l,4,0)}(),a}function i(a,f,p){f[p]=255&a,f[p+1]=a>>>8&255,f[p+2]=a>>>16&255,f[p+3]=a>>>24}function r(a,f,p){f[p]=a>>>24,f[p+1]=a>>>16&255,f[p+2]=a>>>8&255,f[p+3]=255&a}function o(a,f){return(a[f]|a[f+1]<<8|a[f+2]<<16|a[f+3]<<24)>>>0}function l(a,f){return(a[f]<<24|a[f+1]<<16|a[f+2]<<8|a[f+3])>>>0}d.exports=t(t)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(d){}return null}module.exports=inquire},6662:d=>{d.exports=function(t,i,r){var o=r||8192,l=o>>>1,a=null,f=o;return function(p){if(p<1||p>l)return t(p);f+p>o&&(a=t(o),f=0);var h=i.call(a,f,f+=p);return 7&f&&(f=1+(7|f)),h}}},4997:(d,t)=>{var i=t;i.length=function(r){for(var o=0,l=0,a=0;a<r.length;++a)(l=r.charCodeAt(a))<128?o+=1:l<2048?o+=2:(64512&l)==55296&&(64512&r.charCodeAt(a+1))==56320?(++a,o+=4):o+=3;return o},i.read=function(r,o,l){if(l-o<1)return"";for(var a,f=null,p=[],h=0;o<l;)(a=r[o++])<128?p[h++]=a:a>191&&a<224?p[h++]=(31&a)<<6|63&r[o++]:a>239&&a<365?(a=((7&a)<<18|(63&r[o++])<<12|(63&r[o++])<<6|63&r[o++])-65536,p[h++]=55296+(a>>10),p[h++]=56320+(1023&a)):p[h++]=(15&a)<<12|(63&r[o++])<<6|63&r[o++],h>8191&&((f||(f=[])).push(String.fromCharCode.apply(String,p)),h=0);return f?(h&&f.push(String.fromCharCode.apply(String,p.slice(0,h))),f.join("")):String.fromCharCode.apply(String,p.slice(0,h))},i.write=function(r,o,l){for(var a,f,p=l,h=0;h<r.length;++h)(a=r.charCodeAt(h))<128?o[l++]=a:a<2048?(o[l++]=a>>6|192,o[l++]=63&a|128):(64512&a)==55296&&(64512&(f=r.charCodeAt(h+1)))==56320?(a=65536+((1023&a)<<10)+(1023&f),++h,o[l++]=a>>18|240,o[l++]=a>>12&63|128,o[l++]=a>>6&63|128,o[l++]=63&a|128):(o[l++]=a>>12|224,o[l++]=a>>6&63|128,o[l++]=63&a|128);return l-p}},3442:(d,t)=>{t.__esModule=!0;var i=function(){function r(o){if(!o)throw new TypeError("Invalid argument; `value` has no value.");this.value=r.EMPTY,o&&r.isGuid(o)&&(this.value=o)}return r.isGuid=function(o){var l=o.toString();return o&&(o instanceof r||r.validator.test(l))},r.create=function(){return new r([r.gen(2),r.gen(1),r.gen(1),r.gen(1),r.gen(3)].join("-"))},r.createEmpty=function(){return new r("emptyguid")},r.parse=function(o){return new r(o)},r.raw=function(){return[r.gen(2),r.gen(1),r.gen(1),r.gen(1),r.gen(3)].join("-")},r.gen=function(o){for(var l="",a=0;a<o;a++)l+=(65536*(1+Math.random())|0).toString(16).substring(1);return l},r.prototype.equals=function(o){return r.isGuid(o)&&this.value===o.toString()},r.prototype.isEmpty=function(){return this.value===r.EMPTY},r.prototype.toString=function(){return this.value},r.prototype.toJSON=function(){return{value:this.value}},r.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),r.EMPTY="00000000-0000-0000-0000-000000000000",r}();t.Guid=i},3720:d=>{d.exports=i;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function i(x,T,I){this.low=0|x,this.high=0|T,this.unsigned=!!I}function r(x){return(x&&x.__isLong__)===!0}i.prototype.__isLong__,Object.defineProperty(i.prototype,"__isLong__",{value:!0}),i.isLong=r;var o={},l={};function a(x,T){var I,F,C;return T?(C=0<=(x>>>=0)&&x<256)&&(F=l[x])?F:(I=p(x,(0|x)<0?-1:0,!0),C&&(l[x]=I),I):(C=-128<=(x|=0)&&x<128)&&(F=o[x])?F:(I=p(x,x<0?-1:0,!1),C&&(o[x]=I),I)}function f(x,T){if(isNaN(x))return T?g:b;if(T){if(x<0)return g;if(x>=s)return M}else{if(x<=-u)return S;if(x+1>=u)return w}return x<0?f(-x,T).neg():p(x%e|0,x/e|0,T)}function p(x,T,I){return new i(x,T,I)}i.fromInt=a,i.fromNumber=f,i.fromBits=p;var h=Math.pow;function c(x,T,I){if(x.length===0)throw Error("empty string");if(x==="NaN"||x==="Infinity"||x==="+Infinity"||x==="-Infinity")return b;if(typeof T=="number"?(I=T,T=!1):T=!!T,(I=I||10)<2||36<I)throw RangeError("radix");var F;if((F=x.indexOf("-"))>0)throw Error("interior hyphen");if(F===0)return c(x.substring(1),T,I).neg();for(var C=f(h(I,8)),N=b,B=0;B<x.length;B+=8){var k=Math.min(8,x.length-B),R=parseInt(x.substring(B,B+k),I);if(k<8){var X=f(h(I,k));N=N.mul(X).add(f(R))}else N=(N=N.mul(C)).add(f(R))}return N.unsigned=T,N}function n(x,T){return typeof x=="number"?f(x,T):typeof x=="string"?c(x,T):p(x.low,x.high,typeof T=="boolean"?T:x.unsigned)}i.fromString=c,i.fromValue=n;var e=4294967296,s=e*e,u=s/2,m=a(1<<24),b=a(0);i.ZERO=b;var g=a(0,!0);i.UZERO=g;var _=a(1);i.ONE=_;var y=a(1,!0);i.UONE=y;var v=a(-1);i.NEG_ONE=v;var w=p(-1,2147483647,!1);i.MAX_VALUE=w;var M=p(-1,-1,!0);i.MAX_UNSIGNED_VALUE=M;var S=p(0,-2147483648,!1);i.MIN_VALUE=S;var O=i.prototype;O.toInt=function(){return this.unsigned?this.low>>>0:this.low},O.toNumber=function(){return this.unsigned?(this.high>>>0)*e+(this.low>>>0):this.high*e+(this.low>>>0)},O.toString=function(x){if((x=x||10)<2||36<x)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var T=f(x),I=this.div(T),F=I.mul(T).sub(this);return I.toString(x)+F.toInt().toString(x)}return"-"+this.neg().toString(x)}for(var C=f(h(x,6),this.unsigned),N=this,B="";;){var k=N.div(C),R=(N.sub(k.mul(C)).toInt()>>>0).toString(x);if((N=k).isZero())return R+B;for(;R.length<6;)R="0"+R;B=""+R+B}},O.getHighBits=function(){return this.high},O.getHighBitsUnsigned=function(){return this.high>>>0},O.getLowBits=function(){return this.low},O.getLowBitsUnsigned=function(){return this.low>>>0},O.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var x=this.high!=0?this.high:this.low,T=31;T>0&&!(x&1<<T);T--);return this.high!=0?T+33:T+1},O.isZero=function(){return this.high===0&&this.low===0},O.eqz=O.isZero,O.isNegative=function(){return!this.unsigned&&this.high<0},O.isPositive=function(){return this.unsigned||this.high>=0},O.isOdd=function(){return(1&this.low)==1},O.isEven=function(){return(1&this.low)==0},O.equals=function(x){return r(x)||(x=n(x)),(this.unsigned===x.unsigned||this.high>>>31!=1||x.high>>>31!=1)&&this.high===x.high&&this.low===x.low},O.eq=O.equals,O.notEquals=function(x){return!this.eq(x)},O.neq=O.notEquals,O.ne=O.notEquals,O.lessThan=function(x){return this.comp(x)<0},O.lt=O.lessThan,O.lessThanOrEqual=function(x){return this.comp(x)<=0},O.lte=O.lessThanOrEqual,O.le=O.lessThanOrEqual,O.greaterThan=function(x){return this.comp(x)>0},O.gt=O.greaterThan,O.greaterThanOrEqual=function(x){return this.comp(x)>=0},O.gte=O.greaterThanOrEqual,O.ge=O.greaterThanOrEqual,O.compare=function(x){if(r(x)||(x=n(x)),this.eq(x))return 0;var T=this.isNegative(),I=x.isNegative();return T&&!I?-1:!T&&I?1:this.unsigned?x.high>>>0>this.high>>>0||x.high===this.high&&x.low>>>0>this.low>>>0?-1:1:this.sub(x).isNegative()?-1:1},O.comp=O.compare,O.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(_)},O.neg=O.negate,O.add=function(x){r(x)||(x=n(x));var T=this.high>>>16,I=65535&this.high,F=this.low>>>16,C=65535&this.low,N=x.high>>>16,B=65535&x.high,k=x.low>>>16,R=0,X=0,U=0,K=0;return U+=(K+=C+(65535&x.low))>>>16,X+=(U+=F+k)>>>16,R+=(X+=I+B)>>>16,R+=T+N,p((U&=65535)<<16|(K&=65535),(R&=65535)<<16|(X&=65535),this.unsigned)},O.subtract=function(x){return r(x)||(x=n(x)),this.add(x.neg())},O.sub=O.subtract,O.multiply=function(x){if(this.isZero())return b;if(r(x)||(x=n(x)),t)return p(t.mul(this.low,this.high,x.low,x.high),t.get_high(),this.unsigned);if(x.isZero())return b;if(this.eq(S))return x.isOdd()?S:b;if(x.eq(S))return this.isOdd()?S:b;if(this.isNegative())return x.isNegative()?this.neg().mul(x.neg()):this.neg().mul(x).neg();if(x.isNegative())return this.mul(x.neg()).neg();if(this.lt(m)&&x.lt(m))return f(this.toNumber()*x.toNumber(),this.unsigned);var T=this.high>>>16,I=65535&this.high,F=this.low>>>16,C=65535&this.low,N=x.high>>>16,B=65535&x.high,k=x.low>>>16,R=65535&x.low,X=0,U=0,K=0,Q=0;return K+=(Q+=C*R)>>>16,U+=(K+=F*R)>>>16,K&=65535,U+=(K+=C*k)>>>16,X+=(U+=I*R)>>>16,U&=65535,X+=(U+=F*k)>>>16,U&=65535,X+=(U+=C*B)>>>16,X+=T*R+I*k+F*B+C*N,p((K&=65535)<<16|(Q&=65535),(X&=65535)<<16|(U&=65535),this.unsigned)},O.mul=O.multiply,O.divide=function(x){if(r(x)||(x=n(x)),x.isZero())throw Error("division by zero");var T,I,F;if(t)return this.unsigned||this.high!==-2147483648||x.low!==-1||x.high!==-1?p((this.unsigned?t.div_u:t.div_s)(this.low,this.high,x.low,x.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?g:b;if(this.unsigned){if(x.unsigned||(x=x.toUnsigned()),x.gt(this))return g;if(x.gt(this.shru(1)))return y;F=g}else{if(this.eq(S))return x.eq(_)||x.eq(v)?S:x.eq(S)?_:(T=this.shr(1).div(x).shl(1)).eq(b)?x.isNegative()?_:v:(I=this.sub(x.mul(T)),F=T.add(I.div(x)));if(x.eq(S))return this.unsigned?g:b;if(this.isNegative())return x.isNegative()?this.neg().div(x.neg()):this.neg().div(x).neg();if(x.isNegative())return this.div(x.neg()).neg();F=b}for(I=this;I.gte(x);){T=Math.max(1,Math.floor(I.toNumber()/x.toNumber()));for(var C=Math.ceil(Math.log(T)/Math.LN2),N=C<=48?1:h(2,C-48),B=f(T),k=B.mul(x);k.isNegative()||k.gt(I);)k=(B=f(T-=N,this.unsigned)).mul(x);B.isZero()&&(B=_),F=F.add(B),I=I.sub(k)}return F},O.div=O.divide,O.modulo=function(x){return r(x)||(x=n(x)),t?p((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,x.low,x.high),t.get_high(),this.unsigned):this.sub(this.div(x).mul(x))},O.mod=O.modulo,O.rem=O.modulo,O.not=function(){return p(~this.low,~this.high,this.unsigned)},O.and=function(x){return r(x)||(x=n(x)),p(this.low&x.low,this.high&x.high,this.unsigned)},O.or=function(x){return r(x)||(x=n(x)),p(this.low|x.low,this.high|x.high,this.unsigned)},O.xor=function(x){return r(x)||(x=n(x)),p(this.low^x.low,this.high^x.high,this.unsigned)},O.shiftLeft=function(x){return r(x)&&(x=x.toInt()),(x&=63)==0?this:x<32?p(this.low<<x,this.high<<x|this.low>>>32-x,this.unsigned):p(0,this.low<<x-32,this.unsigned)},O.shl=O.shiftLeft,O.shiftRight=function(x){return r(x)&&(x=x.toInt()),(x&=63)==0?this:x<32?p(this.low>>>x|this.high<<32-x,this.high>>x,this.unsigned):p(this.high>>x-32,this.high>=0?0:-1,this.unsigned)},O.shr=O.shiftRight,O.shiftRightUnsigned=function(x){if(r(x)&&(x=x.toInt()),(x&=63)==0)return this;var T=this.high;return x<32?p(this.low>>>x|T<<32-x,T>>>x,this.unsigned):p(x===32?T:T>>>x-32,0,this.unsigned)},O.shru=O.shiftRightUnsigned,O.shr_u=O.shiftRightUnsigned,O.toSigned=function(){return this.unsigned?p(this.low,this.high,!1):this},O.toUnsigned=function(){return this.unsigned?this:p(this.low,this.high,!0)},O.toBytes=function(x){return x?this.toBytesLE():this.toBytesBE()},O.toBytesLE=function(){var x=this.high,T=this.low;return[255&T,T>>>8&255,T>>>16&255,T>>>24,255&x,x>>>8&255,x>>>16&255,x>>>24]},O.toBytesBE=function(){var x=this.high,T=this.low;return[x>>>24,x>>>16&255,x>>>8&255,255&x,T>>>24,T>>>16&255,T>>>8&255,255&T]},i.fromBytes=function(x,T,I){return I?i.fromBytesLE(x,T):i.fromBytesBE(x,T)},i.fromBytesLE=function(x,T){return new i(x[0]|x[1]<<8|x[2]<<16|x[3]<<24,x[4]|x[5]<<8|x[6]<<16|x[7]<<24,T)},i.fromBytesBE=function(x,T){return new i(x[4]<<24|x[5]<<16|x[6]<<8|x[7],x[0]<<24|x[1]<<16|x[2]<<8|x[3],T)}},1446:(d,t,i)=>{var r,o,l,a=i(2100),f=a.Reader,p=a.Writer,h=a.util,c=a.roots.default||(a.roots.default={});c.onnx=((l={}).Version=(r={},(o=Object.create(r))[r[0]="_START_VERSION"]=0,o[r[1]="IR_VERSION_2017_10_10"]=1,o[r[2]="IR_VERSION_2017_10_30"]=2,o[r[3]="IR_VERSION_2017_11_3"]=3,o[r[4]="IR_VERSION_2019_1_22"]=4,o[r[5]="IR_VERSION"]=5,o),l.AttributeProto=function(){function n(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.name="",n.prototype.refAttrName="",n.prototype.docString="",n.prototype.type=0,n.prototype.f=0,n.prototype.i=h.Long?h.Long.fromBits(0,0,!1):0,n.prototype.s=h.newBuffer([]),n.prototype.t=null,n.prototype.g=null,n.prototype.floats=h.emptyArray,n.prototype.ints=h.emptyArray,n.prototype.strings=h.emptyArray,n.prototype.tensors=h.emptyArray,n.prototype.graphs=h.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,s){if(s||(s=p.create()),e.name!=null&&e.hasOwnProperty("name")&&s.uint32(10).string(e.name),e.f!=null&&e.hasOwnProperty("f")&&s.uint32(21).float(e.f),e.i!=null&&e.hasOwnProperty("i")&&s.uint32(24).int64(e.i),e.s!=null&&e.hasOwnProperty("s")&&s.uint32(34).bytes(e.s),e.t!=null&&e.hasOwnProperty("t")&&c.onnx.TensorProto.encode(e.t,s.uint32(42).fork()).ldelim(),e.g!=null&&e.hasOwnProperty("g")&&c.onnx.GraphProto.encode(e.g,s.uint32(50).fork()).ldelim(),e.floats!=null&&e.floats.length){s.uint32(58).fork();for(var u=0;u<e.floats.length;++u)s.float(e.floats[u]);s.ldelim()}if(e.ints!=null&&e.ints.length){for(s.uint32(66).fork(),u=0;u<e.ints.length;++u)s.int64(e.ints[u]);s.ldelim()}if(e.strings!=null&&e.strings.length)for(u=0;u<e.strings.length;++u)s.uint32(74).bytes(e.strings[u]);if(e.tensors!=null&&e.tensors.length)for(u=0;u<e.tensors.length;++u)c.onnx.TensorProto.encode(e.tensors[u],s.uint32(82).fork()).ldelim();if(e.graphs!=null&&e.graphs.length)for(u=0;u<e.graphs.length;++u)c.onnx.GraphProto.encode(e.graphs[u],s.uint32(90).fork()).ldelim();return e.docString!=null&&e.hasOwnProperty("docString")&&s.uint32(106).string(e.docString),e.type!=null&&e.hasOwnProperty("type")&&s.uint32(160).int32(e.type),e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&s.uint32(170).string(e.refAttrName),s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.AttributeProto;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:m.name=e.string();break;case 21:m.refAttrName=e.string();break;case 13:m.docString=e.string();break;case 20:m.type=e.int32();break;case 2:m.f=e.float();break;case 3:m.i=e.int64();break;case 4:m.s=e.bytes();break;case 5:m.t=c.onnx.TensorProto.decode(e,e.uint32());break;case 6:m.g=c.onnx.GraphProto.decode(e,e.uint32());break;case 7:if(m.floats&&m.floats.length||(m.floats=[]),(7&b)==2)for(var g=e.uint32()+e.pos;e.pos<g;)m.floats.push(e.float());else m.floats.push(e.float());break;case 8:if(m.ints&&m.ints.length||(m.ints=[]),(7&b)==2)for(g=e.uint32()+e.pos;e.pos<g;)m.ints.push(e.int64());else m.ints.push(e.int64());break;case 9:m.strings&&m.strings.length||(m.strings=[]),m.strings.push(e.bytes());break;case 10:m.tensors&&m.tensors.length||(m.tensors=[]),m.tensors.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 11:m.graphs&&m.graphs.length||(m.graphs=[]),m.graphs.push(c.onnx.GraphProto.decode(e,e.uint32()));break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!h.isString(e.name))return"name: string expected";if(e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&!h.isString(e.refAttrName))return"refAttrName: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!h.isString(e.docString))return"docString: string expected";if(e.type!=null&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(e.f!=null&&e.hasOwnProperty("f")&&typeof e.f!="number")return"f: number expected";if(e.i!=null&&e.hasOwnProperty("i")&&!(h.isInteger(e.i)||e.i&&h.isInteger(e.i.low)&&h.isInteger(e.i.high)))return"i: integer|Long expected";if(e.s!=null&&e.hasOwnProperty("s")&&!(e.s&&typeof e.s.length=="number"||h.isString(e.s)))return"s: buffer expected";if(e.t!=null&&e.hasOwnProperty("t")&&(u=c.onnx.TensorProto.verify(e.t)))return"t."+u;if(e.g!=null&&e.hasOwnProperty("g")&&(u=c.onnx.GraphProto.verify(e.g)))return"g."+u;if(e.floats!=null&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var s=0;s<e.floats.length;++s)if(typeof e.floats[s]!="number")return"floats: number[] expected"}if(e.ints!=null&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(s=0;s<e.ints.length;++s)if(!(h.isInteger(e.ints[s])||e.ints[s]&&h.isInteger(e.ints[s].low)&&h.isInteger(e.ints[s].high)))return"ints: integer|Long[] expected"}if(e.strings!=null&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(s=0;s<e.strings.length;++s)if(!(e.strings[s]&&typeof e.strings[s].length=="number"||h.isString(e.strings[s])))return"strings: buffer[] expected"}if(e.tensors!=null&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(s=0;s<e.tensors.length;++s)if(u=c.onnx.TensorProto.verify(e.tensors[s]))return"tensors."+u}if(e.graphs!=null&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(s=0;s<e.graphs.length;++s){var u;if(u=c.onnx.GraphProto.verify(e.graphs[s]))return"graphs."+u}}return null},n.fromObject=function(e){if(e instanceof c.onnx.AttributeProto)return e;var s=new c.onnx.AttributeProto;switch(e.name!=null&&(s.name=String(e.name)),e.refAttrName!=null&&(s.refAttrName=String(e.refAttrName)),e.docString!=null&&(s.docString=String(e.docString)),e.type){case"UNDEFINED":case 0:s.type=0;break;case"FLOAT":case 1:s.type=1;break;case"INT":case 2:s.type=2;break;case"STRING":case 3:s.type=3;break;case"TENSOR":case 4:s.type=4;break;case"GRAPH":case 5:s.type=5;break;case"FLOATS":case 6:s.type=6;break;case"INTS":case 7:s.type=7;break;case"STRINGS":case 8:s.type=8;break;case"TENSORS":case 9:s.type=9;break;case"GRAPHS":case 10:s.type=10}if(e.f!=null&&(s.f=Number(e.f)),e.i!=null&&(h.Long?(s.i=h.Long.fromValue(e.i)).unsigned=!1:typeof e.i=="string"?s.i=parseInt(e.i,10):typeof e.i=="number"?s.i=e.i:typeof e.i=="object"&&(s.i=new h.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),e.s!=null&&(typeof e.s=="string"?h.base64.decode(e.s,s.s=h.newBuffer(h.base64.length(e.s)),0):e.s.length&&(s.s=e.s)),e.t!=null){if(typeof e.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");s.t=c.onnx.TensorProto.fromObject(e.t)}if(e.g!=null){if(typeof e.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");s.g=c.onnx.GraphProto.fromObject(e.g)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");s.floats=[];for(var u=0;u<e.floats.length;++u)s.floats[u]=Number(e.floats[u])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(s.ints=[],u=0;u<e.ints.length;++u)h.Long?(s.ints[u]=h.Long.fromValue(e.ints[u])).unsigned=!1:typeof e.ints[u]=="string"?s.ints[u]=parseInt(e.ints[u],10):typeof e.ints[u]=="number"?s.ints[u]=e.ints[u]:typeof e.ints[u]=="object"&&(s.ints[u]=new h.LongBits(e.ints[u].low>>>0,e.ints[u].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(s.strings=[],u=0;u<e.strings.length;++u)typeof e.strings[u]=="string"?h.base64.decode(e.strings[u],s.strings[u]=h.newBuffer(h.base64.length(e.strings[u])),0):e.strings[u].length&&(s.strings[u]=e.strings[u])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(s.tensors=[],u=0;u<e.tensors.length;++u){if(typeof e.tensors[u]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");s.tensors[u]=c.onnx.TensorProto.fromObject(e.tensors[u])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(s.graphs=[],u=0;u<e.graphs.length;++u){if(typeof e.graphs[u]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");s.graphs[u]=c.onnx.GraphProto.fromObject(e.graphs[u])}}return s},n.toObject=function(e,s){s||(s={});var u={};if((s.arrays||s.defaults)&&(u.floats=[],u.ints=[],u.strings=[],u.tensors=[],u.graphs=[]),s.defaults){if(u.name="",u.f=0,h.Long){var m=new h.Long(0,0,!1);u.i=s.longs===String?m.toString():s.longs===Number?m.toNumber():m}else u.i=s.longs===String?"0":0;s.bytes===String?u.s="":(u.s=[],s.bytes!==Array&&(u.s=h.newBuffer(u.s))),u.t=null,u.g=null,u.docString="",u.type=s.enums===String?"UNDEFINED":0,u.refAttrName=""}if(e.name!=null&&e.hasOwnProperty("name")&&(u.name=e.name),e.f!=null&&e.hasOwnProperty("f")&&(u.f=s.json&&!isFinite(e.f)?String(e.f):e.f),e.i!=null&&e.hasOwnProperty("i")&&(typeof e.i=="number"?u.i=s.longs===String?String(e.i):e.i:u.i=s.longs===String?h.Long.prototype.toString.call(e.i):s.longs===Number?new h.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),e.s!=null&&e.hasOwnProperty("s")&&(u.s=s.bytes===String?h.base64.encode(e.s,0,e.s.length):s.bytes===Array?Array.prototype.slice.call(e.s):e.s),e.t!=null&&e.hasOwnProperty("t")&&(u.t=c.onnx.TensorProto.toObject(e.t,s)),e.g!=null&&e.hasOwnProperty("g")&&(u.g=c.onnx.GraphProto.toObject(e.g,s)),e.floats&&e.floats.length){u.floats=[];for(var b=0;b<e.floats.length;++b)u.floats[b]=s.json&&!isFinite(e.floats[b])?String(e.floats[b]):e.floats[b]}if(e.ints&&e.ints.length)for(u.ints=[],b=0;b<e.ints.length;++b)typeof e.ints[b]=="number"?u.ints[b]=s.longs===String?String(e.ints[b]):e.ints[b]:u.ints[b]=s.longs===String?h.Long.prototype.toString.call(e.ints[b]):s.longs===Number?new h.LongBits(e.ints[b].low>>>0,e.ints[b].high>>>0).toNumber():e.ints[b];if(e.strings&&e.strings.length)for(u.strings=[],b=0;b<e.strings.length;++b)u.strings[b]=s.bytes===String?h.base64.encode(e.strings[b],0,e.strings[b].length):s.bytes===Array?Array.prototype.slice.call(e.strings[b]):e.strings[b];if(e.tensors&&e.tensors.length)for(u.tensors=[],b=0;b<e.tensors.length;++b)u.tensors[b]=c.onnx.TensorProto.toObject(e.tensors[b],s);if(e.graphs&&e.graphs.length)for(u.graphs=[],b=0;b<e.graphs.length;++b)u.graphs[b]=c.onnx.GraphProto.toObject(e.graphs[b],s);return e.docString!=null&&e.hasOwnProperty("docString")&&(u.docString=e.docString),e.type!=null&&e.hasOwnProperty("type")&&(u.type=s.enums===String?c.onnx.AttributeProto.AttributeType[e.type]:e.type),e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&(u.refAttrName=e.refAttrName),u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n.AttributeType=function(){var e={},s=Object.create(e);return s[e[0]="UNDEFINED"]=0,s[e[1]="FLOAT"]=1,s[e[2]="INT"]=2,s[e[3]="STRING"]=3,s[e[4]="TENSOR"]=4,s[e[5]="GRAPH"]=5,s[e[6]="FLOATS"]=6,s[e[7]="INTS"]=7,s[e[8]="STRINGS"]=8,s[e[9]="TENSORS"]=9,s[e[10]="GRAPHS"]=10,s}(),n}(),l.ValueInfoProto=function(){function n(e){if(e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.name="",n.prototype.type=null,n.prototype.docString="",n.create=function(e){return new n(e)},n.encode=function(e,s){return s||(s=p.create()),e.name!=null&&e.hasOwnProperty("name")&&s.uint32(10).string(e.name),e.type!=null&&e.hasOwnProperty("type")&&c.onnx.TypeProto.encode(e.type,s.uint32(18).fork()).ldelim(),e.docString!=null&&e.hasOwnProperty("docString")&&s.uint32(26).string(e.docString),s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.ValueInfoProto;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:m.name=e.string();break;case 2:m.type=c.onnx.TypeProto.decode(e,e.uint32());break;case 3:m.docString=e.string();break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!h.isString(e.name))return"name: string expected";if(e.type!=null&&e.hasOwnProperty("type")){var s=c.onnx.TypeProto.verify(e.type);if(s)return"type."+s}return e.docString!=null&&e.hasOwnProperty("docString")&&!h.isString(e.docString)?"docString: string expected":null},n.fromObject=function(e){if(e instanceof c.onnx.ValueInfoProto)return e;var s=new c.onnx.ValueInfoProto;if(e.name!=null&&(s.name=String(e.name)),e.type!=null){if(typeof e.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");s.type=c.onnx.TypeProto.fromObject(e.type)}return e.docString!=null&&(s.docString=String(e.docString)),s},n.toObject=function(e,s){s||(s={});var u={};return s.defaults&&(u.name="",u.type=null,u.docString=""),e.name!=null&&e.hasOwnProperty("name")&&(u.name=e.name),e.type!=null&&e.hasOwnProperty("type")&&(u.type=c.onnx.TypeProto.toObject(e.type,s)),e.docString!=null&&e.hasOwnProperty("docString")&&(u.docString=e.docString),u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n}(),l.NodeProto=function(){function n(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.input=h.emptyArray,n.prototype.output=h.emptyArray,n.prototype.name="",n.prototype.opType="",n.prototype.domain="",n.prototype.attribute=h.emptyArray,n.prototype.docString="",n.create=function(e){return new n(e)},n.encode=function(e,s){if(s||(s=p.create()),e.input!=null&&e.input.length)for(var u=0;u<e.input.length;++u)s.uint32(10).string(e.input[u]);if(e.output!=null&&e.output.length)for(u=0;u<e.output.length;++u)s.uint32(18).string(e.output[u]);if(e.name!=null&&e.hasOwnProperty("name")&&s.uint32(26).string(e.name),e.opType!=null&&e.hasOwnProperty("opType")&&s.uint32(34).string(e.opType),e.attribute!=null&&e.attribute.length)for(u=0;u<e.attribute.length;++u)c.onnx.AttributeProto.encode(e.attribute[u],s.uint32(42).fork()).ldelim();return e.docString!=null&&e.hasOwnProperty("docString")&&s.uint32(50).string(e.docString),e.domain!=null&&e.hasOwnProperty("domain")&&s.uint32(58).string(e.domain),s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.NodeProto;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:m.input&&m.input.length||(m.input=[]),m.input.push(e.string());break;case 2:m.output&&m.output.length||(m.output=[]),m.output.push(e.string());break;case 3:m.name=e.string();break;case 4:m.opType=e.string();break;case 7:m.domain=e.string();break;case 5:m.attribute&&m.attribute.length||(m.attribute=[]),m.attribute.push(c.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:m.docString=e.string();break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var s=0;s<e.input.length;++s)if(!h.isString(e.input[s]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(s=0;s<e.output.length;++s)if(!h.isString(e.output[s]))return"output: string[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!h.isString(e.name))return"name: string expected";if(e.opType!=null&&e.hasOwnProperty("opType")&&!h.isString(e.opType))return"opType: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!h.isString(e.domain))return"domain: string expected";if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(s=0;s<e.attribute.length;++s){var u=c.onnx.AttributeProto.verify(e.attribute[s]);if(u)return"attribute."+u}}return e.docString!=null&&e.hasOwnProperty("docString")&&!h.isString(e.docString)?"docString: string expected":null},n.fromObject=function(e){if(e instanceof c.onnx.NodeProto)return e;var s=new c.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");s.input=[];for(var u=0;u<e.input.length;++u)s.input[u]=String(e.input[u])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(s.output=[],u=0;u<e.output.length;++u)s.output[u]=String(e.output[u])}if(e.name!=null&&(s.name=String(e.name)),e.opType!=null&&(s.opType=String(e.opType)),e.domain!=null&&(s.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(s.attribute=[],u=0;u<e.attribute.length;++u){if(typeof e.attribute[u]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");s.attribute[u]=c.onnx.AttributeProto.fromObject(e.attribute[u])}}return e.docString!=null&&(s.docString=String(e.docString)),s},n.toObject=function(e,s){s||(s={});var u={};if((s.arrays||s.defaults)&&(u.input=[],u.output=[],u.attribute=[]),s.defaults&&(u.name="",u.opType="",u.docString="",u.domain=""),e.input&&e.input.length){u.input=[];for(var m=0;m<e.input.length;++m)u.input[m]=e.input[m]}if(e.output&&e.output.length)for(u.output=[],m=0;m<e.output.length;++m)u.output[m]=e.output[m];if(e.name!=null&&e.hasOwnProperty("name")&&(u.name=e.name),e.opType!=null&&e.hasOwnProperty("opType")&&(u.opType=e.opType),e.attribute&&e.attribute.length)for(u.attribute=[],m=0;m<e.attribute.length;++m)u.attribute[m]=c.onnx.AttributeProto.toObject(e.attribute[m],s);return e.docString!=null&&e.hasOwnProperty("docString")&&(u.docString=e.docString),e.domain!=null&&e.hasOwnProperty("domain")&&(u.domain=e.domain),u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n}(),l.ModelProto=function(){function n(e){if(this.opsetImport=[],this.metadataProps=[],e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.irVersion=h.Long?h.Long.fromBits(0,0,!1):0,n.prototype.opsetImport=h.emptyArray,n.prototype.producerName="",n.prototype.producerVersion="",n.prototype.domain="",n.prototype.modelVersion=h.Long?h.Long.fromBits(0,0,!1):0,n.prototype.docString="",n.prototype.graph=null,n.prototype.metadataProps=h.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,s){if(s||(s=p.create()),e.irVersion!=null&&e.hasOwnProperty("irVersion")&&s.uint32(8).int64(e.irVersion),e.producerName!=null&&e.hasOwnProperty("producerName")&&s.uint32(18).string(e.producerName),e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&s.uint32(26).string(e.producerVersion),e.domain!=null&&e.hasOwnProperty("domain")&&s.uint32(34).string(e.domain),e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&s.uint32(40).int64(e.modelVersion),e.docString!=null&&e.hasOwnProperty("docString")&&s.uint32(50).string(e.docString),e.graph!=null&&e.hasOwnProperty("graph")&&c.onnx.GraphProto.encode(e.graph,s.uint32(58).fork()).ldelim(),e.opsetImport!=null&&e.opsetImport.length)for(var u=0;u<e.opsetImport.length;++u)c.onnx.OperatorSetIdProto.encode(e.opsetImport[u],s.uint32(66).fork()).ldelim();if(e.metadataProps!=null&&e.metadataProps.length)for(u=0;u<e.metadataProps.length;++u)c.onnx.StringStringEntryProto.encode(e.metadataProps[u],s.uint32(114).fork()).ldelim();return s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.ModelProto;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:m.irVersion=e.int64();break;case 8:m.opsetImport&&m.opsetImport.length||(m.opsetImport=[]),m.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:m.producerName=e.string();break;case 3:m.producerVersion=e.string();break;case 4:m.domain=e.string();break;case 5:m.modelVersion=e.int64();break;case 6:m.docString=e.string();break;case 7:m.graph=c.onnx.GraphProto.decode(e,e.uint32());break;case 14:m.metadataProps&&m.metadataProps.length||(m.metadataProps=[]),m.metadataProps.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&!(h.isInteger(e.irVersion)||e.irVersion&&h.isInteger(e.irVersion.low)&&h.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var s=0;s<e.opsetImport.length;++s)if(u=c.onnx.OperatorSetIdProto.verify(e.opsetImport[s]))return"opsetImport."+u}if(e.producerName!=null&&e.hasOwnProperty("producerName")&&!h.isString(e.producerName))return"producerName: string expected";if(e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&!h.isString(e.producerVersion))return"producerVersion: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!h.isString(e.domain))return"domain: string expected";if(e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&!(h.isInteger(e.modelVersion)||e.modelVersion&&h.isInteger(e.modelVersion.low)&&h.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!h.isString(e.docString))return"docString: string expected";if(e.graph!=null&&e.hasOwnProperty("graph")&&(u=c.onnx.GraphProto.verify(e.graph)))return"graph."+u;if(e.metadataProps!=null&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(s=0;s<e.metadataProps.length;++s){var u;if(u=c.onnx.StringStringEntryProto.verify(e.metadataProps[s]))return"metadataProps."+u}}return null},n.fromObject=function(e){if(e instanceof c.onnx.ModelProto)return e;var s=new c.onnx.ModelProto;if(e.irVersion!=null&&(h.Long?(s.irVersion=h.Long.fromValue(e.irVersion)).unsigned=!1:typeof e.irVersion=="string"?s.irVersion=parseInt(e.irVersion,10):typeof e.irVersion=="number"?s.irVersion=e.irVersion:typeof e.irVersion=="object"&&(s.irVersion=new h.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");s.opsetImport=[];for(var u=0;u<e.opsetImport.length;++u){if(typeof e.opsetImport[u]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");s.opsetImport[u]=c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[u])}}if(e.producerName!=null&&(s.producerName=String(e.producerName)),e.producerVersion!=null&&(s.producerVersion=String(e.producerVersion)),e.domain!=null&&(s.domain=String(e.domain)),e.modelVersion!=null&&(h.Long?(s.modelVersion=h.Long.fromValue(e.modelVersion)).unsigned=!1:typeof e.modelVersion=="string"?s.modelVersion=parseInt(e.modelVersion,10):typeof e.modelVersion=="number"?s.modelVersion=e.modelVersion:typeof e.modelVersion=="object"&&(s.modelVersion=new h.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),e.docString!=null&&(s.docString=String(e.docString)),e.graph!=null){if(typeof e.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");s.graph=c.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(s.metadataProps=[],u=0;u<e.metadataProps.length;++u){if(typeof e.metadataProps[u]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");s.metadataProps[u]=c.onnx.StringStringEntryProto.fromObject(e.metadataProps[u])}}return s},n.toObject=function(e,s){s||(s={});var u={};if((s.arrays||s.defaults)&&(u.opsetImport=[],u.metadataProps=[]),s.defaults){if(h.Long){var m=new h.Long(0,0,!1);u.irVersion=s.longs===String?m.toString():s.longs===Number?m.toNumber():m}else u.irVersion=s.longs===String?"0":0;u.producerName="",u.producerVersion="",u.domain="",h.Long?(m=new h.Long(0,0,!1),u.modelVersion=s.longs===String?m.toString():s.longs===Number?m.toNumber():m):u.modelVersion=s.longs===String?"0":0,u.docString="",u.graph=null}if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&(typeof e.irVersion=="number"?u.irVersion=s.longs===String?String(e.irVersion):e.irVersion:u.irVersion=s.longs===String?h.Long.prototype.toString.call(e.irVersion):s.longs===Number?new h.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),e.producerName!=null&&e.hasOwnProperty("producerName")&&(u.producerName=e.producerName),e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&(u.producerVersion=e.producerVersion),e.domain!=null&&e.hasOwnProperty("domain")&&(u.domain=e.domain),e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&(typeof e.modelVersion=="number"?u.modelVersion=s.longs===String?String(e.modelVersion):e.modelVersion:u.modelVersion=s.longs===String?h.Long.prototype.toString.call(e.modelVersion):s.longs===Number?new h.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),e.docString!=null&&e.hasOwnProperty("docString")&&(u.docString=e.docString),e.graph!=null&&e.hasOwnProperty("graph")&&(u.graph=c.onnx.GraphProto.toObject(e.graph,s)),e.opsetImport&&e.opsetImport.length){u.opsetImport=[];for(var b=0;b<e.opsetImport.length;++b)u.opsetImport[b]=c.onnx.OperatorSetIdProto.toObject(e.opsetImport[b],s)}if(e.metadataProps&&e.metadataProps.length)for(u.metadataProps=[],b=0;b<e.metadataProps.length;++b)u.metadataProps[b]=c.onnx.StringStringEntryProto.toObject(e.metadataProps[b],s);return u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n}(),l.StringStringEntryProto=function(){function n(e){if(e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.key="",n.prototype.value="",n.create=function(e){return new n(e)},n.encode=function(e,s){return s||(s=p.create()),e.key!=null&&e.hasOwnProperty("key")&&s.uint32(10).string(e.key),e.value!=null&&e.hasOwnProperty("value")&&s.uint32(18).string(e.value),s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.StringStringEntryProto;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:m.key=e.string();break;case 2:m.value=e.string();break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){return typeof e!="object"||e===null?"object expected":e.key!=null&&e.hasOwnProperty("key")&&!h.isString(e.key)?"key: string expected":e.value!=null&&e.hasOwnProperty("value")&&!h.isString(e.value)?"value: string expected":null},n.fromObject=function(e){if(e instanceof c.onnx.StringStringEntryProto)return e;var s=new c.onnx.StringStringEntryProto;return e.key!=null&&(s.key=String(e.key)),e.value!=null&&(s.value=String(e.value)),s},n.toObject=function(e,s){s||(s={});var u={};return s.defaults&&(u.key="",u.value=""),e.key!=null&&e.hasOwnProperty("key")&&(u.key=e.key),e.value!=null&&e.hasOwnProperty("value")&&(u.value=e.value),u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n}(),l.TensorAnnotation=function(){function n(e){if(this.quantParameterTensorNames=[],e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.tensorName="",n.prototype.quantParameterTensorNames=h.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,s){if(s||(s=p.create()),e.tensorName!=null&&e.hasOwnProperty("tensorName")&&s.uint32(10).string(e.tensorName),e.quantParameterTensorNames!=null&&e.quantParameterTensorNames.length)for(var u=0;u<e.quantParameterTensorNames.length;++u)c.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[u],s.uint32(18).fork()).ldelim();return s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.TensorAnnotation;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:m.tensorName=e.string();break;case 2:m.quantParameterTensorNames&&m.quantParameterTensorNames.length||(m.quantParameterTensorNames=[]),m.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.tensorName!=null&&e.hasOwnProperty("tensorName")&&!h.isString(e.tensorName))return"tensorName: string expected";if(e.quantParameterTensorNames!=null&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var s=0;s<e.quantParameterTensorNames.length;++s){var u=c.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[s]);if(u)return"quantParameterTensorNames."+u}}return null},n.fromObject=function(e){if(e instanceof c.onnx.TensorAnnotation)return e;var s=new c.onnx.TensorAnnotation;if(e.tensorName!=null&&(s.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");s.quantParameterTensorNames=[];for(var u=0;u<e.quantParameterTensorNames.length;++u){if(typeof e.quantParameterTensorNames[u]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");s.quantParameterTensorNames[u]=c.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[u])}}return s},n.toObject=function(e,s){s||(s={});var u={};if((s.arrays||s.defaults)&&(u.quantParameterTensorNames=[]),s.defaults&&(u.tensorName=""),e.tensorName!=null&&e.hasOwnProperty("tensorName")&&(u.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){u.quantParameterTensorNames=[];for(var m=0;m<e.quantParameterTensorNames.length;++m)u.quantParameterTensorNames[m]=c.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[m],s)}return u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n}(),l.GraphProto=function(){function n(e){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.node=h.emptyArray,n.prototype.name="",n.prototype.initializer=h.emptyArray,n.prototype.docString="",n.prototype.input=h.emptyArray,n.prototype.output=h.emptyArray,n.prototype.valueInfo=h.emptyArray,n.prototype.quantizationAnnotation=h.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,s){if(s||(s=p.create()),e.node!=null&&e.node.length)for(var u=0;u<e.node.length;++u)c.onnx.NodeProto.encode(e.node[u],s.uint32(10).fork()).ldelim();if(e.name!=null&&e.hasOwnProperty("name")&&s.uint32(18).string(e.name),e.initializer!=null&&e.initializer.length)for(u=0;u<e.initializer.length;++u)c.onnx.TensorProto.encode(e.initializer[u],s.uint32(42).fork()).ldelim();if(e.docString!=null&&e.hasOwnProperty("docString")&&s.uint32(82).string(e.docString),e.input!=null&&e.input.length)for(u=0;u<e.input.length;++u)c.onnx.ValueInfoProto.encode(e.input[u],s.uint32(90).fork()).ldelim();if(e.output!=null&&e.output.length)for(u=0;u<e.output.length;++u)c.onnx.ValueInfoProto.encode(e.output[u],s.uint32(98).fork()).ldelim();if(e.valueInfo!=null&&e.valueInfo.length)for(u=0;u<e.valueInfo.length;++u)c.onnx.ValueInfoProto.encode(e.valueInfo[u],s.uint32(106).fork()).ldelim();if(e.quantizationAnnotation!=null&&e.quantizationAnnotation.length)for(u=0;u<e.quantizationAnnotation.length;++u)c.onnx.TensorAnnotation.encode(e.quantizationAnnotation[u],s.uint32(114).fork()).ldelim();return s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.GraphProto;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:m.node&&m.node.length||(m.node=[]),m.node.push(c.onnx.NodeProto.decode(e,e.uint32()));break;case 2:m.name=e.string();break;case 5:m.initializer&&m.initializer.length||(m.initializer=[]),m.initializer.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 10:m.docString=e.string();break;case 11:m.input&&m.input.length||(m.input=[]),m.input.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:m.output&&m.output.length||(m.output=[]),m.output.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:m.valueInfo&&m.valueInfo.length||(m.valueInfo=[]),m.valueInfo.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:m.quantizationAnnotation&&m.quantizationAnnotation.length||(m.quantizationAnnotation=[]),m.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var s=0;s<e.node.length;++s)if(u=c.onnx.NodeProto.verify(e.node[s]))return"node."+u}if(e.name!=null&&e.hasOwnProperty("name")&&!h.isString(e.name))return"name: string expected";if(e.initializer!=null&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(s=0;s<e.initializer.length;++s)if(u=c.onnx.TensorProto.verify(e.initializer[s]))return"initializer."+u}if(e.docString!=null&&e.hasOwnProperty("docString")&&!h.isString(e.docString))return"docString: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(s=0;s<e.input.length;++s)if(u=c.onnx.ValueInfoProto.verify(e.input[s]))return"input."+u}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(s=0;s<e.output.length;++s)if(u=c.onnx.ValueInfoProto.verify(e.output[s]))return"output."+u}if(e.valueInfo!=null&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(s=0;s<e.valueInfo.length;++s)if(u=c.onnx.ValueInfoProto.verify(e.valueInfo[s]))return"valueInfo."+u}if(e.quantizationAnnotation!=null&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(s=0;s<e.quantizationAnnotation.length;++s){var u;if(u=c.onnx.TensorAnnotation.verify(e.quantizationAnnotation[s]))return"quantizationAnnotation."+u}}return null},n.fromObject=function(e){if(e instanceof c.onnx.GraphProto)return e;var s=new c.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");s.node=[];for(var u=0;u<e.node.length;++u){if(typeof e.node[u]!="object")throw TypeError(".onnx.GraphProto.node: object expected");s.node[u]=c.onnx.NodeProto.fromObject(e.node[u])}}if(e.name!=null&&(s.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(s.initializer=[],u=0;u<e.initializer.length;++u){if(typeof e.initializer[u]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");s.initializer[u]=c.onnx.TensorProto.fromObject(e.initializer[u])}}if(e.docString!=null&&(s.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(s.input=[],u=0;u<e.input.length;++u){if(typeof e.input[u]!="object")throw TypeError(".onnx.GraphProto.input: object expected");s.input[u]=c.onnx.ValueInfoProto.fromObject(e.input[u])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(s.output=[],u=0;u<e.output.length;++u){if(typeof e.output[u]!="object")throw TypeError(".onnx.GraphProto.output: object expected");s.output[u]=c.onnx.ValueInfoProto.fromObject(e.output[u])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(s.valueInfo=[],u=0;u<e.valueInfo.length;++u){if(typeof e.valueInfo[u]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");s.valueInfo[u]=c.onnx.ValueInfoProto.fromObject(e.valueInfo[u])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(s.quantizationAnnotation=[],u=0;u<e.quantizationAnnotation.length;++u){if(typeof e.quantizationAnnotation[u]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");s.quantizationAnnotation[u]=c.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[u])}}return s},n.toObject=function(e,s){s||(s={});var u={};if((s.arrays||s.defaults)&&(u.node=[],u.initializer=[],u.input=[],u.output=[],u.valueInfo=[],u.quantizationAnnotation=[]),s.defaults&&(u.name="",u.docString=""),e.node&&e.node.length){u.node=[];for(var m=0;m<e.node.length;++m)u.node[m]=c.onnx.NodeProto.toObject(e.node[m],s)}if(e.name!=null&&e.hasOwnProperty("name")&&(u.name=e.name),e.initializer&&e.initializer.length)for(u.initializer=[],m=0;m<e.initializer.length;++m)u.initializer[m]=c.onnx.TensorProto.toObject(e.initializer[m],s);if(e.docString!=null&&e.hasOwnProperty("docString")&&(u.docString=e.docString),e.input&&e.input.length)for(u.input=[],m=0;m<e.input.length;++m)u.input[m]=c.onnx.ValueInfoProto.toObject(e.input[m],s);if(e.output&&e.output.length)for(u.output=[],m=0;m<e.output.length;++m)u.output[m]=c.onnx.ValueInfoProto.toObject(e.output[m],s);if(e.valueInfo&&e.valueInfo.length)for(u.valueInfo=[],m=0;m<e.valueInfo.length;++m)u.valueInfo[m]=c.onnx.ValueInfoProto.toObject(e.valueInfo[m],s);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(u.quantizationAnnotation=[],m=0;m<e.quantizationAnnotation.length;++m)u.quantizationAnnotation[m]=c.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[m],s);return u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n}(),l.TensorProto=function(){function n(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.dims=h.emptyArray,n.prototype.dataType=0,n.prototype.segment=null,n.prototype.floatData=h.emptyArray,n.prototype.int32Data=h.emptyArray,n.prototype.stringData=h.emptyArray,n.prototype.int64Data=h.emptyArray,n.prototype.name="",n.prototype.docString="",n.prototype.rawData=h.newBuffer([]),n.prototype.externalData=h.emptyArray,n.prototype.dataLocation=0,n.prototype.doubleData=h.emptyArray,n.prototype.uint64Data=h.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,s){if(s||(s=p.create()),e.dims!=null&&e.dims.length){s.uint32(10).fork();for(var u=0;u<e.dims.length;++u)s.int64(e.dims[u]);s.ldelim()}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&s.uint32(16).int32(e.dataType),e.segment!=null&&e.hasOwnProperty("segment")&&c.onnx.TensorProto.Segment.encode(e.segment,s.uint32(26).fork()).ldelim(),e.floatData!=null&&e.floatData.length){for(s.uint32(34).fork(),u=0;u<e.floatData.length;++u)s.float(e.floatData[u]);s.ldelim()}if(e.int32Data!=null&&e.int32Data.length){for(s.uint32(42).fork(),u=0;u<e.int32Data.length;++u)s.int32(e.int32Data[u]);s.ldelim()}if(e.stringData!=null&&e.stringData.length)for(u=0;u<e.stringData.length;++u)s.uint32(50).bytes(e.stringData[u]);if(e.int64Data!=null&&e.int64Data.length){for(s.uint32(58).fork(),u=0;u<e.int64Data.length;++u)s.int64(e.int64Data[u]);s.ldelim()}if(e.name!=null&&e.hasOwnProperty("name")&&s.uint32(66).string(e.name),e.rawData!=null&&e.hasOwnProperty("rawData")&&s.uint32(74).bytes(e.rawData),e.doubleData!=null&&e.doubleData.length){for(s.uint32(82).fork(),u=0;u<e.doubleData.length;++u)s.double(e.doubleData[u]);s.ldelim()}if(e.uint64Data!=null&&e.uint64Data.length){for(s.uint32(90).fork(),u=0;u<e.uint64Data.length;++u)s.uint64(e.uint64Data[u]);s.ldelim()}if(e.docString!=null&&e.hasOwnProperty("docString")&&s.uint32(98).string(e.docString),e.externalData!=null&&e.externalData.length)for(u=0;u<e.externalData.length;++u)c.onnx.StringStringEntryProto.encode(e.externalData[u],s.uint32(106).fork()).ldelim();return e.dataLocation!=null&&e.hasOwnProperty("dataLocation")&&s.uint32(112).int32(e.dataLocation),s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.TensorProto;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:if(m.dims&&m.dims.length||(m.dims=[]),(7&b)==2)for(var g=e.uint32()+e.pos;e.pos<g;)m.dims.push(e.int64());else m.dims.push(e.int64());break;case 2:m.dataType=e.int32();break;case 3:m.segment=c.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(m.floatData&&m.floatData.length||(m.floatData=[]),(7&b)==2)for(g=e.uint32()+e.pos;e.pos<g;)m.floatData.push(e.float());else m.floatData.push(e.float());break;case 5:if(m.int32Data&&m.int32Data.length||(m.int32Data=[]),(7&b)==2)for(g=e.uint32()+e.pos;e.pos<g;)m.int32Data.push(e.int32());else m.int32Data.push(e.int32());break;case 6:m.stringData&&m.stringData.length||(m.stringData=[]),m.stringData.push(e.bytes());break;case 7:if(m.int64Data&&m.int64Data.length||(m.int64Data=[]),(7&b)==2)for(g=e.uint32()+e.pos;e.pos<g;)m.int64Data.push(e.int64());else m.int64Data.push(e.int64());break;case 8:m.name=e.string();break;case 12:m.docString=e.string();break;case 9:m.rawData=e.bytes();break;case 13:m.externalData&&m.externalData.length||(m.externalData=[]),m.externalData.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:m.dataLocation=e.int32();break;case 10:if(m.doubleData&&m.doubleData.length||(m.doubleData=[]),(7&b)==2)for(g=e.uint32()+e.pos;e.pos<g;)m.doubleData.push(e.double());else m.doubleData.push(e.double());break;case 11:if(m.uint64Data&&m.uint64Data.length||(m.uint64Data=[]),(7&b)==2)for(g=e.uint32()+e.pos;e.pos<g;)m.uint64Data.push(e.uint64());else m.uint64Data.push(e.uint64());break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var s=0;s<e.dims.length;++s)if(!(h.isInteger(e.dims[s])||e.dims[s]&&h.isInteger(e.dims[s].low)&&h.isInteger(e.dims[s].high)))return"dims: integer|Long[] expected"}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&!h.isInteger(e.dataType))return"dataType: integer expected";if(e.segment!=null&&e.hasOwnProperty("segment")&&(u=c.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+u;if(e.floatData!=null&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(s=0;s<e.floatData.length;++s)if(typeof e.floatData[s]!="number")return"floatData: number[] expected"}if(e.int32Data!=null&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(s=0;s<e.int32Data.length;++s)if(!h.isInteger(e.int32Data[s]))return"int32Data: integer[] expected"}if(e.stringData!=null&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(s=0;s<e.stringData.length;++s)if(!(e.stringData[s]&&typeof e.stringData[s].length=="number"||h.isString(e.stringData[s])))return"stringData: buffer[] expected"}if(e.int64Data!=null&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(s=0;s<e.int64Data.length;++s)if(!(h.isInteger(e.int64Data[s])||e.int64Data[s]&&h.isInteger(e.int64Data[s].low)&&h.isInteger(e.int64Data[s].high)))return"int64Data: integer|Long[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!h.isString(e.name))return"name: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!h.isString(e.docString))return"docString: string expected";if(e.rawData!=null&&e.hasOwnProperty("rawData")&&!(e.rawData&&typeof e.rawData.length=="number"||h.isString(e.rawData)))return"rawData: buffer expected";if(e.externalData!=null&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(s=0;s<e.externalData.length;++s){var u;if(u=c.onnx.StringStringEntryProto.verify(e.externalData[s]))return"externalData."+u}}if(e.dataLocation!=null&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(e.doubleData!=null&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(s=0;s<e.doubleData.length;++s)if(typeof e.doubleData[s]!="number")return"doubleData: number[] expected"}if(e.uint64Data!=null&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(s=0;s<e.uint64Data.length;++s)if(!(h.isInteger(e.uint64Data[s])||e.uint64Data[s]&&h.isInteger(e.uint64Data[s].low)&&h.isInteger(e.uint64Data[s].high)))return"uint64Data: integer|Long[] expected"}return null},n.fromObject=function(e){if(e instanceof c.onnx.TensorProto)return e;var s=new c.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");s.dims=[];for(var u=0;u<e.dims.length;++u)h.Long?(s.dims[u]=h.Long.fromValue(e.dims[u])).unsigned=!1:typeof e.dims[u]=="string"?s.dims[u]=parseInt(e.dims[u],10):typeof e.dims[u]=="number"?s.dims[u]=e.dims[u]:typeof e.dims[u]=="object"&&(s.dims[u]=new h.LongBits(e.dims[u].low>>>0,e.dims[u].high>>>0).toNumber())}if(e.dataType!=null&&(s.dataType=0|e.dataType),e.segment!=null){if(typeof e.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");s.segment=c.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(s.floatData=[],u=0;u<e.floatData.length;++u)s.floatData[u]=Number(e.floatData[u])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(s.int32Data=[],u=0;u<e.int32Data.length;++u)s.int32Data[u]=0|e.int32Data[u]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(s.stringData=[],u=0;u<e.stringData.length;++u)typeof e.stringData[u]=="string"?h.base64.decode(e.stringData[u],s.stringData[u]=h.newBuffer(h.base64.length(e.stringData[u])),0):e.stringData[u].length&&(s.stringData[u]=e.stringData[u])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(s.int64Data=[],u=0;u<e.int64Data.length;++u)h.Long?(s.int64Data[u]=h.Long.fromValue(e.int64Data[u])).unsigned=!1:typeof e.int64Data[u]=="string"?s.int64Data[u]=parseInt(e.int64Data[u],10):typeof e.int64Data[u]=="number"?s.int64Data[u]=e.int64Data[u]:typeof e.int64Data[u]=="object"&&(s.int64Data[u]=new h.LongBits(e.int64Data[u].low>>>0,e.int64Data[u].high>>>0).toNumber())}if(e.name!=null&&(s.name=String(e.name)),e.docString!=null&&(s.docString=String(e.docString)),e.rawData!=null&&(typeof e.rawData=="string"?h.base64.decode(e.rawData,s.rawData=h.newBuffer(h.base64.length(e.rawData)),0):e.rawData.length&&(s.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(s.externalData=[],u=0;u<e.externalData.length;++u){if(typeof e.externalData[u]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");s.externalData[u]=c.onnx.StringStringEntryProto.fromObject(e.externalData[u])}}switch(e.dataLocation){case"DEFAULT":case 0:s.dataLocation=0;break;case"EXTERNAL":case 1:s.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(s.doubleData=[],u=0;u<e.doubleData.length;++u)s.doubleData[u]=Number(e.doubleData[u])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(s.uint64Data=[],u=0;u<e.uint64Data.length;++u)h.Long?(s.uint64Data[u]=h.Long.fromValue(e.uint64Data[u])).unsigned=!0:typeof e.uint64Data[u]=="string"?s.uint64Data[u]=parseInt(e.uint64Data[u],10):typeof e.uint64Data[u]=="number"?s.uint64Data[u]=e.uint64Data[u]:typeof e.uint64Data[u]=="object"&&(s.uint64Data[u]=new h.LongBits(e.uint64Data[u].low>>>0,e.uint64Data[u].high>>>0).toNumber(!0))}return s},n.toObject=function(e,s){s||(s={});var u={};if((s.arrays||s.defaults)&&(u.dims=[],u.floatData=[],u.int32Data=[],u.stringData=[],u.int64Data=[],u.doubleData=[],u.uint64Data=[],u.externalData=[]),s.defaults&&(u.dataType=0,u.segment=null,u.name="",s.bytes===String?u.rawData="":(u.rawData=[],s.bytes!==Array&&(u.rawData=h.newBuffer(u.rawData))),u.docString="",u.dataLocation=s.enums===String?"DEFAULT":0),e.dims&&e.dims.length){u.dims=[];for(var m=0;m<e.dims.length;++m)typeof e.dims[m]=="number"?u.dims[m]=s.longs===String?String(e.dims[m]):e.dims[m]:u.dims[m]=s.longs===String?h.Long.prototype.toString.call(e.dims[m]):s.longs===Number?new h.LongBits(e.dims[m].low>>>0,e.dims[m].high>>>0).toNumber():e.dims[m]}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&(u.dataType=e.dataType),e.segment!=null&&e.hasOwnProperty("segment")&&(u.segment=c.onnx.TensorProto.Segment.toObject(e.segment,s)),e.floatData&&e.floatData.length)for(u.floatData=[],m=0;m<e.floatData.length;++m)u.floatData[m]=s.json&&!isFinite(e.floatData[m])?String(e.floatData[m]):e.floatData[m];if(e.int32Data&&e.int32Data.length)for(u.int32Data=[],m=0;m<e.int32Data.length;++m)u.int32Data[m]=e.int32Data[m];if(e.stringData&&e.stringData.length)for(u.stringData=[],m=0;m<e.stringData.length;++m)u.stringData[m]=s.bytes===String?h.base64.encode(e.stringData[m],0,e.stringData[m].length):s.bytes===Array?Array.prototype.slice.call(e.stringData[m]):e.stringData[m];if(e.int64Data&&e.int64Data.length)for(u.int64Data=[],m=0;m<e.int64Data.length;++m)typeof e.int64Data[m]=="number"?u.int64Data[m]=s.longs===String?String(e.int64Data[m]):e.int64Data[m]:u.int64Data[m]=s.longs===String?h.Long.prototype.toString.call(e.int64Data[m]):s.longs===Number?new h.LongBits(e.int64Data[m].low>>>0,e.int64Data[m].high>>>0).toNumber():e.int64Data[m];if(e.name!=null&&e.hasOwnProperty("name")&&(u.name=e.name),e.rawData!=null&&e.hasOwnProperty("rawData")&&(u.rawData=s.bytes===String?h.base64.encode(e.rawData,0,e.rawData.length):s.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(u.doubleData=[],m=0;m<e.doubleData.length;++m)u.doubleData[m]=s.json&&!isFinite(e.doubleData[m])?String(e.doubleData[m]):e.doubleData[m];if(e.uint64Data&&e.uint64Data.length)for(u.uint64Data=[],m=0;m<e.uint64Data.length;++m)typeof e.uint64Data[m]=="number"?u.uint64Data[m]=s.longs===String?String(e.uint64Data[m]):e.uint64Data[m]:u.uint64Data[m]=s.longs===String?h.Long.prototype.toString.call(e.uint64Data[m]):s.longs===Number?new h.LongBits(e.uint64Data[m].low>>>0,e.uint64Data[m].high>>>0).toNumber(!0):e.uint64Data[m];if(e.docString!=null&&e.hasOwnProperty("docString")&&(u.docString=e.docString),e.externalData&&e.externalData.length)for(u.externalData=[],m=0;m<e.externalData.length;++m)u.externalData[m]=c.onnx.StringStringEntryProto.toObject(e.externalData[m],s);return e.dataLocation!=null&&e.hasOwnProperty("dataLocation")&&(u.dataLocation=s.enums===String?c.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n.DataType=function(){var e={},s=Object.create(e);return s[e[0]="UNDEFINED"]=0,s[e[1]="FLOAT"]=1,s[e[2]="UINT8"]=2,s[e[3]="INT8"]=3,s[e[4]="UINT16"]=4,s[e[5]="INT16"]=5,s[e[6]="INT32"]=6,s[e[7]="INT64"]=7,s[e[8]="STRING"]=8,s[e[9]="BOOL"]=9,s[e[10]="FLOAT16"]=10,s[e[11]="DOUBLE"]=11,s[e[12]="UINT32"]=12,s[e[13]="UINT64"]=13,s[e[14]="COMPLEX64"]=14,s[e[15]="COMPLEX128"]=15,s[e[16]="BFLOAT16"]=16,s}(),n.Segment=function(){function e(s){if(s)for(var u=Object.keys(s),m=0;m<u.length;++m)s[u[m]]!=null&&(this[u[m]]=s[u[m]])}return e.prototype.begin=h.Long?h.Long.fromBits(0,0,!1):0,e.prototype.end=h.Long?h.Long.fromBits(0,0,!1):0,e.create=function(s){return new e(s)},e.encode=function(s,u){return u||(u=p.create()),s.begin!=null&&s.hasOwnProperty("begin")&&u.uint32(8).int64(s.begin),s.end!=null&&s.hasOwnProperty("end")&&u.uint32(16).int64(s.end),u},e.encodeDelimited=function(s,u){return this.encode(s,u).ldelim()},e.decode=function(s,u){s instanceof f||(s=f.create(s));for(var m=u===void 0?s.len:s.pos+u,b=new c.onnx.TensorProto.Segment;s.pos<m;){var g=s.uint32();switch(g>>>3){case 1:b.begin=s.int64();break;case 2:b.end=s.int64();break;default:s.skipType(7&g)}}return b},e.decodeDelimited=function(s){return s instanceof f||(s=new f(s)),this.decode(s,s.uint32())},e.verify=function(s){return typeof s!="object"||s===null?"object expected":s.begin!=null&&s.hasOwnProperty("begin")&&!(h.isInteger(s.begin)||s.begin&&h.isInteger(s.begin.low)&&h.isInteger(s.begin.high))?"begin: integer|Long expected":s.end!=null&&s.hasOwnProperty("end")&&!(h.isInteger(s.end)||s.end&&h.isInteger(s.end.low)&&h.isInteger(s.end.high))?"end: integer|Long expected":null},e.fromObject=function(s){if(s instanceof c.onnx.TensorProto.Segment)return s;var u=new c.onnx.TensorProto.Segment;return s.begin!=null&&(h.Long?(u.begin=h.Long.fromValue(s.begin)).unsigned=!1:typeof s.begin=="string"?u.begin=parseInt(s.begin,10):typeof s.begin=="number"?u.begin=s.begin:typeof s.begin=="object"&&(u.begin=new h.LongBits(s.begin.low>>>0,s.begin.high>>>0).toNumber())),s.end!=null&&(h.Long?(u.end=h.Long.fromValue(s.end)).unsigned=!1:typeof s.end=="string"?u.end=parseInt(s.end,10):typeof s.end=="number"?u.end=s.end:typeof s.end=="object"&&(u.end=new h.LongBits(s.end.low>>>0,s.end.high>>>0).toNumber())),u},e.toObject=function(s,u){u||(u={});var m={};if(u.defaults){if(h.Long){var b=new h.Long(0,0,!1);m.begin=u.longs===String?b.toString():u.longs===Number?b.toNumber():b}else m.begin=u.longs===String?"0":0;h.Long?(b=new h.Long(0,0,!1),m.end=u.longs===String?b.toString():u.longs===Number?b.toNumber():b):m.end=u.longs===String?"0":0}return s.begin!=null&&s.hasOwnProperty("begin")&&(typeof s.begin=="number"?m.begin=u.longs===String?String(s.begin):s.begin:m.begin=u.longs===String?h.Long.prototype.toString.call(s.begin):u.longs===Number?new h.LongBits(s.begin.low>>>0,s.begin.high>>>0).toNumber():s.begin),s.end!=null&&s.hasOwnProperty("end")&&(typeof s.end=="number"?m.end=u.longs===String?String(s.end):s.end:m.end=u.longs===String?h.Long.prototype.toString.call(s.end):u.longs===Number?new h.LongBits(s.end.low>>>0,s.end.high>>>0).toNumber():s.end),m},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),n.DataLocation=function(){var e={},s=Object.create(e);return s[e[0]="DEFAULT"]=0,s[e[1]="EXTERNAL"]=1,s}(),n}(),l.TensorShapeProto=function(){function n(e){if(this.dim=[],e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.dim=h.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,s){if(s||(s=p.create()),e.dim!=null&&e.dim.length)for(var u=0;u<e.dim.length;++u)c.onnx.TensorShapeProto.Dimension.encode(e.dim[u],s.uint32(10).fork()).ldelim();return s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.TensorShapeProto;e.pos<u;){var b=e.uint32();b>>>3==1?(m.dim&&m.dim.length||(m.dim=[]),m.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&b)}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dim!=null&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var s=0;s<e.dim.length;++s){var u=c.onnx.TensorShapeProto.Dimension.verify(e.dim[s]);if(u)return"dim."+u}}return null},n.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto)return e;var s=new c.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");s.dim=[];for(var u=0;u<e.dim.length;++u){if(typeof e.dim[u]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");s.dim[u]=c.onnx.TensorShapeProto.Dimension.fromObject(e.dim[u])}}return s},n.toObject=function(e,s){s||(s={});var u={};if((s.arrays||s.defaults)&&(u.dim=[]),e.dim&&e.dim.length){u.dim=[];for(var m=0;m<e.dim.length;++m)u.dim[m]=c.onnx.TensorShapeProto.Dimension.toObject(e.dim[m],s)}return u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n.Dimension=function(){function e(u){if(u)for(var m=Object.keys(u),b=0;b<m.length;++b)u[m[b]]!=null&&(this[m[b]]=u[m[b]])}var s;return e.prototype.dimValue=h.Long?h.Long.fromBits(0,0,!1):0,e.prototype.dimParam="",e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:h.oneOfGetter(s=["dimValue","dimParam"]),set:h.oneOfSetter(s)}),e.create=function(u){return new e(u)},e.encode=function(u,m){return m||(m=p.create()),u.dimValue!=null&&u.hasOwnProperty("dimValue")&&m.uint32(8).int64(u.dimValue),u.dimParam!=null&&u.hasOwnProperty("dimParam")&&m.uint32(18).string(u.dimParam),u.denotation!=null&&u.hasOwnProperty("denotation")&&m.uint32(26).string(u.denotation),m},e.encodeDelimited=function(u,m){return this.encode(u,m).ldelim()},e.decode=function(u,m){u instanceof f||(u=f.create(u));for(var b=m===void 0?u.len:u.pos+m,g=new c.onnx.TensorShapeProto.Dimension;u.pos<b;){var _=u.uint32();switch(_>>>3){case 1:g.dimValue=u.int64();break;case 2:g.dimParam=u.string();break;case 3:g.denotation=u.string();break;default:u.skipType(7&_)}}return g},e.decodeDelimited=function(u){return u instanceof f||(u=new f(u)),this.decode(u,u.uint32())},e.verify=function(u){if(typeof u!="object"||u===null)return"object expected";var m={};if(u.dimValue!=null&&u.hasOwnProperty("dimValue")&&(m.value=1,!(h.isInteger(u.dimValue)||u.dimValue&&h.isInteger(u.dimValue.low)&&h.isInteger(u.dimValue.high))))return"dimValue: integer|Long expected";if(u.dimParam!=null&&u.hasOwnProperty("dimParam")){if(m.value===1)return"value: multiple values";if(m.value=1,!h.isString(u.dimParam))return"dimParam: string expected"}return u.denotation!=null&&u.hasOwnProperty("denotation")&&!h.isString(u.denotation)?"denotation: string expected":null},e.fromObject=function(u){if(u instanceof c.onnx.TensorShapeProto.Dimension)return u;var m=new c.onnx.TensorShapeProto.Dimension;return u.dimValue!=null&&(h.Long?(m.dimValue=h.Long.fromValue(u.dimValue)).unsigned=!1:typeof u.dimValue=="string"?m.dimValue=parseInt(u.dimValue,10):typeof u.dimValue=="number"?m.dimValue=u.dimValue:typeof u.dimValue=="object"&&(m.dimValue=new h.LongBits(u.dimValue.low>>>0,u.dimValue.high>>>0).toNumber())),u.dimParam!=null&&(m.dimParam=String(u.dimParam)),u.denotation!=null&&(m.denotation=String(u.denotation)),m},e.toObject=function(u,m){m||(m={});var b={};return m.defaults&&(b.denotation=""),u.dimValue!=null&&u.hasOwnProperty("dimValue")&&(typeof u.dimValue=="number"?b.dimValue=m.longs===String?String(u.dimValue):u.dimValue:b.dimValue=m.longs===String?h.Long.prototype.toString.call(u.dimValue):m.longs===Number?new h.LongBits(u.dimValue.low>>>0,u.dimValue.high>>>0).toNumber():u.dimValue,m.oneofs&&(b.value="dimValue")),u.dimParam!=null&&u.hasOwnProperty("dimParam")&&(b.dimParam=u.dimParam,m.oneofs&&(b.value="dimParam")),u.denotation!=null&&u.hasOwnProperty("denotation")&&(b.denotation=u.denotation),b},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),n}(),l.TypeProto=function(){function n(s){if(s)for(var u=Object.keys(s),m=0;m<u.length;++m)s[u[m]]!=null&&(this[u[m]]=s[u[m]])}var e;return n.prototype.tensorType=null,n.prototype.denotation="",Object.defineProperty(n.prototype,"value",{get:h.oneOfGetter(e=["tensorType"]),set:h.oneOfSetter(e)}),n.create=function(s){return new n(s)},n.encode=function(s,u){return u||(u=p.create()),s.tensorType!=null&&s.hasOwnProperty("tensorType")&&c.onnx.TypeProto.Tensor.encode(s.tensorType,u.uint32(10).fork()).ldelim(),s.denotation!=null&&s.hasOwnProperty("denotation")&&u.uint32(50).string(s.denotation),u},n.encodeDelimited=function(s,u){return this.encode(s,u).ldelim()},n.decode=function(s,u){s instanceof f||(s=f.create(s));for(var m=u===void 0?s.len:s.pos+u,b=new c.onnx.TypeProto;s.pos<m;){var g=s.uint32();switch(g>>>3){case 1:b.tensorType=c.onnx.TypeProto.Tensor.decode(s,s.uint32());break;case 6:b.denotation=s.string();break;default:s.skipType(7&g)}}return b},n.decodeDelimited=function(s){return s instanceof f||(s=new f(s)),this.decode(s,s.uint32())},n.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.tensorType!=null&&s.hasOwnProperty("tensorType")){var u=c.onnx.TypeProto.Tensor.verify(s.tensorType);if(u)return"tensorType."+u}return s.denotation!=null&&s.hasOwnProperty("denotation")&&!h.isString(s.denotation)?"denotation: string expected":null},n.fromObject=function(s){if(s instanceof c.onnx.TypeProto)return s;var u=new c.onnx.TypeProto;if(s.tensorType!=null){if(typeof s.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");u.tensorType=c.onnx.TypeProto.Tensor.fromObject(s.tensorType)}return s.denotation!=null&&(u.denotation=String(s.denotation)),u},n.toObject=function(s,u){u||(u={});var m={};return u.defaults&&(m.denotation=""),s.tensorType!=null&&s.hasOwnProperty("tensorType")&&(m.tensorType=c.onnx.TypeProto.Tensor.toObject(s.tensorType,u),u.oneofs&&(m.value="tensorType")),s.denotation!=null&&s.hasOwnProperty("denotation")&&(m.denotation=s.denotation),m},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n.Tensor=function(){function s(u){if(u)for(var m=Object.keys(u),b=0;b<m.length;++b)u[m[b]]!=null&&(this[m[b]]=u[m[b]])}return s.prototype.elemType=0,s.prototype.shape=null,s.create=function(u){return new s(u)},s.encode=function(u,m){return m||(m=p.create()),u.elemType!=null&&u.hasOwnProperty("elemType")&&m.uint32(8).int32(u.elemType),u.shape!=null&&u.hasOwnProperty("shape")&&c.onnx.TensorShapeProto.encode(u.shape,m.uint32(18).fork()).ldelim(),m},s.encodeDelimited=function(u,m){return this.encode(u,m).ldelim()},s.decode=function(u,m){u instanceof f||(u=f.create(u));for(var b=m===void 0?u.len:u.pos+m,g=new c.onnx.TypeProto.Tensor;u.pos<b;){var _=u.uint32();switch(_>>>3){case 1:g.elemType=u.int32();break;case 2:g.shape=c.onnx.TensorShapeProto.decode(u,u.uint32());break;default:u.skipType(7&_)}}return g},s.decodeDelimited=function(u){return u instanceof f||(u=new f(u)),this.decode(u,u.uint32())},s.verify=function(u){if(typeof u!="object"||u===null)return"object expected";if(u.elemType!=null&&u.hasOwnProperty("elemType")&&!h.isInteger(u.elemType))return"elemType: integer expected";if(u.shape!=null&&u.hasOwnProperty("shape")){var m=c.onnx.TensorShapeProto.verify(u.shape);if(m)return"shape."+m}return null},s.fromObject=function(u){if(u instanceof c.onnx.TypeProto.Tensor)return u;var m=new c.onnx.TypeProto.Tensor;if(u.elemType!=null&&(m.elemType=0|u.elemType),u.shape!=null){if(typeof u.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");m.shape=c.onnx.TensorShapeProto.fromObject(u.shape)}return m},s.toObject=function(u,m){m||(m={});var b={};return m.defaults&&(b.elemType=0,b.shape=null),u.elemType!=null&&u.hasOwnProperty("elemType")&&(b.elemType=u.elemType),u.shape!=null&&u.hasOwnProperty("shape")&&(b.shape=c.onnx.TensorShapeProto.toObject(u.shape,m)),b},s.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},s}(),n}(),l.OperatorSetIdProto=function(){function n(e){if(e)for(var s=Object.keys(e),u=0;u<s.length;++u)e[s[u]]!=null&&(this[s[u]]=e[s[u]])}return n.prototype.domain="",n.prototype.version=h.Long?h.Long.fromBits(0,0,!1):0,n.create=function(e){return new n(e)},n.encode=function(e,s){return s||(s=p.create()),e.domain!=null&&e.hasOwnProperty("domain")&&s.uint32(10).string(e.domain),e.version!=null&&e.hasOwnProperty("version")&&s.uint32(16).int64(e.version),s},n.encodeDelimited=function(e,s){return this.encode(e,s).ldelim()},n.decode=function(e,s){e instanceof f||(e=f.create(e));for(var u=s===void 0?e.len:e.pos+s,m=new c.onnx.OperatorSetIdProto;e.pos<u;){var b=e.uint32();switch(b>>>3){case 1:m.domain=e.string();break;case 2:m.version=e.int64();break;default:e.skipType(7&b)}}return m},n.decodeDelimited=function(e){return e instanceof f||(e=new f(e)),this.decode(e,e.uint32())},n.verify=function(e){return typeof e!="object"||e===null?"object expected":e.domain!=null&&e.hasOwnProperty("domain")&&!h.isString(e.domain)?"domain: string expected":e.version!=null&&e.hasOwnProperty("version")&&!(h.isInteger(e.version)||e.version&&h.isInteger(e.version.low)&&h.isInteger(e.version.high))?"version: integer|Long expected":null},n.fromObject=function(e){if(e instanceof c.onnx.OperatorSetIdProto)return e;var s=new c.onnx.OperatorSetIdProto;return e.domain!=null&&(s.domain=String(e.domain)),e.version!=null&&(h.Long?(s.version=h.Long.fromValue(e.version)).unsigned=!1:typeof e.version=="string"?s.version=parseInt(e.version,10):typeof e.version=="number"?s.version=e.version:typeof e.version=="object"&&(s.version=new h.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),s},n.toObject=function(e,s){s||(s={});var u={};if(s.defaults)if(u.domain="",h.Long){var m=new h.Long(0,0,!1);u.version=s.longs===String?m.toString():s.longs===Number?m.toNumber():m}else u.version=s.longs===String?"0":0;return e.domain!=null&&e.hasOwnProperty("domain")&&(u.domain=e.domain),e.version!=null&&e.hasOwnProperty("version")&&(typeof e.version=="number"?u.version=s.longs===String?String(e.version):e.version:u.version=s.longs===String?h.Long.prototype.toString.call(e.version):s.longs===Number?new h.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),u},n.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},n}(),l),d.exports=c},2100:(d,t,i)=>{d.exports=i(9482)},9482:(d,t,i)=>{var r=t;function o(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build="minimal",r.Writer=i(1173),r.BufferWriter=i(3155),r.Reader=i(1408),r.BufferReader=i(593),r.util=i(9693),r.rpc=i(5994),r.roots=i(5054),r.configure=o,o()},1408:(d,t,i)=>{d.exports=p;var r,o=i(9693),l=o.LongBits,a=o.utf8;function f(m,b){return RangeError("index out of range: "+m.pos+" + "+(b||1)+" > "+m.len)}function p(m){this.buf=m,this.pos=0,this.len=m.length}var h,c=typeof Uint8Array<"u"?function(m){if(m instanceof Uint8Array||Array.isArray(m))return new p(m);throw Error("illegal buffer")}:function(m){if(Array.isArray(m))return new p(m);throw Error("illegal buffer")},n=function(){return o.Buffer?function(m){return(p.create=function(b){return o.Buffer.isBuffer(b)?new r(b):c(b)})(m)}:c};function e(){var m=new l(0,0),b=0;if(!(this.len-this.pos>4)){for(;b<3;++b){if(this.pos>=this.len)throw f(this);if(m.lo=(m.lo|(127&this.buf[this.pos])<<7*b)>>>0,this.buf[this.pos++]<128)return m}return m.lo=(m.lo|(127&this.buf[this.pos++])<<7*b)>>>0,m}for(;b<4;++b)if(m.lo=(m.lo|(127&this.buf[this.pos])<<7*b)>>>0,this.buf[this.pos++]<128)return m;if(m.lo=(m.lo|(127&this.buf[this.pos])<<28)>>>0,m.hi=(m.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return m;if(b=0,this.len-this.pos>4){for(;b<5;++b)if(m.hi=(m.hi|(127&this.buf[this.pos])<<7*b+3)>>>0,this.buf[this.pos++]<128)return m}else for(;b<5;++b){if(this.pos>=this.len)throw f(this);if(m.hi=(m.hi|(127&this.buf[this.pos])<<7*b+3)>>>0,this.buf[this.pos++]<128)return m}throw Error("invalid varint encoding")}function s(m,b){return(m[b-4]|m[b-3]<<8|m[b-2]<<16|m[b-1]<<24)>>>0}function u(){if(this.pos+8>this.len)throw f(this,8);return new l(s(this.buf,this.pos+=4),s(this.buf,this.pos+=4))}p.create=n(),p.prototype._slice=o.Array.prototype.subarray||o.Array.prototype.slice,p.prototype.uint32=(h=4294967295,function(){if(h=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(h=(h|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(h=(h|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(h=(h|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(h=(h|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return h;if((this.pos+=5)>this.len)throw this.pos=this.len,f(this,10);return h}),p.prototype.int32=function(){return 0|this.uint32()},p.prototype.sint32=function(){var m=this.uint32();return m>>>1^-(1&m)|0},p.prototype.bool=function(){return this.uint32()!==0},p.prototype.fixed32=function(){if(this.pos+4>this.len)throw f(this,4);return s(this.buf,this.pos+=4)},p.prototype.sfixed32=function(){if(this.pos+4>this.len)throw f(this,4);return 0|s(this.buf,this.pos+=4)},p.prototype.float=function(){if(this.pos+4>this.len)throw f(this,4);var m=o.float.readFloatLE(this.buf,this.pos);return this.pos+=4,m},p.prototype.double=function(){if(this.pos+8>this.len)throw f(this,4);var m=o.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,m},p.prototype.bytes=function(){var m=this.uint32(),b=this.pos,g=this.pos+m;if(g>this.len)throw f(this,m);return this.pos+=m,Array.isArray(this.buf)?this.buf.slice(b,g):b===g?new this.buf.constructor(0):this._slice.call(this.buf,b,g)},p.prototype.string=function(){var m=this.bytes();return a.read(m,0,m.length)},p.prototype.skip=function(m){if(typeof m=="number"){if(this.pos+m>this.len)throw f(this,m);this.pos+=m}else do if(this.pos>=this.len)throw f(this);while(128&this.buf[this.pos++]);return this},p.prototype.skipType=function(m){switch(m){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(m=7&this.uint32())!=4;)this.skipType(m);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+m+" at offset "+this.pos)}return this},p._configure=function(m){r=m,p.create=n(),r._configure();var b=o.Long?"toLong":"toNumber";o.merge(p.prototype,{int64:function(){return e.call(this)[b](!1)},uint64:function(){return e.call(this)[b](!0)},sint64:function(){return e.call(this).zzDecode()[b](!1)},fixed64:function(){return u.call(this)[b](!0)},sfixed64:function(){return u.call(this)[b](!1)}})}},593:(d,t,i)=>{d.exports=l;var r=i(1408);(l.prototype=Object.create(r.prototype)).constructor=l;var o=i(9693);function l(a){r.call(this,a)}l._configure=function(){o.Buffer&&(l.prototype._slice=o.Buffer.prototype.slice)},l.prototype.string=function(){var a=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+a,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+a,this.len))},l._configure()},5054:d=>{d.exports={}},5994:(d,t,i)=>{t.Service=i(7948)},7948:(d,t,i)=>{d.exports=o;var r=i(9693);function o(l,a,f){if(typeof l!="function")throw TypeError("rpcImpl must be a function");r.EventEmitter.call(this),this.rpcImpl=l,this.requestDelimited=Boolean(a),this.responseDelimited=Boolean(f)}(o.prototype=Object.create(r.EventEmitter.prototype)).constructor=o,o.prototype.rpcCall=function l(a,f,p,h,c){if(!h)throw TypeError("request must be specified");var n=this;if(!c)return r.asPromise(l,n,a,f,p,h);if(n.rpcImpl)try{return n.rpcImpl(a,f[n.requestDelimited?"encodeDelimited":"encode"](h).finish(),function(e,s){if(e)return n.emit("error",e,a),c(e);if(s!==null){if(!(s instanceof p))try{s=p[n.responseDelimited?"decodeDelimited":"decode"](s)}catch(u){return n.emit("error",u,a),c(u)}return n.emit("data",s,a),c(null,s)}n.end(!0)})}catch(e){return n.emit("error",e,a),void setTimeout(function(){c(e)},0)}else setTimeout(function(){c(Error("already ended"))},0)},o.prototype.end=function(l){return this.rpcImpl&&(l||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(d,t,i)=>{d.exports=o;var r=i(9693);function o(p,h){this.lo=p>>>0,this.hi=h>>>0}var l=o.zero=new o(0,0);l.toNumber=function(){return 0},l.zzEncode=l.zzDecode=function(){return this},l.length=function(){return 1};var a=o.zeroHash="\0\0\0\0\0\0\0\0";o.fromNumber=function(p){if(p===0)return l;var h=p<0;h&&(p=-p);var c=p>>>0,n=(p-c)/4294967296>>>0;return h&&(n=~n>>>0,c=~c>>>0,++c>4294967295&&(c=0,++n>4294967295&&(n=0))),new o(c,n)},o.from=function(p){if(typeof p=="number")return o.fromNumber(p);if(r.isString(p)){if(!r.Long)return o.fromNumber(parseInt(p,10));p=r.Long.fromString(p)}return p.low||p.high?new o(p.low>>>0,p.high>>>0):l},o.prototype.toNumber=function(p){if(!p&&this.hi>>>31){var h=1+~this.lo>>>0,c=~this.hi>>>0;return h||(c=c+1>>>0),-(h+4294967296*c)}return this.lo+4294967296*this.hi},o.prototype.toLong=function(p){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(p)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(p)}};var f=String.prototype.charCodeAt;o.fromHash=function(p){return p===a?l:new o((f.call(p,0)|f.call(p,1)<<8|f.call(p,2)<<16|f.call(p,3)<<24)>>>0,(f.call(p,4)|f.call(p,5)<<8|f.call(p,6)<<16|f.call(p,7)<<24)>>>0)},o.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},o.prototype.zzEncode=function(){var p=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^p)>>>0,this.lo=(this.lo<<1^p)>>>0,this},o.prototype.zzDecode=function(){var p=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^p)>>>0,this.hi=(this.hi>>>1^p)>>>0,this},o.prototype.length=function(){var p=this.lo,h=(this.lo>>>28|this.hi<<4)>>>0,c=this.hi>>>24;return c===0?h===0?p<16384?p<128?1:2:p<2097152?3:4:h<16384?h<128?5:6:h<2097152?7:8:c<128?9:10}},9693:function(d,t,i){var r=t;function o(a,f,p){for(var h=Object.keys(f),c=0;c<h.length;++c)a[h[c]]!==void 0&&p||(a[h[c]]=f[h[c]]);return a}function l(a){function f(p,h){if(!(this instanceof f))return new f(p,h);Object.defineProperty(this,"message",{get:function(){return p}}),Error.captureStackTrace?Error.captureStackTrace(this,f):Object.defineProperty(this,"stack",{value:new Error().stack||""}),h&&o(this,h)}return(f.prototype=Object.create(Error.prototype)).constructor=f,Object.defineProperty(f.prototype,"name",{get:function(){return a}}),f.prototype.toString=function(){return this.name+": "+this.message},f}r.asPromise=i(4537),r.base64=i(7419),r.EventEmitter=i(9211),r.float=i(945),r.inquire=i(7199),r.utf8=i(4997),r.pool=i(6662),r.LongBits=i(1945),r.isNode=Boolean(i.g!==void 0&&i.g&&i.g.process&&i.g.process.versions&&i.g.process.versions.node),r.global=r.isNode&&i.g||typeof window<"u"&&window||typeof self<"u"&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(a){return typeof a=="number"&&isFinite(a)&&Math.floor(a)===a},r.isString=function(a){return typeof a=="string"||a instanceof String},r.isObject=function(a){return a&&typeof a=="object"},r.isset=r.isSet=function(a,f){var p=a[f];return!(p==null||!a.hasOwnProperty(f))&&(typeof p!="object"||(Array.isArray(p)?p.length:Object.keys(p).length)>0)},r.Buffer=function(){try{var a=r.inquire("buffer").Buffer;return a.prototype.utf8Write?a:null}catch{return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(a){return typeof a=="number"?r.Buffer?r._Buffer_allocUnsafe(a):new r.Array(a):r.Buffer?r._Buffer_from(a):typeof Uint8Array>"u"?a:new Uint8Array(a)},r.Array=typeof Uint8Array<"u"?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(a){return a?r.LongBits.from(a).toHash():r.LongBits.zeroHash},r.longFromHash=function(a,f){var p=r.LongBits.fromHash(a);return r.Long?r.Long.fromBits(p.lo,p.hi,f):p.toNumber(Boolean(f))},r.merge=o,r.lcFirst=function(a){return a.charAt(0).toLowerCase()+a.substring(1)},r.newError=l,r.ProtocolError=l("ProtocolError"),r.oneOfGetter=function(a){for(var f={},p=0;p<a.length;++p)f[a[p]]=1;return function(){for(var h=Object.keys(this),c=h.length-1;c>-1;--c)if(f[h[c]]===1&&this[h[c]]!==void 0&&this[h[c]]!==null)return h[c]}},r.oneOfSetter=function(a){return function(f){for(var p=0;p<a.length;++p)a[p]!==f&&delete this[a[p]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var a=r.Buffer;a?(r._Buffer_from=a.from!==Uint8Array.from&&a.from||function(f,p){return new a(f,p)},r._Buffer_allocUnsafe=a.allocUnsafe||function(f){return new a(f)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(d,t,i)=>{d.exports=n;var r,o=i(9693),l=o.LongBits,a=o.base64,f=o.utf8;function p(_,y,v){this.fn=_,this.len=y,this.next=void 0,this.val=v}function h(){}function c(_){this.head=_.head,this.tail=_.tail,this.len=_.len,this.next=_.states}function n(){this.len=0,this.head=new p(h,0,0),this.tail=this.head,this.states=null}var e=function(){return o.Buffer?function(){return(n.create=function(){return new r})()}:function(){return new n}};function s(_,y,v){y[v]=255&_}function u(_,y){this.len=_,this.next=void 0,this.val=y}function m(_,y,v){for(;_.hi;)y[v++]=127&_.lo|128,_.lo=(_.lo>>>7|_.hi<<25)>>>0,_.hi>>>=7;for(;_.lo>127;)y[v++]=127&_.lo|128,_.lo=_.lo>>>7;y[v++]=_.lo}function b(_,y,v){y[v]=255&_,y[v+1]=_>>>8&255,y[v+2]=_>>>16&255,y[v+3]=_>>>24}n.create=e(),n.alloc=function(_){return new o.Array(_)},o.Array!==Array&&(n.alloc=o.pool(n.alloc,o.Array.prototype.subarray)),n.prototype._push=function(_,y,v){return this.tail=this.tail.next=new p(_,y,v),this.len+=y,this},u.prototype=Object.create(p.prototype),u.prototype.fn=function(_,y,v){for(;_>127;)y[v++]=127&_|128,_>>>=7;y[v]=_},n.prototype.uint32=function(_){return this.len+=(this.tail=this.tail.next=new u((_>>>=0)<128?1:_<16384?2:_<2097152?3:_<268435456?4:5,_)).len,this},n.prototype.int32=function(_){return _<0?this._push(m,10,l.fromNumber(_)):this.uint32(_)},n.prototype.sint32=function(_){return this.uint32((_<<1^_>>31)>>>0)},n.prototype.uint64=function(_){var y=l.from(_);return this._push(m,y.length(),y)},n.prototype.int64=n.prototype.uint64,n.prototype.sint64=function(_){var y=l.from(_).zzEncode();return this._push(m,y.length(),y)},n.prototype.bool=function(_){return this._push(s,1,_?1:0)},n.prototype.fixed32=function(_){return this._push(b,4,_>>>0)},n.prototype.sfixed32=n.prototype.fixed32,n.prototype.fixed64=function(_){var y=l.from(_);return this._push(b,4,y.lo)._push(b,4,y.hi)},n.prototype.sfixed64=n.prototype.fixed64,n.prototype.float=function(_){return this._push(o.float.writeFloatLE,4,_)},n.prototype.double=function(_){return this._push(o.float.writeDoubleLE,8,_)};var g=o.Array.prototype.set?function(_,y,v){y.set(_,v)}:function(_,y,v){for(var w=0;w<_.length;++w)y[v+w]=_[w]};n.prototype.bytes=function(_){var y=_.length>>>0;if(!y)return this._push(s,1,0);if(o.isString(_)){var v=n.alloc(y=a.length(_));a.decode(_,v,0),_=v}return this.uint32(y)._push(g,y,_)},n.prototype.string=function(_){var y=f.length(_);return y?this.uint32(y)._push(f.write,y,_):this._push(s,1,0)},n.prototype.fork=function(){return this.states=new c(this),this.head=this.tail=new p(h,0,0),this.len=0,this},n.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new p(h,0,0),this.len=0),this},n.prototype.ldelim=function(){var _=this.head,y=this.tail,v=this.len;return this.reset().uint32(v),v&&(this.tail.next=_.next,this.tail=y,this.len+=v),this},n.prototype.finish=function(){for(var _=this.head.next,y=this.constructor.alloc(this.len),v=0;_;)_.fn(_.val,y,v),v+=_.len,_=_.next;return y},n._configure=function(_){r=_,n.create=e(),r._configure()}},3155:(d,t,i)=>{d.exports=l;var r=i(1173);(l.prototype=Object.create(r.prototype)).constructor=l;var o=i(9693);function l(){r.call(this)}function a(f,p,h){f.length<40?o.utf8.write(f,p,h):p.utf8Write?p.utf8Write(f,h):p.write(f,h)}l._configure=function(){l.alloc=o._Buffer_allocUnsafe,l.writeBytesBuffer=o.Buffer&&o.Buffer.prototype instanceof Uint8Array&&o.Buffer.prototype.set.name==="set"?function(f,p,h){p.set(f,h)}:function(f,p,h){if(f.copy)f.copy(p,h,0,f.length);else for(var c=0;c<f.length;)p[h++]=f[c++]}},l.prototype.bytes=function(f){o.isString(f)&&(f=o._Buffer_from(f,"base64"));var p=f.length>>>0;return this.uint32(p),p&&this._push(l.writeBytesBuffer,p,f),this},l.prototype.string=function(f){var p=o.Buffer.byteLength(f);return this.uint32(p),p&&this._push(a,p,f),this},l._configure()},7714:(d,t,i)=>{t.R=void 0;const r=i(6919),o=i(7448);t.R=new class{async init(){}async createSessionHandler(l,a){const f=new r.Session(a);return await f.loadModel(l),new o.OnnxjsSessionHandler(f)}}},4200:(d,t,i)=>{t.c8=t.rX=void 0;const r=i(1670),o=i(5381),l=i(2157),a=i(2306);t.rX=()=>{if((typeof r.env.wasm.initTimeout!="number"||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),typeof r.env.wasm.simd!="boolean"&&(r.env.wasm.simd=!0),typeof r.env.wasm.proxy!="boolean"&&(r.env.wasm.proxy=!1),typeof r.env.wasm.numThreads!="number"||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const f=typeof navigator>"u"?(0,o.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((f||1)/2))}},t.c8=new class{async init(){(0,t.rX)(),await(0,l.initWasm)()}async createSessionHandler(f,p){const h=new a.OnnxruntimeWebAssemblySessionHandler;return await h.loadModel(f,p),Promise.resolve(h)}}},6018:function(d,t,i){var r=this&&this.__createBinding||(Object.create?function(a,f,p,h){h===void 0&&(h=p);var c=Object.getOwnPropertyDescriptor(f,p);c&&!("get"in c?!f.__esModule:c.writable||c.configurable)||(c={enumerable:!0,get:function(){return f[p]}}),Object.defineProperty(a,h,c)}:function(a,f,p,h){h===void 0&&(h=p),a[h]=f[p]}),o=this&&this.__exportStar||function(a,f){for(var p in a)p==="default"||Object.prototype.hasOwnProperty.call(f,p)||r(f,a,p)};Object.defineProperty(t,"__esModule",{value:!0}),o(i(1670),t);const l=i(1670);{const a=i(7714).R;(0,l.registerBackend)("webgl",a,-10)}{const a=i(4200).c8;(0,l.registerBackend)("cpu",a,10),(0,l.registerBackend)("wasm",a,10),(0,l.registerBackend)("xnnpack",a,9)}},246:(d,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class i{constructor(o){Object.assign(this,o)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(o=>`${this[o]}`).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=r=>new i(r)},7778:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Attribute=void 0;const r=i(1446),o=i(9395),l=i(9162),a=i(2517);var f=o.onnxruntime.experimental.fbs;class p{constructor(c){if(this._attributes=new Map,c!=null){for(const n of c)n instanceof r.onnx.AttributeProto?this._attributes.set(n.name,[p.getValue(n),p.getType(n)]):n instanceof f.Attribute&&this._attributes.set(n.name(),[p.getValue(n),p.getType(n)]);if(this._attributes.size<c.length)throw new Error("duplicated attribute names")}}set(c,n,e){this._attributes.set(c,[e,n])}delete(c){this._attributes.delete(c)}getFloat(c,n){return this.get(c,"float",n)}getInt(c,n){return this.get(c,"int",n)}getString(c,n){return this.get(c,"string",n)}getTensor(c,n){return this.get(c,"tensor",n)}getFloats(c,n){return this.get(c,"floats",n)}getInts(c,n){return this.get(c,"ints",n)}getStrings(c,n){return this.get(c,"strings",n)}getTensors(c,n){return this.get(c,"tensors",n)}get(c,n,e){const s=this._attributes.get(c);if(s===void 0){if(e!==void 0)return e;throw new Error(`required attribute not found: ${c}`)}if(s[1]!==n)throw new Error(`type mismatch: expected ${n} but got ${s[1]}`);return s[0]}static getType(c){const n=c instanceof r.onnx.AttributeProto?c.type:c.type();switch(n){case r.onnx.AttributeProto.AttributeType.FLOAT:return"float";case r.onnx.AttributeProto.AttributeType.INT:return"int";case r.onnx.AttributeProto.AttributeType.STRING:return"string";case r.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case r.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case r.onnx.AttributeProto.AttributeType.INTS:return"ints";case r.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case r.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[n]}`)}}static getValue(c){const n=c instanceof r.onnx.AttributeProto?c.type:c.type();if(n===r.onnx.AttributeProto.AttributeType.GRAPH||n===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const e=this.getValueNoCheck(c);if(n===r.onnx.AttributeProto.AttributeType.INT&&a.LongUtil.isLong(e))return a.LongUtil.longToNumber(e);if(n===r.onnx.AttributeProto.AttributeType.INTS){const s=e,u=new Array(s.length);for(let m=0;m<s.length;m++){const b=s[m];u[m]=a.LongUtil.longToNumber(b)}return u}if(n===r.onnx.AttributeProto.AttributeType.TENSOR)return c instanceof r.onnx.AttributeProto?l.Tensor.fromProto(e):l.Tensor.fromOrtTensor(e);if(n===r.onnx.AttributeProto.AttributeType.TENSORS){if(c instanceof r.onnx.AttributeProto)return e.map(s=>l.Tensor.fromProto(s));if(c instanceof f.Attribute)return e.map(s=>l.Tensor.fromOrtTensor(s))}if(n===r.onnx.AttributeProto.AttributeType.STRING&&c instanceof r.onnx.AttributeProto){const s=e;return(0,a.decodeUtf8String)(s)}return n===r.onnx.AttributeProto.AttributeType.STRINGS&&c instanceof r.onnx.AttributeProto?e.map(a.decodeUtf8String):e}static getValueNoCheck(c){return c instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(c):this.getValueNoCheckFromOrtFormat(c)}static getValueNoCheckFromOnnxFormat(c){switch(c.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return c.f;case r.onnx.AttributeProto.AttributeType.INT:return c.i;case r.onnx.AttributeProto.AttributeType.STRING:return c.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return c.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return c.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return c.floats;case r.onnx.AttributeProto.AttributeType.INTS:return c.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return c.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return c.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return c.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[c.type]}`)}}static getValueNoCheckFromOrtFormat(c){switch(c.type()){case f.AttributeType.FLOAT:return c.f();case f.AttributeType.INT:return c.i();case f.AttributeType.STRING:return c.s();case f.AttributeType.TENSOR:return c.t();case f.AttributeType.GRAPH:return c.g();case f.AttributeType.FLOATS:return c.floatsArray();case f.AttributeType.INTS:{const n=[];for(let e=0;e<c.intsLength();e++)n.push(c.ints(e));return n}case f.AttributeType.STRINGS:{const n=[];for(let e=0;e<c.stringsLength();e++)n.push(c.strings(e));return n}case f.AttributeType.TENSORS:{const n=[];for(let e=0;e<c.tensorsLength();e++)n.push(c.tensors(e));return n}default:throw new Error(`unsupported attribute type: ${f.AttributeType[c.type()]}`)}}}t.Attribute=p},7091:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBackend=t.backend=void 0;const r=i(5038),o=new Map;async function l(a){const f=t.backend;if(f[a]!==void 0&&function(p){const h=p;return"initialize"in h&&typeof h.initialize=="function"&&"createSessionHandler"in h&&typeof h.createSessionHandler=="function"&&"dispose"in h&&typeof h.dispose=="function"}(f[a])){const p=f[a];let h=p.initialize();if(typeof h=="object"&&"then"in h&&(h=await h),h)return o.set(a,p),p}}t.backend={webgl:new r.WebGLBackend},t.resolveBackend=async function a(f){if(!f)return a(["webgl"]);{const p=typeof f=="string"?[f]:f;for(const h of p){const c=o.get(h);if(c)return c;const n=await l(h);if(n)return n}}throw new Error("no available backend to use")}},5038:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLBackend=void 0;const r=i(1670),o=i(6231),l=i(6416),a=i(7305);t.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(f){r.env.webgl.contextId=f}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(f){r.env.webgl.matmulMaxBatchSize=f}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(f){r.env.webgl.textureCacheMode=f}get pack(){return r.env.webgl.pack}set pack(f){r.env.webgl.pack=f}get async(){return r.env.webgl.async}set async(f){r.env.webgl.async=f}initialize(){try{return this.glContext=(0,a.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),o.Logger.setWithEnv(r.env),o.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(f){return o.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${f}`),!1}}createSessionHandler(f){return new l.WebGLSessionHandler(this,f)}dispose(){this.glContext.dispose()}}},5107:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.CoordsGlslLib=void 0;const r=i(2517),o=i(8520),l=i(5060),a=i(7859),f=i(9390);class p extends o.GlslLib{constructor(c){super(c)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new o.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new o.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const c=this.context.outputTextureLayout;return c.isPacked?this.getPackedOutputSamplingSnippet(c):this.getUnpackedOutputSamplingSnippet(c)}getPackedOutputSamplingSnippet(c){const n=c.unpackedShape,e=[c.width,c.height],s={},u="getOutputCoords";switch(n.length){case 0:s[u]=this.getOutputScalarCoords();break;case 1:s[u]=this.getOutputPacked1DCoords(n,e);break;case 2:s[u]=this.getOutputPacked2DCoords(n,e);break;case 3:s[u]=this.getOutputPacked3DCoords(n,e);break;default:s[u]=this.getOutputPackedNDCoords(n,e)}const m=`
      void setOutput(vec4 val) {
        ${(0,l.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return s.floatTextureSetRGBA=new o.GlslLibRoutine(m),s}getUnpackedOutputSamplingSnippet(c){const n=c.unpackedShape,e=[c.width,c.height],s={},u="getOutputCoords";switch(n.length){case 0:s[u]=this.getOutputScalarCoords();break;case 1:s[u]=this.getOutputUnpacked1DCoords(n,e);break;case 2:s[u]=this.getOutputUnpacked2DCoords(n,e);break;case 3:s[u]=this.getOutputUnpacked3DCoords(n,e);break;case 4:s[u]=this.getOutputUnpacked4DCoords(n,e);break;case 5:s[u]=this.getOutputUnpacked5DCoords(n,e);break;case 6:s[u]=this.getOutputUnpacked6DCoords(n,e);break;default:throw new Error(`Unsupported output dimensionality: ${n.length}`)}const m=`
        void setOutput(float val) {
          ${(0,l.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return s.floatTextureSetR=new o.GlslLibRoutine(m),s}getOutputScalarCoords(){return new o.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(c,n){const e=n;let s="";return e[0]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${e[1]}.0);
          }
        `,new o.GlslLibRoutine(s)):e[1]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${e[0]}.0);
          }
        `,new o.GlslLibRoutine(s)):(s=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${e[0]}, ${e[1]}));
          return 2 * (resTexRC.y * ${e[0]} + resTexRC.x);
        }
      `,new o.GlslLibRoutine(s))}getOutputPacked2DCoords(c,n){let e="";if(r.ArrayUtil.arraysEqual(c,n))return e=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${n[0]}, ${n[1]}));
        }
      `,new o.GlslLibRoutine(e);const s=n,u=Math.ceil(c[1]/2);return e=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));

          int index = resTexRC.y * ${s[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${u}) * 2;
          int c = 2 * (index / ${u});

          return ivec2(r, c);
        }
      `,new o.GlslLibRoutine(e)}getOutputPacked3DCoords(c,n){const e=[n[0],n[1]],s=Math.ceil(c[2]/2),u=s*Math.ceil(c[1]/2),m=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;

          int b = index / ${u};
          index -= b * ${u};

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec3(b, r, c);
        }
      `;return new o.GlslLibRoutine(m)}getOutputPackedNDCoords(c,n){const e=[n[0],n[1]],s=Math.ceil(c[c.length-1]/2),u=s*Math.ceil(c[c.length-2]/2);let m=u,b="",g="b, r, c";for(let y=2;y<c.length-1;y++)m*=c[c.length-y-1],b=`
      int b${y} = index / ${m};
      index -= b${y} * ${m};
    `+b,g=`b${y}, `+g;const _=`
      ivec${c.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.y * ${e[0]} + resTexRC.x;

        ${b}

        int b = index / ${u};
        index -= b * ${u};

        // reverse r and c order for packed texture
        int r = imod(index, ${s}) * 2;
        int c = 2 * (index / ${s});

        return ivec${c.length}(${g});
      }
    `;return new o.GlslLibRoutine(_)}getOutputUnpacked1DCoords(c,n){const e=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          return resTexRC.y * ${n[0]} + resTexRC.x;
        }
      `;return new o.GlslLibRoutine(e)}getOutputUnpacked2DCoords(c,n){const e=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          int r = index / ${c[1]};
          int c = index - r * ${c[1]};
          return ivec2(r, c);
        }
      `;return new o.GlslLibRoutine(e)}getOutputUnpacked3DCoords(c,n){let e="";const s=c.length;let u=null;s<2&&(u=[]),u=new Array(s-1),u[s-2]=c[s-1];for(let g=s-3;g>=0;--g)u[g]=u[g+1]*c[g+1];const m=["r","c","d"],b=u.map((g,_)=>`int ${m[_]} = index / ${g}; ${_===u.length-1?`int ${m[_+1]} = index - ${m[_]} * ${g}`:`index -= ${m[_]} * ${g}`};`).join("");return e=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${b}
          return ivec3(r, c, d);
        }
      `,new o.GlslLibRoutine(e)}getOutputUnpacked4DCoords(c,n){let e="";const s=c.length;let u=null;s<2&&(u=[]),u=new Array(s-1),u[s-2]=c[s-1];for(let g=s-3;g>=0;--g)u[g]=u[g+1]*c[g+1];const m=["r","c","d","d2"],b=u.map((g,_)=>`int ${m[_]} = index / ${g}; ${_===u.length-1?`int ${m[_+1]} = index - ${m[_]} * ${g}`:`index -= ${m[_]} * ${g}`};`).join("");return e=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${b}
          return ivec4(r, c, d, d2);
        }
      `,new o.GlslLibRoutine(e)}getOutputUnpacked5DCoords(c,n){let e="";const s=c.length;let u=null;s<2&&(u=[]),u=new Array(s-1),u[s-2]=c[s-1];for(let g=s-3;g>=0;--g)u[g]=u[g+1]*c[g+1];const m=["r","c","d","d2","d3"],b=u.map((g,_)=>`int ${m[_]} = index / ${g}; ${_===u.length-1?`int ${m[_+1]} = index - ${m[_]} * ${g}`:`index -= ${m[_]} * ${g}`};`).join("");return e=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${b}
          return ivec5(r, c, d, d2, d3);
        }
      `,new o.GlslLibRoutine(e)}getOutputUnpacked6DCoords(c,n){let e="";const s=c.length;let u=null;s<2&&(u=[]),u=new Array(s-1),u[s-2]=c[s-1];for(let g=s-3;g>=0;--g)u[g]=u[g+1]*c[g+1];const m=["r","c","d","d2","d3","d4"],b=u.map((g,_)=>`int ${m[_]} = index / ${g}; ${_===u.length-1?`int ${m[_+1]} = index - ${m[_]} * ${g}`:`index -= ${m[_]} * ${g}`};`).join("");return e=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${n[0]}, ${n[1]}));
         int index = resTexRC.y * ${n[0]} + resTexRC.x;
         ${b}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new o.GlslLibRoutine(e)}getCommonUtilFuncs(){const c={};let n="uvFromFlat";c[n]=new o.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),n="packedUVfrom1D",c[n]=new o.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom2D",c[n]=new o.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom3D",c[n]=new o.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="sampleTexture";const e=(0,l.getGlsl)(this.context.glContext.version);return c[n]=new o.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${e.texture2D}(textureSampler, uv).r;
        }`),c}getInputsSamplingSnippets(){const c={},n=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((e,s)=>{const u=this.context.inputTextureLayouts[s],m=(0,f.generateShaderFuncNameFromInputSamplerName)(e);u.isPacked?c[m]=this.getPackedSamplerFromInput(m,e,u):c[m]=this.getUnpackedSamplerFromInput(m,e,u);const b=(0,f.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(e);u.unpackedShape.length<=n.unpackedShape.length&&(u.isPacked?c[b]=this.getPackedSamplerAtOutputCoords(b,u,n,e):c[b]=this.getUnpackedSamplerAtOutputCoords(b,u,n,e))}),c}getPackedSamplerAtOutputCoords(c,n,e,s){const u=n.unpackedShape,m=e.unpackedShape,b=s,g=(0,f.generateShaderFuncNameFromInputSamplerName)(b),_=u.length,y=m.length,v=r.BroadcastUtil.getBroadcastDims(u,m),w=(0,f.getCoordsDataType)(y),M=y-_;let S;const O=(0,f.getGlChannels)();S=_===0?"":y<2&&v.length>=1?"coords = 0;":v.map(N=>`coords.${O[N+M]} = 0;`).join(`
`);let x="";x=y<2&&_>0?"coords":u.map((N,B)=>`coords.${O[B+M]}`).join(", ");let T="return outputValue;";const I=r.ShapeUtil.size(u)===1,F=r.ShapeUtil.size(m)===1;if(_!==1||I||F){if(I&&!F)T=y===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(v.length){const N=_-2,B=_-1;v.indexOf(N)>-1&&v.indexOf(B)>-1?T="return vec4(outputValue.x);":v.indexOf(N)>-1?T="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":v.indexOf(B)>-1&&(T="return vec4(outputValue.xx, outputValue.zz);")}}else T=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const C=`
      vec4 ${c}() {
        ${w} coords = getOutputCoords();
        
        int lastDim = coords.${O[y-1]};
        coords.${O[y-1]} = coords.${O[y-2]};
        coords.${O[y-2]} = lastDim;
      
        ${S}
        vec4 outputValue = ${g}(${x});
        ${T}
      }
    `;return new o.GlslLibRoutine(C,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(c,n,e,s){const u=[e.width,e.height],m=[n.width,n.height],b=n.unpackedShape.length,g=e.unpackedShape.length,_=n.unpackedShape,y=e.unpackedShape,v=(0,f.generateShaderFuncNameFromInputSamplerName)(s);if(b===g&&r.ArrayUtil.arraysEqual(m,u)){const F=`
          float ${c}() {
            return sampleTexture(${s}, TexCoords);
          }
        `;return new o.GlslLibRoutine(F,["coordinates.sampleTexture"])}const w=(0,f.getCoordsDataType)(g),M=r.BroadcastUtil.getBroadcastDims(_,y),S=g-b;let O;const x=(0,f.getGlChannels)();O=b===0?"":g<2&&M.length>=1?"coords = 0;":M.map(F=>`coords.${x[F+S]} = 0;`).join(`
`);let T="";T=g<2&&b>0?"coords":n.unpackedShape.map((F,C)=>`coords.${x[C+S]}`).join(", ");const I=`
        float ${c}() {
          ${w} coords = getOutputCoords();
          ${O}
          return ${v}(${T});
        }
      `;return new o.GlslLibRoutine(I,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(c,n,e){switch(e.unpackedShape.length){case 0:return this.getPackedSamplerScalar(c,n);case 1:return this.getPackedSampler1D(c,n,e);case 2:return this.getPackedSampler2D(c,n,e);case 3:return this.getPackedSampler3D(c,n,e);default:return this.getPackedSamplerND(c,n,e)}}getUnpackedSamplerFromInput(c,n,e){const s=e.unpackedShape;switch(s.length){case 0:return this.getUnpackedSamplerScalar(c,n,e);case 1:return this.getUnpackedSampler1D(c,n,e);case 2:return this.getUnpackedSampler2D(c,n,e);case 3:return this.getUnpackedSampler3D(c,n,e);case 4:return this.getUnpackedSampler4D(c,n,e);case 5:return this.getUnpackedSampler5D(c,n,e);case 6:return this.getUnpackedSampler6D(c,n,e);default:throw new Error(`Unsupported dimension ${s.length}-D`)}}getPackedSamplerScalar(c,n){const e=`
          vec4 ${c}() {
            return ${(0,l.getGlsl)(this.context.glContext.version).texture2D}(${n}, halfCR);
          }
        `;return new o.GlslLibRoutine(e)}getPackedSampler1D(c,n,e){const s=[e.width,e.height],u=[s[1],s[0]],m=(0,l.getGlsl)(this.context.glContext.version),b=`vec4 ${c}(int index) {
      vec2 uv = packedUVfrom1D(
      ${u[0]}, ${u[1]}, index);
      return ${m.texture2D}(${n}, uv);
    }`;return new o.GlslLibRoutine(b,["coordinates.packedUVfrom1D"])}getPackedSampler2D(c,n,e){const s=e.unpackedShape,u=[e.width,e.height],m=(0,l.getGlsl)(this.context.glContext.version),b=u[0],g=u[1];if(u!=null&&r.ArrayUtil.arraysEqual(s,u)){const w=`vec4 ${c}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${b}.0);
        return ${m.texture2D}(${n}, uv);
      }`;return new o.GlslLibRoutine(w)}const _=u,y=Math.ceil(s[1]/2),v=`vec4 ${c}(int row, int col) {
      vec2 uv = packedUVfrom2D(${_[1]}, ${_[0]}, ${y}, row, col);
      return ${m.texture2D}(${n}, uv);
    }`;return new o.GlslLibRoutine(v,["coordinates.packedUVfrom2D"])}getPackedSampler3D(c,n,e){const s=e.unpackedShape,u=[e.width,e.height],m=[u[0],u[1]],b=(0,l.getGlsl)(this.context.glContext.version);if(s[0]===1){const w=s.slice(1),M=[1,2],S=(0,f.squeezeInputShape)(s,w),O=["b","row","col"],x=JSON.parse(JSON.stringify(e));x.unpackedShape=S;const T=this.getPackedSamplerFromInput(c,n,x),I=`${T.routineBody}
      vec4 ${c}(int b, int row, int col) {
        return ${c}(${(0,f.getSqueezedParams)(O,M)});
      } `;return new o.GlslLibRoutine(I,T.dependencies)}const g=m[0],_=m[1],y=Math.ceil(s[2]/2),v=`vec4 ${c}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${_}, ${g}, ${y*Math.ceil(s[1]/2)}, ${y}, b, row, col);
      return ${b.texture2D}(${n}, uv);}`;return new o.GlslLibRoutine(v,["coordinates.packedUVfrom3D"])}getPackedSamplerND(c,n,e){const s=e.unpackedShape,u=s.length,m=[e.width,e.height],b=(0,l.getGlsl)(this.context.glContext.version),g=[m[0],m[1]],_=g[1],y=g[0],v=Math.ceil(s[u-1]/2);let w=v*Math.ceil(s[u-2]/2),M="int b, int row, int col",S=`b * ${w} + (row / 2) * ${v} + (col / 2)`;for(let x=2;x<u-1;x++)M=`int b${x}, `+M,w*=s[u-x-1],S=`b${x} * ${w} + `+S;const O=`vec4 ${c}(${M}) {
      int index = ${S};
      int texR = index / ${y};
      int texC = index - texR * ${y};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${y}, ${_});
      return ${b.texture2D}(${n}, uv);
    }`;return new o.GlslLibRoutine(O)}getUnpackedSamplerScalar(c,n,e){const[s,u]=[e.width,e.height];if(s===1&&u===1){const b=`
          float ${c}() {
            return sampleTexture(${n}, halfCR);
          }
        `;return new o.GlslLibRoutine(b,["coordinates.sampleTexture"])}const m=`
        float ${c}() {
          int offset_${n} = coordsToOffset(TexCoords, ${s}, ${u});
          vec2 uv = uvFromFlat(${s}, ${u}, offset_${n});
          return sampleTexture(${n}, uv);
        }
      `;return new o.GlslLibRoutine(m,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(c,n,e){const s=e.width,u=e.height;if(u===1&&s===1){const b=`
        float ${c}(int index) {
          return sampleTexture(${n}, halfCR);
        }
      `;return new o.GlslLibRoutine(b,["coordinates.sampleTexture"])}if(u===1){const b=`
          float ${c}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${s}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new o.GlslLibRoutine(b,["coordinates.sampleTexture"])}if(s===1){const b=`
          float ${c}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${u}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new o.GlslLibRoutine(b,["coordinates.sampleTexture"])}const m=`
        float ${c}(int index) {
          vec2 uv = uvFromFlat(${s}, ${u}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new o.GlslLibRoutine(m,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(c,n,e){const s=e.unpackedShape,u=[e.height,e.width];if(u!=null&&r.ArrayUtil.arraysEqual(s,u)){const w=`
          float ${c}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new o.GlslLibRoutine(w,["coordinates.sampleTexture"])}const{newShape:m,keptDims:b}=(0,a.squeezeShape)(s),g=m;if(g.length<s.length){const w=(0,f.squeezeInputShape)(s,g),M=JSON.parse(JSON.stringify(e));M.unpackedShape=w;const S=["col","row"],O=`
          ${this.getUnpackedSamplerFromInput(c,n,M).routineBody}
          float ${c}(int row, int col) {
            return ${c}(${(0,f.getSqueezedParams)(S,b)});
          }
        `;return new o.GlslLibRoutine(O,["coordinates.sampleTexture"])}const _=u[1],y=u[0];if(y===1){const w=`
          float ${c}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${_}, ${y});
            float index = dot(vec3(row, col, offset_${n}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${_}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new o.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(_===1){const w=`
          float ${c}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${_}, ${y});
            float index = dot(vec3(row, col, offset_${n}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${y}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new o.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const v=`
        float ${c}(int row, int col) {
          int index = col * ${s[1]} + row;
          vec2 uv = uvFromFlat(${_}, ${y}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new o.GlslLibRoutine(v,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(c,n,e){const s=e.unpackedShape,u=s[1]*s[2],m=s[2],{newShape:b,keptDims:g}=(0,a.squeezeShape)(s),_=b;if(_.length<s.length){const v=(0,f.squeezeInputShape)(s,_),w=["batch","col","row"],M=JSON.parse(JSON.stringify(e));M.unpackedShape=v;const S=this.getUnpackedSamplerFromInput(c,n,M),O=g.reverse(),x=`
          ${S.routineBody}
          float ${c}(int batch, int row, int col) {
            return ${c}(${(0,f.getSqueezedParams)(w,O)});
          }
        `;return new o.GlslLibRoutine(x,S.dependencies)}const y=`
          float ${c}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${u} + col * ${m} + row;
            vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
            return sampleTexture(${n}, uv);
          }
      `;return new o.GlslLibRoutine(y,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(c,n,e){const s=e.unpackedShape,u=s[3],m=s[2]*u,b=`
        float ${c}(int row, int col, int depth, int depth2) {
          int index = row * ${s[1]*m} + col * ${m} +
              depth2 * ${u} + depth;
          vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new o.GlslLibRoutine(b,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(c,n,e){const s=e.unpackedShape,u=s[4],m=s[3]*u,b=s[2]*m,g=s[1]*b,{newShape:_,keptDims:y}=(0,a.squeezeShape)(s);if(_.length<s.length){const w=(0,f.squeezeInputShape)(s,_),M=["row","col","depth","depth2","depth3"],S=JSON.parse(JSON.stringify(e));S.unpackedShape=w;const O=`
          ${this.getUnpackedSamplerFromInput(c,n,S).routineBody}
          float ${c}(int row, int col, int depth, int depth2, int depth3) {
            return ${c}(${(0,f.getSqueezedParams)(M,y)});
          }
        `;return new o.GlslLibRoutine(O,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const v=`
        float ${c}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${g} + col * ${b} + depth * ${m} +
          depth3 * ${u} + depth2;
          vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new o.GlslLibRoutine(v,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(c,n,e){const s=e.unpackedShape,u=s[5],m=s[4]*u,b=s[3]*m,g=s[2]*b,_=s[1]*g,{newShape:y,keptDims:v}=(0,a.squeezeShape)(s);if(y.length<s.length){const M=(0,f.squeezeInputShape)(s,y),S=["row","col","depth","depth2","depth3","depth4"],O=JSON.parse(JSON.stringify(e));O.unpackedShape=M;const x=`
            ${this.getUnpackedSamplerFromInput(c,n,O).routineBody}
            float ${c}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${c}(${(0,f.getSqueezedParams)(S,v)});
            }
          `;return new o.GlslLibRoutine(x,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const w=`
          float ${c}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${_} + col * ${g} + depth * ${b} +
            depth2 * ${m} + depth3 * ${u} + depth4;
            vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
            return sampleTexture(${n}, uv);
          }
        `;return new o.GlslLibRoutine(w,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const c=this.context.outputTextureLayout,n=c.shape.length,e=c.strides,s=c.width,u=c.height,m=[];for(let g=0;g<n-1;++g)m.push(`
        c[${g}] = offset / ${e[g]};`),m.push(`
        offset -= c[${g}] * ${e[g]};`);m.push(`
        c[${n-1}] = offset;`);const b=`
      void toVec(vec2 texCoords, out int c[${n}]) {
        int offset = coordsToOffset(texCoords, ${s}, ${u});
        ${m.join("")}
      }
      void toVec(int offset, out int c[${n}]) {
        ${m.join("")}
      }
    `;return{toVec:new o.GlslLibRoutine(b,["coordinates.coordsToOffset"])}}valueFrom(){const c={};return this.context.programInfo.inputNames.forEach((n,e)=>{const s=this.context.inputTextureLayouts[e],u=(s.unpackedShape.length>0?s.unpackedShape:s.shape).length;let m=`_${n}`;c[m]=new o.GlslLibRoutine(this.getValueFromSingle(n,u,s.width,s.height,!1),[`shapeUtils.indicesToOffset${m}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),m+="_T",c[m]=new o.GlslLibRoutine(this.getValueFromSingle(n,u,s.width,s.height,!0),[`shapeUtils.indicesToOffset${m}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),c}getValueFromSingle(c,n,e,s,u){let m=`_${c}`;return u&&(m+="_T"),`
        float ${m}(int m[${n}]) {
          int offset = indicesToOffset${m}(m);
          vec2 coords = offsetToCoords(offset, ${e}, ${s});
          float value = getColorAsFloat(${(0,l.getGlsl)(this.context.glContext.version).texture2D}(${c}, coords));
          return value;
        }
        `}getPackedValueFrom(c,n,e,s,u){let m=`_${c}_Pack`;return u&&(m+="_T"),`
        vec4 ${m}(int m[${n}]) {
          int offset = indicesToOffset_${c}(m);
          vec2 coords = offsetToCoords(offset, ${e}, ${s});
          return ${(0,l.getGlsl)(this.context.glContext.version).texture2D}(${c}, coords);
        }
        `}}t.CoordsGlslLib=p},8520:(d,t)=>{var i;Object.defineProperty(t,"__esModule",{value:!0}),t.TopologicalSortGlslRoutines=t.GlslLibRoutineNode=t.GlslLibRoutine=t.GlslLib=t.GlslContext=t.FunctionType=void 0,(i=t.FunctionType||(t.FunctionType={}))[i.ValueBased=0]="ValueBased",i[i.Positional=1]="Positional",t.GlslContext=class{constructor(r,o,l,a){this.glContext=r,this.programInfo=o,this.inputTextureLayouts=l,this.outputTextureLayout=a}},t.GlslLib=class{constructor(r){this.context=r}},t.GlslLibRoutine=class{constructor(r,o){this.routineBody=r,this.dependencies=o}},t.GlslLibRoutineNode=class{constructor(r,o,l){this.name=r,this.dependencies=l||[],o&&(this.routineBody=o)}addDependency(r){r&&this.dependencies.push(r)}},t.TopologicalSortGlslRoutines=class{static returnOrderedNodes(r){if(!r||r.length===0)return[];if(r.length===1)return r;const o=new Set,l=new Set,a=new Array;return this.createOrderedNodes(r,o,l,a),a}static createOrderedNodes(r,o,l,a){for(let f=0;f<r.length;++f)this.dfsTraverse(r[f],o,l,a)}static dfsTraverse(r,o,l,a){if(!r||l.has(r.name))return;if(o.has(r.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");o.add(r.name);const f=r.dependencies;if(f&&f.length>0)for(let p=0;p<f.length;++p)this.dfsTraverse(f[p],o,l,a);a.push(r),l.add(r.name),o.delete(r.name)}}},7341:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.EncodingGlslLib=void 0;const r=i(8520);class o extends r.GlslLib{constructor(a){super(a)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new r.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const a=o.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new r.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${a}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const a=o.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new r.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${a}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const a=new ArrayBuffer(4),f=new Uint32Array(a),p=new Uint8Array(a);if(f[0]=3735928559,p[0]===239)return!0;if(p[0]===222)return!1;throw new Error("unknown endianness")}}t.EncodingGlslLib=o},9894:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FragColorGlslLib=void 0;const r=i(8520),o=i(5060);class l extends r.GlslLib{constructor(f){super(f)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const f=(0,o.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`
        void setFragColor(float value) {
            ${f.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}t.FragColorGlslLib=l},2848:(d,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.replaceInlines=void 0;const i=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;t.replaceInlines=function(r){const o={};let l;for(;(l=i.exec(r))!==null;){const a=l[3].split(",").map(f=>{const p=f.trim().split(" ");return p&&p.length===2?{type:p[0],name:p[1]}:null}).filter(f=>f!==null);o[l[2]]={params:a,body:l[4]}}for(const a in o){const f="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",a),p=new RegExp(f,"gm");for(;(l=p.exec(r))!==null;){const h=l[1],c=l[2],n=l[3].split(","),e=h?`${h} ${c};`:"";let s=o[a].body,u="";o[a].params.forEach((b,g)=>{b&&(u+=`${b.type} ${b.name} = ${n[g]};
`)}),s=`${u}
 ${s}`,s=s.replace("return",`${c} = `);const m=`
      ${e}
      {
        ${s}
      }
      `;r=r.replace(l[0],m)}}return r.replace(i,"")}},8879:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.GlslPreprocessor=void 0;const r=i(8520),o=i(2848),l=i(5483),a=i(5060);t.GlslPreprocessor=class{constructor(f,p,h,c){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(f,p,h,c),Object.keys(l.glslRegistry).forEach(e=>{const s=new l.glslRegistry[e](this.context);this.libs[e]=s});const n=this.glslLibRoutineDependencyGraph;for(const e in this.libs){const s=this.libs[e].getFunctions();for(const u in s){const m=e+"."+u;let b;n[m]?(b=n[m],b.routineBody=s[u].routineBody):(b=new r.GlslLibRoutineNode(m,s[u].routineBody),n[m]=b);const g=s[u].dependencies;if(g)for(let _=0;_<g.length;++_)if(n[g[_]])b.addDependency(n[g[_]]);else{const y=new r.GlslLibRoutineNode(g[_]);n[g[_]]=y,b.addDependency(y)}}}}preprocess(){const f=this.context.programInfo;let p=f.shaderSource;return this.context.programInfo.hasMain||(p=`${p}
      ${(0,a.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),p=(0,o.replaceInlines)(p),`${(0,a.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(f.inputNames,f.variables)}
    ${this.getImports(p)}
    ${p}`}getImports(f){const p=this.selectGlslLibRoutinesToBeIncluded(f);if(p.length===0)return"";let h="";for(let c=0;c<p.length;++c){if(!p[c].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${p[c].name}`);h+=p[c].routineBody+`
`}return h}selectGlslLibRoutinesToBeIncluded(f){const p=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(h=>{const c=h.split(".")[1];f.indexOf(c)!==-1&&p.push(this.glslLibRoutineDependencyGraph[h])}),r.TopologicalSortGlslRoutines.returnOrderedNodes(p)}getUniforms(f,p){const h=[];if(f)for(const c of f)h.push(`uniform sampler2D ${c};`);if(p)for(const c of p)h.push(`uniform ${c.type} ${c.name}${c.arrayLength?`[${c.arrayLength}]`:""};`);return h.join(`
`)}}},5483:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.glslRegistry=void 0;const r=i(5107),o=i(7341),l=i(9894),a=i(2655),f=i(3891);t.glslRegistry={encoding:o.EncodingGlslLib,fragcolor:l.FragColorGlslLib,vec:f.VecGlslLib,shapeUtils:a.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},2655:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ShapeUtilsGlslLib=void 0;const r=i(8520);class o extends r.GlslLib{constructor(a){super(a)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const a=this.context.outputTextureLayout.shape.length,f={};return this.context.programInfo.inputNames.forEach((p,h)=>{const c=this.context.inputTextureLayouts[h].unpackedShape;if(c.length<=a){const n=c.length,e=a-n,s=`bcastIndices_${p}`;let u="";for(let b=0;b<n;++b)u+=`
          realIndices[${b}] = int( mod(float(bcastedIndices[${e+b}]), ${c[b]}.0) );
          `;const m=`
        void ${s} (int bcastedIndices[${a}], out int realIndices[${n}]) {
          ${u}
        }
        `;f[s]=new r.GlslLibRoutine(m)}}),f}bcastMatmulIndex(){const a=this.context.outputTextureLayout.shape.length,f={};return this.context.programInfo.inputNames.forEach((p,h)=>{const c=this.context.inputTextureLayouts[h].shape;if(!(c.length<2||c.length>a)){const n=c.length,e=a-n,s=`bcastMatmulIndices_${p}`;let u="";for(let b=0;b<n-2;++b)u+=`
          realIndices[${b}] = int( mod(float(bcastedIndices[${e+b}]), ${c[b]}.0) );
          `;const m=`
        void ${s}(int bcastedIndices[${a}], out int realIndices[${n}]) {
          ${u}
          realIndices[${n-1}] = bcastedIndices[${a-1}];
          realIndices[${n-2}] = bcastedIndices[${a-2}];
        }
        `;f[s]=new r.GlslLibRoutine(m)}}),f}indicesToOffset(){const a={};return this.context.programInfo.inputNames.forEach((f,p)=>{const h=this.context.inputTextureLayouts[p].shape,c=this.context.inputTextureLayouts[p].strides,n=h.length;let e=`indicesToOffset_${f}`;a[e]=new r.GlslLibRoutine(o.indexToOffsetSingle(e,n,c)),e=`indicesToOffset_${f}_T`,a[e]=new r.GlslLibRoutine(o.indexToOffsetSingle(e,n,c.slice().reverse()))}),a}static indexToOffsetSingle(a,f,p){let h="";for(let c=f-1;c>=0;--c)h+=`
        offset += indices[${c}] * ${p[c]};
        `;return`
      int ${a}(int indices[${f}]) {
        int offset = 0;
        ${h}
        return offset;
      }
      `}offsetToIndices(){const a={};return this.context.programInfo.inputNames.forEach((f,p)=>{const h=this.context.inputTextureLayouts[p].shape,c=this.context.inputTextureLayouts[p].strides,n=h.length;let e=`offsetToIndices_${f}`;a[e]=new r.GlslLibRoutine(o.offsetToIndicesSingle(e,n,c)),e=`offsetToIndices_${f}_T`,a[e]=new r.GlslLibRoutine(o.offsetToIndicesSingle(e,n,c.slice().reverse()))}),a}static offsetToIndicesSingle(a,f,p){const h=[];for(let c=0;c<f-1;++c)h.push(`
      indices[${c}] = offset / ${p[c]};`),h.push(`
        offset -= indices[${c}] * ${p[c]};`);return h.push(`
      indices[${f-1}] = offset;`),`
      void ${a}(int offset, out int indices[${f}]) {
        ${h.join("")}
      }
      `}incrementIndices(){const a={};return this.context.programInfo.inputNames.forEach((f,p)=>{const h=this.context.inputTextureLayouts[p].shape,c=h.length,n=`incrementIndices_${f}`;let e="";for(let u=0;u<c;++u)e+=`
        shape[${u}] = ${h[u]};`;const s=`
        void ${n}(int axis, out int indices[${c}]) {
          int shape[${c}];
          ${e};
          for(int i = ${c} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;a[n]=new r.GlslLibRoutine(s)}),a}}t.ShapeUtilsGlslLib=o},5060:(d,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getDefaultFragShaderMain=t.getFragShaderPreamble=t.getVertexShaderSource=t.getGlsl=void 0;const i={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},r={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function o(l){return l===1?i:r}t.getGlsl=o,t.getVertexShaderSource=function(l){const a=o(l);return`${a.version}
      precision highp float;
      ${a.attribute} vec3 position;
      ${a.attribute} vec2 textureCoord;

      ${a.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},t.getFragShaderPreamble=function(l){const a=o(l);return`${a.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${a.varyingFrag} vec2 TexCoords;
    ${a.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},t.getDefaultFragShaderMain=function(l,a){return`
  void main() {
    int indices[${a}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o(l).output} = result;
  }
  `}},3891:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.VecGlslLib=void 0;const r=i(8520);class o extends r.GlslLib{constructor(a){super(a)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const a=this.context.outputTextureLayout.shape.length,f={add:"+=",sub:"-=",mul:"*=",div:"/="},p={};for(const h in f){const c=`${h}Vec`;let n="";for(let s=0;s<a;++s)n+=`
          dest[${s}] ${f[h]} src[${s}];
          `;const e=`
        void ${c}(int src[${a}], out int dest[${a}]) {
          ${n}
        }
        `;p[c]=new r.GlslLibRoutine(e)}return p}copyVec(){const a=this.context.outputTextureLayout.shape.length;let f="";for(let h=0;h<a;++h)f+=`
        dest[${h}] = src[${h}];
        `;const p=`
      void copyVec(int src[${a}], out int dest[${a}]) {
        ${f}
      }
      `;return{copyVec:new r.GlslLibRoutine(p)}}setVecItem(){const a=this.context.outputTextureLayout.shape.length;let f=`
        if(index < 0)
            index =${a} + index;
        if (index == 0)
            m[0] = value;
        `;for(let h=1;h<a-1;++h)f+=`
        else if (index == ${h})
            m[${h}] = value;
            `;f+=`
        else
            m[${a-1}] = value;
        `;const p=`
      void setVecItem(out int m[${a}], int index, int value) {
        ${f}
      }
        `;return{setVecItem:new r.GlslLibRoutine(p)}}getVecItem(){const a=this.context.outputTextureLayout.shape.length;let f=`
        if(index < 0)
            index = ${a} + index;
        if (index == 0)
            return m[0];
      `;for(let h=1;h<a-1;++h)f+=`
        else if (index == ${h})
            return m[${h}];
      `;f+=`
        else
            return m[${a-1}];
        `;const p=`
      int getVecItem(int m[${a}], int index) {
        ${f}
      }
    `;return{getVecItem:new r.GlslLibRoutine(p)}}}t.VecGlslLib=o},8316:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLInferenceHandler=void 0;const r=i(6231),o=i(9162),l=i(2517),a=i(2403),f=i(7019),p=i(8710),h=i(5611),c=i(4057),n=i(2039);t.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,s){return(0,c.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,s)}executeProgram(e,s){if(s.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");const u=[];for(let v=0;v<e.inputNames.length;++v)u[v]=this.getOrCreateTextureData(s[v],e.inputTypes[v]);const m=((v,w)=>{const M=w.map(O=>`${O.unpackedShape.join(",")};${O.width}x${O.height}`).join("_");let S=v.name;return v.cacheHint&&(S+="["+v.cacheHint+"]"),S+=":"+M,S})(e,u);let b=this.session.programManager.getArtifact(m);const g=b?b.programInfo:typeof e.get=="function"?e.get():e,_=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,g.output.dims,g.output.textureType),y=this.createTextureData(_,g.output.type);return b||(b=this.session.programManager.build(g,u,y),this.session.programManager.setArtifact(m,b)),this.runProgram(b,u,y),y}run(e,s){return this.executeProgram(e,s).tensor}runProgram(e,s,u){for(let m=0;m<s.length;++m)if(!!s[m].isPacked!=(e.programInfo.inputTypes[m]===n.TextureType.packed))throw new Error(`input[${m}] property packed inconsistent`);if(!!u.isPacked!=(e.programInfo.output.textureType===n.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,s,u)}getOrCreateTextureData(e,s){let u=this.getTextureData(e.dataId,s===n.TextureType.packed);if(!u&&(u=this.getTextureData(e.dataId,s!==n.TextureType.packed),u))return s===n.TextureType.packed?this.pack(u):this.unpack(u);if(!u){const m=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,s);if(s===n.TextureType.packedLastDimension){const _=e.dims;if(_.length===4){const y=[_[0],Math.ceil(_[1]*_[2]*_[3]/4)],v=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,y,s);let w=e.numberData;if(_[1]*_[2]*_[3]%4!=0){const M=_[0],S=_[1]*_[2]*_[3],O=Math.ceil(S*1/4)*4;w=new Float32Array(M*O);for(let x=0;x<M;++x){const T=x*S,I=x*O+x%1*S;w.set(e.numberData.subarray(T,T+S),I)}}return this.createTextureData(v,e.type,w,e,1)}}if(s===n.TextureType.packed){const b=(0,c.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),g=this.createTextureData(b,e.type,e.numberData,e,1);u=this.pack(g)}else u=this.createTextureData(m,e.type,e.numberData,e,1)}return u}createTextureDataFromLayoutBindTensor(e,s,u,m){return this.createTextureData(e,s,u,m,1)}createTextureData(e,s,u,m,b){r.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);const g=this.session.textureManager.createTextureFromLayout(s,e,u,b);return this.createTextureDataFromTexture(e,s,g,m)}reshapeUnpacked(e,s){const u=this.getOrCreateTextureData(e,n.TextureType.unpacked),m={channels:u.channels,height:u.height,width:u.width,shape:s.length!==0?s:[1],strides:l.ShapeUtil.computeStrides(s),unpackedShape:s};return this.createTextureDataFromTexture(m,e.type,u.texture).tensor}reshapePacked(e,s){const u=this.getOrCreateTextureData(e,n.TextureType.packed);if((0,f.isReshapeCheap)(e.dims,s)){const y={channels:u.channels,height:u.height,width:u.width,shape:s.length!==0?s:[1],strides:l.ShapeUtil.computeStrides(s),unpackedShape:s,isPacked:!0};return this.createTextureDataFromTexture(y,e.type,u.texture).tensor}const m=(0,f.processDims3D)(e.dims),b=(0,f.processDims3D)(s),g=this.reshapePacked(e,m),_=this.run((0,f.createPackedReshape3DProgramInfoLoader)(this,g,b),[g]);return this.reshapePacked(_,s)}cast(e,s){const u=this.getOrCreateTextureData(e,n.TextureType.unpacked);return this.createTextureDataFromTexture(u,s,u.texture).tensor}createTextureDataFromTexture(e,s,u,m,b){const g=Object.assign(Object.assign({},e),{tensor:m||new o.Tensor(e.unpackedShape,s,_=>this.readTexture(g),async _=>this.readTextureAsync(g),void 0,b),texture:u});return this.setTextureData(g.tensor.dataId,g,e.isPacked),g}getTextureData(e,s=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,s):s?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,s,u=!1){this.session.isInitializer(e)?this.session.setTextureData(e,s,u):(u?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,s)}isTextureLayoutCached(e,s=!1){return!!this.getTextureData(e.dataId,s)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,p.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,p.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,a.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,h.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},1640:function(d,t,i){var r=this&&this.__createBinding||(Object.create?function(U,K,Q,se){se===void 0&&(se=Q);var te=Object.getOwnPropertyDescriptor(K,Q);te&&!("get"in te?!K.__esModule:te.writable||te.configurable)||(te={enumerable:!0,get:function(){return K[Q]}}),Object.defineProperty(U,se,te)}:function(U,K,Q,se){se===void 0&&(se=Q),U[se]=K[Q]}),o=this&&this.__setModuleDefault||(Object.create?function(U,K){Object.defineProperty(U,"default",{enumerable:!0,value:K})}:function(U,K){U.default=K}),l=this&&this.__importStar||function(U){if(U&&U.__esModule)return U;var K={};if(U!=null)for(var Q in U)Q!=="default"&&Object.prototype.hasOwnProperty.call(U,Q)&&r(K,U,Q);return o(K,U),K};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGL_OP_RESOLVE_RULES=void 0;const a=i(2898),f=l(i(7839)),p=i(4196),h=i(2069),c=i(8138),n=i(9663),e=i(5193),s=i(7992),u=i(1253),m=i(4776),b=i(6572),g=i(3346),_=i(5623),y=i(2870),v=i(2143),w=i(4939),M=i(718),S=i(2268),O=i(8117),x=i(2278),T=i(5524),I=i(5975),F=i(3933),C=i(6558),N=i(5723),B=i(3738),k=l(i(4909)),R=i(8428),X=i(9793);t.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",k.abs],["Acos","","7+",k.acos],["Add","","7+",f.add],["And","","7+",f.and],["Asin","","7+",k.asin],["Atan","","7+",k.atan],["AveragePool","","7+",v.averagePool,v.parseAveragePoolAttributes],["BatchNormalization","","7+",a.batchNormalization,a.parseBatchNormalizationAttributes],["Cast","","6+",p.cast,p.parseCastAttributes],["Ceil","","6+",k.ceil],["Clip","","6-10",k.clip,k.parseClipAttributes],["Clip","","11+",k.clipV11],["Concat","","4+",h.concat,h.parseConcatAttributes],["Conv","","1+",c.conv,c.parseConvAttributes],["ConvTranspose","","1+",n.convTranspose,n.parseConvTransposeAttributes],["Cos","","7+",k.cos],["Div","","7+",f.div],["Dropout","","7+",k.identity],["DepthToSpace","","1+",e.depthToSpace,e.parseDepthToSpaceAttributes],["Equal","","7+",f.equal],["Elu","","6+",k.elu,k.parseEluAttributes],["Exp","","6+",k.exp],["Flatten","","1+",s.flatten,s.parseFlattenAttributes],["Floor","","6+",k.floor],["FusedConv","com.microsoft","1+",c.conv,c.parseConvAttributes],["Gather","","1+",u.gather,u.parseGatherAttributes],["Gemm","","7-10",m.gemm,m.parseGemmAttributesV7],["Gemm","","11+",m.gemm,m.parseGemmAttributesV11],["GlobalAveragePool","","1+",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",v.globalMaxPool],["Greater","","7+",f.greater],["Identity","","1+",k.identity],["ImageScaler","","1+",b.imageScaler,b.parseImageScalerAttributes],["InstanceNormalization","","6+",g.instanceNormalization,g.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",k.leakyRelu,k.parseLeakyReluAttributes],["Less","","7+",f.less],["Log","","6+",k.log],["MatMul","","1+",_.matMul,_.parseMatMulAttributes],["MaxPool","","1+",v.maxPool,v.parseMaxPoolAttributes],["Mul","","7+",f.mul],["Neg","","6+",k.neg],["Not","","1+",k.not],["Or","","7+",f.or],["Pad","","2-10",y.padV2,y.parsePadAttributesV2],["Pad","","11+",y.padV11,y.parsePadAttributesV11],["Pow","","7+",f.pow],["PRelu","","7+",f.pRelu],["ReduceLogSum","","1+",w.reduceLogSum,w.parseReduceAttributes],["ReduceMax","","1+",w.reduceMax,w.parseReduceAttributes],["ReduceMean","","1+",w.reduceMean,w.parseReduceAttributes],["ReduceMin","","1+",w.reduceMin,w.parseReduceAttributes],["ReduceProd","","1+",w.reduceProd,w.parseReduceAttributes],["ReduceSum","","1-12",w.reduceSum,w.parseReduceAttributes],["ReduceSumSquare","","1+",w.reduceLogSumSquare,w.parseReduceAttributes],["Relu","","6+",k.relu],["Reshape","","5+",M.reshape],["Resize","","10",S.resize,S.parseResizeAttributesV10],["Resize","","11+",S.resize,S.parseResizeAttributesV11],["Shape","","1+",O.shape],["Sigmoid","","6+",k.sigmoid],["Sin","","7+",k.sin],["Slice","","10+",x.sliceV10],["Slice","","1-9",x.slice,x.parseSliceAttributes],["Softmax","","1-12",T.softmax,T.parseSoftmaxAttributes],["Softmax","","13+",T.softmaxV13,T.parseSoftmaxAttributesV13],["Split","","2-12",I.split,I.parseSplitAttributes],["Sqrt","","6+",k.sqrt],["Squeeze","","1-12",F.squeeze,F.parseSqueezeAttributes],["Squeeze","","13+",F.squeezeV13],["Sub","","7+",f.sub],["Sum","","6+",C.sum],["Tan","","7+",k.tan],["Tanh","","6+",k.tanh],["Tile","","6+",N.tile],["Transpose","","1+",B.transpose,B.parseTransposeAttributes],["Upsample","","7-8",X.upsample,X.parseUpsampleAttributesV7],["Upsample","","9",X.upsample,X.parseUpsampleAttributesV9],["Unsqueeze","","1-12",R.unsqueeze,R.parseUnsqueezeAttributes],["Unsqueeze","","13+",R.unsqueezeV13],["Xor","","7+",f.xor]]},2898:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseBatchNormalizationAttributes=t.batchNormalization=void 0;const r=i(246),o=i(5060),l=i(2039),a={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]};t.batchNormalization=(h,c,n)=>(p(c),[h.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>f(h,c,n)}),c)]),t.parseBatchNormalizationAttributes=h=>{const c=h.attributes.getFloat("epsilon",1e-5),n=h.attributes.getFloat("momentum",.9),e=h.attributes.getInt("spatial",1);return(0,r.createAttributeWithCacheKey)({epsilon:c,momentum:n,spatial:e})};const f=(h,c,n)=>{const e=(0,o.getGlsl)(h.session.backend.glContext.version),s=c[0].dims.length,[u,m]=h.calculateTextureWidthAndHeight(c[1].dims,l.TextureType.unpacked),b=`
  float process(int[${s}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u}, ${m});
    float scale = getColorAsFloat(${e.texture2D}(Scale, position));
    float mean = getColorAsFloat(${e.texture2D}(Mean, position));
    float variance = getColorAsFloat(${e.texture2D}(Variance, position));
    float b = getColorAsFloat(${e.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},a),{output:{dims:c[0].dims,type:c[0].type,textureType:l.TextureType.unpacked},shaderSource:b})},p=h=>{if(!h||h.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const c=h[0],n=h[1],e=h[2],s=h[3],u=h[4];if(c.dims.length<3||n.dims.length!==1||e.dims.length!==1||s.dims.length!==1||u.dims.length!==1)throw new Error("invalid input shape.");if(n.dims[0]!==c.dims[1]||e.dims[0]!==c.dims[1]||s.dims[0]!==c.dims[1]||u.dims[0]!==c.dims[1])throw new Error("invalid input shape.");if(c.type!=="float32"&&c.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||u.type!=="float32"&&u.type!=="float64")throw new Error("invalid input tensor types.")}},7839:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.xor=t.sub=t.pRelu=t.pow=t.or=t.mul=t.less=t.greater=t.equal=t.div=t.and=t.add=t.glslPRelu=t.glslPow=t.glslXor=t.glslOr=t.glslAnd=t.glslLess=t.glslGreater=t.glslEqual=t.glslSub=t.glslMul=t.glslDiv=t.glslAdd=void 0;const r=i(2517),o=i(8520),l=i(5060),a=i(2039);function f(){const w="add_";return{body:`
  float ${w}(float a, float b) {
    return a + b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:w,type:o.FunctionType.ValueBased}}function p(){const w="div_";return{body:`
  float ${w}(float a, float b) {
    return a / b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:w,type:o.FunctionType.ValueBased}}function h(){const w="mul_";return{body:`
  float ${w}(float a, float b) {
    return a * b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:w,type:o.FunctionType.ValueBased}}function c(){const w="sub_";return{body:`
  float ${w}(float a, float b) {
    return a - b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:w,type:o.FunctionType.ValueBased}}function n(){const w="equal_";return{body:`
  float ${w}(float a, float b) {
    return float(a == b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:w,type:o.FunctionType.ValueBased}}function e(){const w="greater_";return{body:`
  float ${w}(float a, float b) {
    return float(a > b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:w,type:o.FunctionType.ValueBased}}function s(){const w="less_";return{body:`
  float ${w}(float a, float b) {
    return float(a < b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:w,type:o.FunctionType.ValueBased}}function u(){const w="and_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:w,type:o.FunctionType.ValueBased}}function m(){const w="or_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:w,type:o.FunctionType.ValueBased}}function b(){const w="xor_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:w,type:o.FunctionType.ValueBased}}function g(){return function(w){const M=`${w}_`;return{body:`
  float ${M}(float a, float b) {
    return ${w}(a, b);
  }
  vec4 ${M}(vec4 v1, vec4 v2) {
    return ${w}(v1, v2);
  }
  `,name:M,type:o.FunctionType.ValueBased}}("pow")}function _(){const w="prelu_";return{body:`
  float ${w}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:w,type:o.FunctionType.ValueBased}}t.glslAdd=f,t.glslDiv=p,t.glslMul=h,t.glslSub=c,t.glslEqual=n,t.glslGreater=e,t.glslLess=s,t.glslAnd=u,t.glslOr=m,t.glslXor=b,t.glslPow=g,t.glslPRelu=_;const y=(w,M,S,O=M[0].type,x)=>{const T=w.session.pack?a.TextureType.packed:a.TextureType.unpacked;return{name:S.name,inputNames:["A","B"],inputTypes:[T,T],cacheHint:x,get:()=>v(w,M,S,O)}},v=(w,M,S,O=M[0].type)=>{const x=w.session.pack?a.TextureType.packed:a.TextureType.unpacked,T=!r.ShapeUtil.areEqual(M[0].dims,M[1].dims);let I=M[0].dims;const F=w.session.pack;if(T){const B=r.BroadcastUtil.calcShape(M[0].dims,M[1].dims,!1);if(!B)throw new Error("Can't perform binary op on the given tensors");I=B;const k=I.length,R=M[0].dims.length!==0?M[0].dims.length:1,X=M[1].dims.length!==0?M[1].dims.length:1,U=M[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",K=M[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",Q=(0,l.getGlsl)(w.session.backend.glContext.version),se=F?`
      ${S.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${S.name}(a, b);
        ${Q.output} = result;
      }`:`
      ${S.body}
      float process(int indices[${k}]) {
        int aindices[${R}];
        int bindices[${X}];
        ${U}
        ${K}
        return ${S.name}(_A(aindices), _B(bindices));
      }`;return{name:S.name,inputNames:["A","B"],inputTypes:[x,x],output:{dims:I,type:O,textureType:x},shaderSource:se,hasMain:F}}const C=(0,l.getGlsl)(w.session.backend.glContext.version),N=`
    ${S.body}
    void main() {
      vec4 v1 = ${C.texture2D}(A, TexCoords);
      vec4 v2 = ${C.texture2D}(B, TexCoords);
      vec4 result = ${S.name}(v1, v2);
      ${C.output} = result;
    }
    `;return{name:S.name,inputNames:["A","B"],inputTypes:[x,x],output:{dims:M[0].dims,type:O,textureType:x},shaderSource:N,hasMain:!0}};t.add=(w,M)=>[w.run(y(w,M,f()),M)],t.and=(w,M)=>[w.run(y(w,M,u(),"bool"),M)],t.div=(w,M)=>[w.run(y(w,M,p()),M)],t.equal=(w,M)=>[w.run(y(w,M,n(),"bool"),M)],t.greater=(w,M)=>[w.run(y(w,M,e(),"bool"),M)],t.less=(w,M)=>[w.run(y(w,M,s(),"bool"),M)],t.mul=(w,M)=>[w.run(y(w,M,h()),M)],t.or=(w,M)=>[w.run(y(w,M,m(),"bool"),M)],t.pow=(w,M)=>[w.run(y(w,M,g()),M)],t.pRelu=(w,M)=>[w.run(y(w,M,_()),M)],t.sub=(w,M)=>[w.run(y(w,M,c()),M)],t.xor=(w,M)=>[w.run(y(w,M,b(),"bool"),M)]},4196:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCastAttributes=t.cast=void 0;const r=i(2517);t.cast=(l,a,f)=>(o(a),[l.cast(a[0],f)]),t.parseCastAttributes=l=>r.ProtoUtil.tensorDataTypeFromProto(l.attributes.getInt("to"));const o=l=>{if(!l||l.length!==1)throw new Error("Cast requires 1 input.");if(l[0].type==="string")throw new Error("Invalid input type.")}},1163:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedConcatProgramInfoLoader=void 0;const r=i(5060),o=i(2039),l=i(9390),a=i(2827);t.createPackedConcatProgramInfoLoader=(p,h,c)=>{const n=(e=h.length,s=c.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:e},(u,m)=>`X${m}`),inputTypes:Array(e).fill(o.TextureType.packed),cacheHint:s});var e,s;return Object.assign(Object.assign({},n),{get:()=>((u,m,b,g)=>{const _=b[0].dims.slice();if(g>=_.length||g<-1*_.length)throw new Error("axis specified for concat doesn't match input dimensionality");g<0&&(g=_.length+g);const y=_.slice(0);for(let U=1;U<b.length;U++){const K=b[U].dims.slice();for(let Q=0;Q<_.length;Q++)if(Q===g)y[g]+=K[Q];else if(_[Q]!==K[Q])throw new Error("non concat dimensions must match")}const v=y.length,w=(0,a.getChannels)("coords",v),M=(0,l.getCoordsDataType)(v),S=(0,a.unpackFromChannel)(),O=b.map(U=>U.dims),x=(0,l.getGlChannels)(v),T=new Array(O.length-1);T[0]=O[0][g];for(let U=1;U<T.length;U++)T[U]=T[U-1]+O[U][g];const I=x[g],F=x.slice(-2),C=x.join();let N=`if (${I} < ${T[0]}) {
        return getChannel(
            getX0(${C}), vec2(${F.join()}));
        }`;for(let U=1;U<T.length;U++){const K=T[U-1];N+=`
            if (${I} < ${T[U]}  && ${I} >= ${T[U-1]}) {
              return getChannel(
                getX${U}(${f(x,I,K)}),
                vec2(${f(F,I,K)}));
            }`}const B=T.length,k=T[T.length-1];N+=`
            return getChannel(
              getX${B}(${f(x,I,k)}),
              vec2(${f(F,I,k)}));`;const R=(0,r.getGlsl)(u.session.backend.glContext.version),X=`
          ${S}
          float getValue(${x.map(U=>"int "+U)}) {
            ${N}
          }

          void main() {
            ${M} coords = getOutputCoords();
            int lastDim = coords.${x[v-1]};
            coords.${x[v-1]} = coords.${x[v-2]};
            coords.${x[v-2]} = lastDim;

            vec4 result = vec4(getValue(${w}), 0., 0., 0.);

            ${w[v-1]} = ${w[v-1]} + 1;
            if (${w[v-1]} < ${y[v-1]}) {
              result.g = getValue(${w});
            }

            ${w[v-2]} = ${w[v-2]} + 1;
            if (${w[v-2]} < ${y[v-2]}) {
              result.a = getValue(${w});
            }

            ${w[v-1]} = ${w[v-1]} - 1;
            if (${w[v-2]} < ${y[v-2]} &&
                ${w[v-1]} < ${y[v-1]}) {
              result.b = getValue(${w});
            }
            ${R.output} = result;
          }
        `;return Object.assign(Object.assign({},m),{output:{dims:y,type:b[0].type,textureType:o.TextureType.packed},shaderSource:X,hasMain:!0})})(p,n,h,c.axis)})};const f=(p,h,c)=>{const n=p.indexOf(h);return p.map((e,s)=>s===n?`${e} - ${c}`:e).join()}},2069:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const r=i(246),o=i(2039),l=i(1163);t.concat=(e,s,u)=>(n(s),e.session.pack&&s[0].dims.length>1?[e.run((0,l.createPackedConcatProgramInfoLoader)(e,s,u),s)]:[e.run(a(e,s,u),s)]);const a=(e,s,u)=>{const m=(b=s.length,g=u.cacheKey,{name:"Concat",inputNames:Array.from({length:b},(_,y)=>`X${y}`),inputTypes:Array(b).fill(o.TextureType.unpacked),cacheHint:g});var b,g;return Object.assign(Object.assign({},m),{get:()=>((_,y,v,w)=>{const M=v[0].dims.slice();if(w>=M.length||w<-1*M.length)throw new Error("axis specified for concat doesn't match input dimensionality");w<0&&(w=M.length+w);const S=M.slice(0);for(let C=1;C<v.length;C++){const N=v[C].dims.slice();for(let B=0;B<M.length;B++)if(B===w)S[w]+=N[B];else if(M[B]!==N[B])throw new Error("non concat dimensions must match")}const O=S.length,x=new Array(v.length);let T=0;for(let C=0;C<x.length;++C)T+=v[C].dims[w],x[C]=T;let I="";I=v.length<5?f(x):p(x);const F=`
        ${h(v.length,O)}
        ${c(x)}
        ${I}
        float process(int indices[${O}]) {
          int textureIndex = getTextureWhereDataResides (indices[${w}]);

          if(textureIndex != 0) {
            indices[${w}] = indices[${w}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},y),{output:{dims:S,type:v[0].type,textureType:o.TextureType.unpacked},shaderSource:F})})(0,m,s,u.axis)})},f=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((s,u)=>`if(index<${s}) {return ${u};}
`).join("")}
    }`,p=e=>f(e),h=(e,s)=>{const u=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${s}]) {`];for(let m=0;m<e;++m)m===0?u.push(`	if (textureIndex == ${m}) { return _X${m}(indices); }`):m===e-1?u.push(`	else { return _X${m}(indices); }`):u.push(`	else if (textureIndex == ${m}) { return _X${m}(indices); }`);return u.push("	}"),u.join(`
`)},c=e=>{const s=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let u=0;u<e.length;++u)u===0?s.push(`	if (index == ${u}) { return ${e[u]}; }`):u===e.length-1?s.push(`	else { return ${e[u]}; }`):s.push(`	else if (index == ${u}) { return ${e[u]}; }`);return s.push("	}"),s.join(`
`)};t.parseConcatAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});const n=e=>{if(!e||e.length<1)throw new Error("too few inputs");const s=e[0].type,u=e[0].dims.length;if(s==="string")throw new Error("string tensor is not supported yet");for(const m of e){if(m.type!==s)throw new Error("input tensors should be one type");if(m.dims.length!==u)throw new Error("input tensors should have the same shape")}}},4770:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=i(6231),o=i(5060),l=i(2039),a=i(8138),f=i(2823);t.createUnpackedGroupedConvProgramInfoLoader=(p,h,c)=>{const n=(e=h.length>2,s=c.cacheKey,{name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]:[l.TextureType.unpacked,l.TextureType.unpacked],cacheHint:s});var e,s;return Object.assign(Object.assign({},n),{get:()=>((u,m,b,g)=>{const _=m.length>2?"value += getBias(output_channel);":"",y=m[0].dims.slice(),v=m[1].dims.slice(),w=v[0]/g.group;r.Logger.verbose("GroupedConv",`autpPad:${g.autoPad}, dilations:${g.dilations}, group:${g.group}, kernelShape:${g.kernelShape}, pads:${g.pads}, strides:${g.strides}`);const M=(0,a.calculateOutputShape)(y,v,g.dilations,g.pads,g.strides),S=(0,o.getGlsl)(u.session.backend.glContext.version),{activationFunction:O,applyActivation:x}=(0,f.getActivationSnippet)(g),T=`
  const ivec2 strides = ivec2(${g.strides[0]}, ${g.strides[1]});
  const ivec2 pads = ivec2(${g.pads[0]}, ${g.pads[1]});
  ${O}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${w};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${v[1]}; wInChannel++) {
      int input_channel = group_id * ${v[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${v[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${g.dilations[0]};

        if (xHeight < 0 || xHeight >= ${y[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${v[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${g.dilations[1]};
          if (xWidth < 0 || xWidth >= ${y[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${_}
    ${x}
    ${S.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},b),{output:{dims:M,type:m[0].type,textureType:l.TextureType.unpacked},shaderSource:T,hasMain:!0})})(p,h,n,c)})}},1386:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.conv2DPacked=t.conv2DPackedPointwise=void 0;const r=i(8138),o=i(8555),l=i(708);t.conv2DPackedPointwise=(a,f,p)=>{const h=f[0].dims,c=f[1].dims,n=(0,r.calculateOutputShape)(h,c,p.dilations,p.pads,p.strides),e=a.reshapePacked(f[0],[h[1],h[2]*h[3]]),s=a.reshapePacked(f[1],[c[0],c[1]]),u=f.length>2?[s,e,f[2]]:[s,e],m=a.run((0,l.createPackedMatmulProgramInfoLoader)(a,u,p),u);return a.reshapePacked(m,n)},t.conv2DPacked=(a,f,p)=>{const h=f[0].dims,c=f[1].dims,n=(0,r.calculateOutputShape)(h,c,p.dilations,p.pads,p.strides),e=a.run((0,o.createPackedIm2ColProgramInfoLoader)(a,f[0],f[1],n,p),[f[0]]),s=a.reshapePacked(f[1],[c[0],c[1]*c[2]*c[3]]),u=f.length===3?[s,e,f[2]]:[s,e],m=a.run((0,l.createPackedMatmulProgramInfoLoader)(a,u,p),u);return a.reshapePacked(m,n)}},9663:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvTransposeAttributes=t.convTranspose=void 0;const r=i(246),o=i(5060),l=i(2039),a=i(2823),f=(s,u,m,b,g,_)=>(s-1)*u+m+(b-1)*g+1-_,p=(s,u,m,b,g)=>{const _=Math.floor(s/2);u==="SAME_UPPER"?(m[b]=_,m[g]=s-_):u==="SAME_LOWER"&&(m[b]=s-_,m[g]=_)};t.convTranspose=(s,u,m)=>(e(u,m),h(s,u,m));const h=(s,u,m)=>{const b=n(m,u);return[c(s,u,b)]},c=(s,u,m)=>s.run(((b,g,_)=>{const y=(v=g.length>2,w=_.cacheKey,{name:"ConvTranspose",inputNames:v?["X","W","B"]:["X","W"],inputTypes:v?[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]:[l.TextureType.unpacked,l.TextureType.unpacked],cacheHint:w});var v,w;return Object.assign(Object.assign({},y),{get:()=>((M,S,O,x)=>{const T=S.length>2?"getB(output_channel)":"0.0",I=S[0].dims,F=S[1].dims,C=F[1],N=F[0]/x.group,B=[S[0].dims[0],S[1].dims[1]*x.group,...x.outputShape],k=(0,o.getGlsl)(M.session.backend.glContext.version),{activationFunction:R,applyActivation:X}=(0,a.getActivationSnippet)(x),U=`
  const ivec2 strides = ivec2(${x.strides[0]}, ${x.strides[1]});
  const ivec2 pads = ivec2(${x.pads[0]}, ${x.pads[1]});
  ${R}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${C};
    int wOutChannel = output_channel - group_id * ${C};

    float value = ${T};
    for (int inChannelOffset = 0; inChannelOffset < ${N}; inChannelOffset++) {
      int input_channel = group_id * ${N} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${F[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${F[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${x.dilations[0]}, wHOff * ${x.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${I[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${I[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${X}
    ${k.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},O),{output:{dims:B,type:S[0].type,textureType:l.TextureType.unpacked},shaderSource:U,hasMain:!0})})(b,g,y,_)})})(s,u,m),u),n=(s,u)=>{const m=s.kernelShape.slice();if(s.kernelShape.length===0)for(let y=2;y<u[1].dims.length;++y)m.push(u[1].dims[y]);const b=s.pads.slice(),g=s.outputShape.slice();((y,v,w,M,S,O,x,T)=>{const I=y.length-2,F=T.length===0;for(let C=0;C<I;++C){const N=F?y[C+2]*O[C]:T[C],B=f(y[C+2],O[C],S[C],v[C],w[C],N);p(B,M,S,C,C+I),F&&T.push(O[C]*(y[C+2]-1)+x[C]+(v[C]-1)*w[C]+1-S[C]-S[C+I])}})(u[0].dims,m,s.dilations,s.autoPad,b,s.strides,s.outputPadding,g);const _=Object.assign({},s);return Object.assign(_,{kernelShape:m,pads:b,outputShape:g,cacheKey:s.cacheKey}),_};t.parseConvTransposeAttributes=s=>{const u=s.attributes,m=(0,a.parseInternalActivationAttributes)(u),b=u.getString("auto_pad","NOTSET"),g=u.getInts("dilations",[1,1]),_=u.getInt("group",1),y=u.getInts("kernel_shape",[]),v=u.getInts("output_padding",[0,0]),w=u.getInts("output_shape",[]),M=u.getInts("pads",[0,0,0,0]),S=u.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:b,dilations:g,group:_,kernelShape:y,outputPadding:v,outputShape:w,pads:M,strides:S},m))};const e=(s,u)=>{if(!s||s.length!==2&&s.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(s[0].dims.length!==4||s[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(s[0].dims[1]!==s[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const m=s[1].dims[1]*u.group;if(s.length===3&&(s[2].dims.length!==1||s[2].dims[0]!==m))throw new Error("invalid bias");const b=s[0].dims.length-2;if(u.dilations.length!==b)throw new Error(`dilations should be ${b}D`);if(u.strides.length!==b)throw new Error(`strides should be ${b}D`);if(u.pads.length!==2*b)throw new Error(`pads should be ${2*b}D`);if(u.outputPadding.length!==b)throw new Error(`output_padding should be ${b}D`);if(u.kernelShape.length!==0&&u.kernelShape.length!==s[1].dims.length-2)throw new Error("invalid kernel shape");if(u.outputShape.length!==0&&u.outputShape.length!==s[0].dims.length-2)throw new Error("invalid output shape");if(s[0].type!=="float32"||s[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(s.length===3&&s[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvAttributes=t.conv=t.calculateOutputShape=void 0;const r=i(246),o=i(2517),l=i(4770),a=i(1386),f=i(9828),p=i(2823),h=i(3248),c=i(5623);t.calculateOutputShape=(b,g,_,y,v)=>{const w=b[0],M=b.slice(2),S=M.length,O=g[0],x=g.slice(2).map((I,F)=>I+(I-1)*(_[F]-1)),T=M.map((I,F)=>I+y[F]+y[F+S]).map((I,F)=>Math.floor((I-x[F]+v[F])/v[F]));return[w,O].concat(...T)},t.conv=(b,g,_)=>(m(g,_),n(b,g,_));const n=(b,g,_)=>{const y=u(_,g),v=b.session.pack,w=y.kernelShape[0]===1&&y.kernelShape[1]===1;return y.group>1?[b.run((0,l.createUnpackedGroupedConvProgramInfoLoader)(b,g,y),g)]:w&&v?[e(b,g,y)]:v&&g[0].dims.length===4&&g[0].dims[0]===1&&!w?[(0,a.conv2DPacked)(b,g,y)]:[s(b,g,y)]},e=(b,g,_)=>{const y=g[0].dims,v=g[1].dims,w=(0,t.calculateOutputShape)(y,v,_.dilations,_.pads,_.strides),M=b.reshapeUnpacked(g[0],[y[1],y[2]*y[3]]),S=b.reshapeUnpacked(g[1],[v[0],v[1]]),O=g.length>2?[S,M,g[2]]:[S,M],x=b.run((0,c.createMatmulProgramInfoLoader)(O,_),O);return b.reshapeUnpacked(x,w)},s=(b,g,_)=>{const y=g[0].dims,v=g[1].dims,w=(0,t.calculateOutputShape)(y,v,_.dilations,_.pads,_.strides),M=b.run((0,h.createIm2ColProgramInfoLoader)(b,g[0],g[1],w,_),[g[0]]),S=g.length===3?[M,g[1],g[2]]:[M,g[1]];return b.run((0,f.createDotProductProgramInfoLoader)(b,g,w,_),S)},u=(b,g)=>{const _=b.kernelShape.slice();if(b.kernelShape.length===0)for(let w=2;w<g[1].dims.length;++w)_.push(g[1].dims[w]);const y=b.pads.slice();o.PoolConvUtil.adjustPadsBasedOnAutoPad(g[0].dims,b.strides,b.dilations,_,y,b.autoPad);const v=Object.assign({},b);return Object.assign(v,{kernelShape:_,pads:y,cacheKey:b.cacheKey}),v};t.parseConvAttributes=b=>{const g=b.attributes,_=(0,p.parseInternalActivationAttributes)(g),y=g.getString("auto_pad","NOTSET"),v=g.getInts("dilations",[1,1]),w=g.getInt("group",1),M=g.getInts("kernel_shape",[]),S=g.getInts("pads",[0,0,0,0]),O=g.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:y,dilations:v,group:w,kernelShape:M,pads:S,strides:O},_))};const m=(b,g)=>{if(!b||b.length!==2&&b.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(b[0].dims.length!==4||b[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(b[0].dims[1]!==b[1].dims[1]*g.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(b.length===3&&(b[2].dims.length!==1||b[1].dims[0]!==b[2].dims[0]))throw new Error("invalid bias");const _=b[0].dims.length-2;if(g.dilations.length!==_)throw new Error(`dilations should be ${_}D`);if(g.strides.length!==_)throw new Error(`strides should be ${_}D`);if(g.pads.length!==2*_)throw new Error(`pads should be ${2*_}D`);if(g.kernelShape.length!==0&&g.kernelShape.length!==b[1].dims.length-2)throw new Error("invalid kernel shape");if(b[0].type!=="float32"||b[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(b.length===3&&b[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},5193:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseDepthToSpaceAttributes=t.depthToSpace=void 0;const r=i(3738);t.depthToSpace=(l,a,f)=>{o(a);const p=f.blocksize,h=p*p,c=f.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],n=f.mode==="DCR"?[a[0].dims[0],p,p,a[0].dims[1]/h,a[0].dims[2],a[0].dims[3]]:[a[0].dims[0],a[0].dims[1]/h,p,p,a[0].dims[2],a[0].dims[3]],e=l.reshapeUnpacked(a[0],n),s={perm:c,cacheKey:`${c}`},[u]=(0,r.transpose)(l,[e],s),m=[a[0].dims[0],a[0].dims[1]/h,a[0].dims[2]*p,a[0].dims[3]*p];return[l.reshapeUnpacked(u,m)]},t.parseDepthToSpaceAttributes=l=>{const a=l.attributes.getInt("blocksize");if(a<1)throw new Error(`blocksize must be >= 1, but got : ${a} for DepthToSpace`);const f=l.attributes.getString("mode","DCR");if(f!=="DCR"&&f!=="CRD")throw new Error(`unrecognized mode: ${f} for DepthToSpace`);return{mode:f,blocksize:a}};const o=l=>{if(l.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${l.length}`);if(l[0].type==="string"||l[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createDotProductProgramInfoLoader=void 0;const r=i(2517),o=i(5060),l=i(2039),a=i(2823),f=i(3248);t.createDotProductProgramInfoLoader=(p,h,c,n)=>{const e=((s,u)=>({name:"ConvDotProduct",inputNames:s?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:s?[l.TextureType.unpacked,l.TextureType.packedLastDimension,l.TextureType.unpacked]:[l.TextureType.unpacked,l.TextureType.packedLastDimension],cacheKey:u.activationCacheKey}))(h.length>2,n);return Object.assign(Object.assign({},e),{get:()=>((s,u,m,b,g)=>{const _=m[0].dims,y=m[1].dims,v=[y[0],Math.ceil(_[1]*y[2]*y[3]/4)],w=(0,f.calculateIm2ColDims)(_,y,b),[M,S]=s.calculateTextureWidthAndHeight(v,l.TextureType.packedLastDimension),O=r.ShapeUtil.computeStrides(w),[x,T]=s.calculateTextureWidthAndHeight(w,l.TextureType.packedLastDimension),I=b.length,F=m.length<3?"0.0":"_B(b)",C=Math.ceil(_[1]*y[2]*y[3]/4),{activationFunction:N,applyActivation:B}=(0,a.getActivationSnippet)(g),k=(0,o.getGlsl)(s.session.backend.glContext.version),R=`
${N}
float process(int indices[${I}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${O[0]} + im2col[1] * ${O[1]} + im2col[2] * ${O[2]};
  int kernelOffset = indices[1] * ${v[1]};
  float value = ${F};
  for (int i = 0; i < ${C}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${x}, ${T});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${M}, ${S});
    value += dot(${k.texture2D}(Im2Col, im2colCoords), ${k.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${B}
  return value;
}`;return Object.assign(Object.assign({},u),{output:{dims:b,type:m[0].type,textureType:l.TextureType.unpacked},shaderSource:R})})(p,e,h,c,n)})}},7992:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseFlattenAttributes=t.flatten=void 0;const r=i(2517);t.flatten=(l,a,f)=>{o(a,f);const p=r.ShapeUtil.flattenShape(a[0].dims,f);return[l.reshapeUnpacked(a[0],p)]},t.parseFlattenAttributes=l=>l.attributes.getInt("axis",1);const o=(l,a)=>{if(!l||l.length!==1)throw new Error("Flatten requires 1 input.");const f=l[0].dims.length;if(f===0)throw new Error("scalar tensor is not supported.");if(a<-f||a>f)throw new Error("Invalid axis");if(l[0].type==="string")throw new Error("string tensor is not supported.")}},2823:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActivationSnippet=void 0;const r=i(2517),o=i(4909);t.getActivationSnippet=function(l){let a;switch(l.activation){case"Relu":a=(0,o.glslRelu)();break;case"Sigmoid":a=(0,o.glslSigmoid)();break;case"Clip":a=(0,o.glslClip)(l.clipMin,l.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const f=a.name;return{activationFunction:a.body,applyActivation:`value = ${f}_(value);`}},t.parseInternalActivationAttributes=l=>{const a=l.getString("activation","");if(a==="Clip"){const[f,p]=l.getFloats("activation_params",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:a,clipMax:p,clipMin:f,activationCacheKey:`${a}:${f},${p}`}}return{activation:a,activationCacheKey:a}}},1253:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseGatherAttributes=t.gather=void 0;const r=i(246),o=i(782),l=i(2517),a=i(2039);t.gather=(c,n,e)=>(h(n,e.axis),[c.run(p(c,n,e),n)]),t.parseGatherAttributes=c=>(0,r.createAttributeWithCacheKey)({axis:c.attributes.getInt("axis",0)});const f={name:"Gather",inputNames:["A","B"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},p=(c,n,e)=>{const s=Object.assign(Object.assign({},f),{cacheHint:e.cacheKey});return Object.assign(Object.assign({},s),{get:()=>((u,m,b,g)=>{const _=b[0].dims.slice(),y=b[1].dims.slice(),v=new Array(_.length+y.length-1);g=l.ShapeUtil.normalizeAxis(g,_.length);const w=[];for(let S=0;S<v.length;S++)S<g?(v[S]=_[S],w.push(`inputIdx[${S}] = outputIdx[${S}];`)):S<g+y.length?(v[S]=y[S-g],w.push(`indexDataIdx[${S-g}] = outputIdx[${S}];`)):(v[S]=_[S-y.length+1],w.push(`inputIdx[${S-y.length+1}] = outputIdx[${S}];`));const M=`
      float process(int outputIdx[${v.length||1}]) {
        int inputIdx[${_.length}];
        int indexDataIdx[${y.length||1}];
        indexDataIdx[0] = 0;
        ${w.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${g}] = idx < 0 ? idx + ${_[g]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},m),{output:{dims:v,type:b[0].type,textureType:a.TextureType.unpacked},shaderSource:M})})(0,s,n,e.axis)})},h=(c,n)=>{if(!c||c.length!==2)throw new Error("Gather requires 2 inputs.");const e=c[0].dims.length;if(e<1)throw new Error("Invalid input shape.");if(n<-e||n>e-1)throw new Error("Invalid axis.");if(o.NUMBER_TYPES.indexOf(c[0].type)===-1)throw new Error("Invaid input type.");if(c[1].type!=="int32"&&c[1].type!=="int16")throw new Error("Invaid input type.")}},4776:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributesV11=t.parseGemmAttributesV7=t.gemm=void 0;const r=i(246),o=i(2517),l=i(2039);t.gemm=(c,n,e)=>(h(n,e),[c.run(f(n,e),n)]);const a=(c,n)=>{const e=c.attributes.getInt("transA",0)!==0,s=c.attributes.getInt("transB",0)!==0,u=c.attributes.getFloat("alpha",1),m=c.attributes.getFloat("beta",1);return(0,r.createAttributeWithCacheKey)({transA:e,transB:s,alpha:u,beta:m,isOptionalC:n})};t.parseGemmAttributesV7=c=>a(c,!1),t.parseGemmAttributesV11=c=>a(c,!0);const f=(c,n)=>{const e={name:"Gemm",inputNames:c.length===3?["A","B","C"]:["A","B"],inputTypes:c.length===3?[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]:[l.TextureType.unpacked,l.TextureType.unpacked],key:n.cacheKey};return Object.assign(Object.assign({},e),{get:()=>p(e,c,n)})},p=(c,n,e)=>{const s=n[0].dims.slice(),u=n[1].dims.slice(),[m,b]=o.GemmUtil.getShapeOfGemmResult(s,e.transA,u,e.transB,n.length===3?n[2].dims:void 0),g=[m,b];if(!g)throw new Error("Can't use gemm on the given tensors");let _=s[s.length-1],y="";e.transA&&(_=s[0]),e.transA&&e.transB?y="value += _A_T(a) * _B_T(b);":e.transA&&!e.transB?y="value += _A_T(a) * _B(b);":!e.transA&&e.transB?y="value += _A(a) * _B_T(b);":e.transA||e.transB||(y="value += _A(a) * _B(b);");const v=g.length,w=`
      float process(int indices[${v}]) {
          int a[${v}];
          int b[${v}];
          ${n.length===3?`int c[${n[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${n.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${_}; ++k) {
              a[${v-1}] = k;
              b[${v-2}] = k;
              ${y}
          }

          value = value * alpha;
          ${n.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},c),{output:{dims:g,type:n[0].type,textureType:l.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:e.alpha},{name:"beta",type:"float",data:e.beta}],shaderSource:w})},h=(c,n)=>{if(!c)throw new Error("Input is missing");if(n.isOptionalC&&(c.length<2||c.length>3))throw new Error("Invaid input shape.");if(!n.isOptionalC&&c.length!==3)throw new Error("Gemm requires 3 inputs");if(c.length===3&&c[2].dims.length!==1&&c[2].dims.length!==2)throw new Error("Invalid input shape of C");if(c[0].type!=="float32"&&c[0].type!=="float64"||c[1].type!=="float32"&&c[1].type!=="float64"||c.length===3&&c[2].type!=="float32"&&c[2].type!=="float64")throw new Error("Invalid input type.");if(c[0].type!==c[1].type||c.length===3&&c[0].type!==c[2].type)throw new Error("Input types are mismatched")}},8555:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedIm2ColProgramInfoLoader=void 0;const r=i(5060),o=i(2039),l=i(2827);t.createPackedIm2ColProgramInfoLoader=(a,f,p,h,c)=>{const n=(e=c.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[o.TextureType.packed],cacheHint:e});var e;return Object.assign(Object.assign({},n),{get:()=>((s,u,m,b,g,_)=>{const y=m.dims,v=b.dims,w=g.length,M=[v[1]*v[2]*v[3],g[2]*g[3]],S=v[2]*v[3],O=(0,l.unpackFromChannel)(),x=(0,r.getGlsl)(s.session.backend.glContext.version);let T="";for(let F=0;F<=1;F++)for(let C=0;C<=1;C++)T+=`
            blockIndex = rc.x + ${C};
            pos = rc.y + ${F};

            if(blockIndex < ${M[1]} && pos < ${M[0]}) {
              offsetY = int(blockIndex / (${g[w-1]})) * ${_.strides[0]} -
                ${_.pads[0]};
              d0 = offsetY + ${_.dilations[0]} * (imod(pos, ${S}) / ${v[2]});

              if(d0 < ${y[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${g[w-1]}) * ${_.strides[1]} -
                  ${_.pads[1]};
                d1 = offsetX + ${_.dilations[1]} * imod(imod(pos, ${S}), ${v[2]});

                if(d1 < ${y[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${S}.);
                    innerDims = vec2(d0, d1);
                    result[${2*F+C}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const I=`
      ${O}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${T}
          ${x.output} = result;
      }
            `;return Object.assign(Object.assign({},u),{output:{dims:M,type:m.type,textureType:o.TextureType.packed},shaderSource:I,hasMain:!0})})(a,n,f,p,h,c)})}},3248:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateIm2ColDims=t.createIm2ColProgramInfoLoader=void 0;const r=i(2039);t.createIm2ColProgramInfoLoader=(o,l,a,f,p)=>{const h=(c=p.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[r.TextureType.unpacked],cacheHint:c});var c;return Object.assign(Object.assign({},h),{get:()=>((n,e,s,u,m,b)=>{const g=s.dims,_=u.dims,y=m.length,v=(0,t.calculateIm2ColDims)(g,_,m,4),w=`
        const int XC = ${g[1]};
        const int XH = ${g[2]};
        const int XW = ${g[3]};
        const int KH = ${b.kernelShape[0]};
        const int KW = ${b.kernelShape[1]};
        const int dilationH = ${b.dilations[0]};
        const int dilationW = ${b.dilations[1]};
        const int strideH = ${b.strides[0]};
        const int strideW = ${b.strides[1]};
        const int padH = ${b.pads[0]};
        const int padW = ${b.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${y}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${g.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},e),{output:{dims:v,type:s.type,textureType:r.TextureType.packedLastDimension},shaderSource:w})})(0,h,l,a,f,p)})},t.calculateIm2ColDims=(o,l,a,f=4)=>[a[0],a[2],a[3],Math.ceil(o[1]*l[2]*l[3]/f)]},6572:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseImageScalerAttributes=t.imageScaler=void 0;const r=i(246),o=i(2039);t.imageScaler=(h,c,n)=>(p(c),[h.run(a(h,c,n),c)]),t.parseImageScalerAttributes=h=>{const c=h.attributes.getFloat("scale"),n=h.attributes.getFloats("bias");return(0,r.createAttributeWithCacheKey)({scale:c,bias:n})};const l={name:"ImageScaler",inputNames:["X"],inputTypes:[o.TextureType.unpacked]},a=(h,c,n)=>{const e=Object.assign(Object.assign({},l),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},e),{get:()=>((s,u,m,b)=>{const g=m[0].dims.slice(),_=g.length,y=`
      ${f(b.bias.length)}
      float process(int indices[${_}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},u),{output:{dims:g,type:m[0].type,textureType:o.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:b.bias.length,data:b.bias},{name:"scale",type:"float",data:b.scale}],shaderSource:y})})(0,e,c,n)})},f=h=>{const c=[`float getBias(float bias[${h}], int channel) {`];for(let n=0;n<h;++n)n===0?c.push(`	if (channel == ${n}) { return bias[${n}]; }`):n===h-1?c.push(`	else { return bias[${n}]; }`):c.push(`	else if (channel == ${n}) { return bias[${n}]; }`);return c.push("	}"),c.join(`
`)},p=h=>{if(!h||h.length!==1)throw new Error("ImageScaler requires 1 input.");if(h[0].dims.length!==4)throw new Error("Invalid input shape.");if(h[0].type!=="float32"&&h[0].type!=="float64")throw new Error("Invalid input type.")}},3346:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseInstanceNormalizationAttributes=t.instanceNormalization=void 0;const r=i(5060),o=i(2039);t.instanceNormalization=(c,n,e)=>{h(n);const s=c.run(a(n[0]),n);return[c.run(p(c,n[0],e,s.dims),[n[0],s,n[1],n[2]])]},t.parseInstanceNormalizationAttributes=c=>c.attributes.getFloat("epsilon",1e-5);const l={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[o.TextureType.unpacked]},a=c=>Object.assign(Object.assign({},l),{get:()=>((n,e)=>{const s=e.dims.slice(),u=s[1],m=s[2]*s[3],b=[s[0],u],g=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${s[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${s[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${m});
        temp = 0.0;
        for(int a2=0; a2<${s[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${s[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${m});

        return v;
      }`;return Object.assign(Object.assign({},n),{output:{dims:b,type:e.type,textureType:o.TextureType.packedLastDimension},shaderSource:g})})(l,c)}),f={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked,o.TextureType.unpacked]},p=(c,n,e,s)=>{const u=Object.assign(Object.assign({},f),{cacheHint:`${e}`});return Object.assign(Object.assign({},u),{get:()=>((m,b,g,_,y)=>{const v=(0,r.getGlsl)(m.session.backend.glContext.version),[w,M]=m.calculateTextureWidthAndHeight(y,o.TextureType.packedLastDimension),[S,O]=[w/4,M],x=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${S}, ${O});
        return ${v.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},b),{output:{dims:g.dims,type:g.type,textureType:o.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:_}],shaderSource:x})})(c,u,n,e,s)})},h=c=>{if(!c||c.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const n=c[0],e=c[1],s=c[2];if(n.dims.length<3||e.dims.length!==1||s.dims.length!==1)throw new Error("Invalid input shape.");if(e.dims[0]!==n.dims[1]||s.dims[0]!==n.dims[1])throw new Error("Input shapes are mismatched.");if(n.type!=="float32"&&n.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||s.type!=="float32"&&s.type!=="float64")throw new Error("Invalid input type.");if(c[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},708:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedMatmulProgramInfoLoader=void 0;const r=i(2517),o=i(5060),l=i(2039),a=i(9390),f=i(2823),p=i(5623);t.createPackedMatmulProgramInfoLoader=(h,c,n)=>{const e=(s=c.length>2,u=n.activationCacheKey,{name:"MatMul (packed)",inputNames:s?["A","B","Bias"]:["A","B"],inputTypes:s?[l.TextureType.packed,l.TextureType.packed,l.TextureType.packed]:[l.TextureType.packed,l.TextureType.packed],cacheHint:u});var s,u;return Object.assign(Object.assign({},e),{get:()=>((m,b,g,_)=>{const y=g.length>2,v=y?"value += getBiasForMatmul();":"",w=g[0].dims,M=g[1].dims,S=r.BroadcastUtil.calcShape(w,M,!0),O=!r.ShapeUtil.areEqual(g[0].dims,g[1].dims);if(!S)throw new Error("Can't use matmul on the given tensors");const x=w[w.length-1],T=Math.ceil(x/2),I=w.length,F=M.length,C=(0,o.getGlsl)(m.session.backend.glContext.version),N=(0,a.getCoordsDataType)(S.length),B=S.length,k=(0,a.getGlChannels)(),{activationFunction:R,applyActivation:X}=(0,f.getActivationSnippet)(_),U=y?`${(0,p.getBiasForMatmul)(N,k,g[2].dims,S,!0)}`:"",K=O?`${function(ae,ne,ce,oe){let De=[],$e=[];const Te=ce[0].dims,Ne=ce[1].dims,Fe=Te.length,Ae=Ne.length,Se=oe.length,Ue=Se-Fe,Ge=Se-Ae;De=Te.map((Pe,qe)=>`coords.${ne[qe+Ue]}`),De[Fe-1]="i*2",De.join(", "),$e=Ne.map((Pe,qe)=>`coords.${ne[qe+Ge]}`),$e[Ae-2]="i*2",$e.join(", ");const He=r.BroadcastUtil.getBroadcastDims(Te,oe),Ze=r.BroadcastUtil.getBroadcastDims(Ne,oe),rt=He.map(Pe=>`coords.${ne[Pe+Ue]} = 0;`).join(`
`),Xe=Ze.map(Pe=>`coords.${ne[Pe+Ge]} = 0;`).join(`
`),Ye=`int lastDim = coords.${ne[Se-1]};
  coords.${ne[Se-1]} = coords.${ne[Se-2]};
  coords.${ne[Se-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${ae} coords = getOutputCoords();
  ${Ye}
  ${rt}
  vec4 outputValue = getA(${De});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${ae} coords = getOutputCoords();
  ${Ye}
  ${Xe}
  vec4 outputValue = getB(${$e});
  return outputValue;
}`}(N,k,g,S)}`:"",Q=O?"getAAtOutCoordsMatmul(i)":`getA(${function(ae,ne){let ce="";for(let oe=0;oe<ne-2;oe++)ce+=`rc.${ae[oe]}, `;return ce+=`rc.${ae[ne-2]}, i*2`,ce}(k,I)})`,se=O?"getBAtOutCoordsMatmul(i)":`getB(${function(ae,ne){let ce="";for(let oe=0;oe<ne-2;oe++)ce+=`rc.${ae[oe]}, `;return ce+=`i*2, rc.${ae[ne-1]}`,ce}(k,F)})`,te=`
            ${K}
            ${U}
            ${R}
            void main() {
              ${O?"":`${N} rc =
          getOutputCoords(); int lastDim = rc.${k[B-1]}; rc.${k[B-1]} =
          rc.${k[B-2]}; rc.${k[B-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${T}; i++) {
                vec4 a = ${Q};
                vec4 b = ${se};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${v}
              ${X}
              ${C.output} = value;
            }`;return Object.assign(Object.assign({},b),{output:{dims:S,type:g[0].type,textureType:l.TextureType.packed},shaderSource:te,hasMain:!0})})(h,e,c,n)})}},5623:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getBiasForMatmul=t.createMatmulProgramInfoLoader=t.parseMatMulAttributes=t.matMul=void 0;const r=i(2517),o=i(2039),l=i(9390),a=i(2823),f=i(708);function p(n,e){const s=(u=n.length>2,m=e.activationCacheKey,{name:"MatMul",inputNames:u?["A","B","Bias"]:["A","B"],inputTypes:u?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:m});var u,m;return Object.assign(Object.assign({},s),{get:()=>function(b,g,_){const y=g[0].dims,v=g[1].dims,w=r.BroadcastUtil.calcShape(y,v,!0);if(!w)throw new Error("Can't use matmul on the given tensors");const M=(0,l.getCoordsDataType)(w.length),S=(0,l.getGlChannels)(),{activationFunction:O,applyActivation:x}=(0,a.getActivationSnippet)(_),T=g.length>2,I=T?"value += getBiasForMatmul();":"",F=T?`${c(M,S,g[2].dims,w,!1)}`:"",C=w.length,N=y.length,B=v.length,k=`
    ${O}
    ${F}
    float process(int indices[${C}]) {
        int a[${N}];
        int b[${B}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${y[y.length-1]}; ++k) {
            a[${N-1}] = k;
            b[${B-2}] = k;
            value += _A(a) * _B(b);
        }
        ${I}
        ${x}
        return value;
    }`;return Object.assign(Object.assign({},b),{output:{dims:w,type:g[0].type,textureType:o.TextureType.unpacked},shaderSource:k})}(s,n,e)})}t.matMul=(n,e,s)=>(h(e),n.session.pack?[n.run((0,f.createPackedMatmulProgramInfoLoader)(n,e,s),e)]:[n.run(p(e,s),e)]),t.parseMatMulAttributes=n=>(0,a.parseInternalActivationAttributes)(n.attributes),t.createMatmulProgramInfoLoader=p;const h=n=>{if(!n||n.length!==2)throw new Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw new Error("shared dimension does not match.");if(n[0].type!=="float32"&&n[0].type!=="float64"||n[1].type!=="float32"&&n[1].type!=="float64")throw new Error("inputs should be float type");if(n[0].type!==n[1].type)throw new Error("inputs types should match")};function c(n,e,s,u,m){let b="";const g=s.length,_=u.length,y=_-g;b=_<2&&g>0?"coords":s.map((M,S)=>`coords.${e[S+y]}`).join(", ");const v=r.BroadcastUtil.getBroadcastDims(s,u).map(M=>`coords.${e[M+y]} = 0;`).join(`
`);let w="vec4(outputValue.xx, outputValue.yy)";return r.ShapeUtil.size(s)===1&&(w="vec4(outputValue.x)"),m?`
vec4 getBiasForMatmul() {
  ${n} coords = getOutputCoords();
  ${v}
  vec4 outputValue = getBias(${b});
  return ${w};
}`:`
float getBiasForMatmul() {
  ${n} coords = getOutputCoords();
  ${v}
  return getBias(coords.x);
}`}t.getBiasForMatmul=c},2403:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackProgramInfoLoader=void 0;const r=i(5060),o=i(2039),l=i(9390),a=i(2827),f={name:"pack",inputNames:["A"],inputTypes:[o.TextureType.unpackedReversed]};t.createPackProgramInfoLoader=(p,h)=>Object.assign(Object.assign({},f),{get:()=>((c,n)=>{const e=(0,r.getGlsl)(c.session.backend.glContext.version),s=n.dims,u=s.length,m=n.dims.length,b=(0,l.getCoordsDataType)(m),g=(0,a.getChannels)("rc",m),_=(y=m,v=g,w=s[s.length-2],M=s[s.length-1],y===0||y===1?"":`
    int r = ${v[y-2]};
    int c = ${v[y-1]};
    int rp1 = ${v[y-2]} + 1;
    int cp1 = ${v[y-1]} + 1;
    bool rEdge = rp1 >= ${M};
    bool cEdge = cp1 >= ${w};
    `);var y,v,w,M;let S;S=u===0?[1,1]:u===1?[s[0],1]:[s[m-1],s[m-2]];const O=function(I,F,C){if(I===0)return"false";if(I===1)return`rc > ${F[0]}`;let N="";for(let B=I-2;B<I;B++)N+=`${C[B]} >= ${F[B-I+2]}`,B<I-1&&(N+="||");return N}(m,S,g),x=function(I,F){const C=I.length;if(C===0)return"getA(), 0, 0, 0";if(C===1)return`getA(rc),
            rc + 1 >= ${I[0]} ? 0. : getA(rc + 1),
            0, 0`;let N="";if(C>2)for(let B=0;B<C-2;++B)N+=`${F[B]},`;return`getA(${N}r, c),
          rEdge ? 0. : getA(${N}rp1, c),
          cEdge ? 0. : getA(${N}r, cp1),
          rEdge || cEdge ? 0. : getA(${N}rp1, cp1)`}(s,g),T=`
        void main() {
          ${b} rc = getOutputCoords();

          if(${O}) {
            ${e.output} = vec4(0);
          } else {
            ${_}

            ${e.output} = vec4(${x});
          }
        }
      `;return Object.assign(Object.assign({},f),{hasMain:!0,output:{dims:n.dims,type:n.type,textureType:o.TextureType.packed},shaderSource:T})})(p,h)})},2827:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.unpackFromChannel=t.getChannels=t.getVecChannels=void 0;const r=i(9390);function o(l,a){return(0,r.getGlChannels)(a).map(f=>`${l}.${f}`)}t.getVecChannels=o,t.getChannels=function(l,a){return a===1?[l]:o(l,a)},t.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},2870:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parsePadAttributesV11=t.padV11=t.parsePadAttributesV2=t.padV2=void 0;const r=i(246),o=i(2517),l=i(5060),a=i(2039),f={name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.padV2=(b,g,_)=>(c(g),[b.run(Object.assign(Object.assign({},f),{cacheHint:_.cacheKey,get:()=>h(b,g[0],_)}),g)]),t.parsePadAttributesV2=b=>{const g=b.attributes.getString("mode","constant"),_=b.attributes.getFloat("value",0),y=b.attributes.getInts("pads");return(0,r.createAttributeWithCacheKey)({mode:g,value:_,pads:y})},t.padV11=(b,g,_)=>{n(g);const y=p(b,g,_);return(0,t.padV2)(b,[g[0]],y)},t.parsePadAttributesV11=b=>b.attributes.getString("mode","constant");const p=(b,g,_)=>{if(!b.session.isInitializer(g[1].dataId)||g.length>=3&&!b.session.isInitializer(g[2].dataId))throw new Error("dynamic pad attributes are not allowed");const y=Array.from(g[1].integerData),v=g.length>=3?g[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:_,pads:y,value:v})},h=(b,g,_)=>{const y=o.ShapeUtil.padShape(g.dims.slice(),_.pads),v=y.length,w=`
      ${e(b,g,_)}
      float process(int[${v}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked],output:{dims:y,type:g.type,textureType:a.TextureType.unpacked},shaderSource:w}},c=b=>{if(!b||b.length!==1)throw new Error("Pad requires 1 input");if(b[0].type!=="float32"&&b[0].type!=="float64")throw new Error("Invalid input type.")},n=b=>{if(!b||b.length!==2&&b.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(b[1].type!=="int32")throw new Error("Invalid input type.");if(b.length>=3&&b[2].type==="string")throw new Error("Invalid input type.")},e=(b,g,_)=>{const y=(0,l.getGlsl)(b.session.backend.glContext.version),[v,w]=b.calculateTextureWidthAndHeight(g.dims,a.TextureType.unpacked),M=o.ShapeUtil.computeStrides(g.dims);switch(_.mode){case"constant":return s(y,g.dims,M,v,w,_.pads,_.value);case"reflect":return u(y,g.dims,M,v,w,_.pads);case"edge":return m(y,g.dims,M,v,w,_.pads);default:throw new Error("Invalid mode")}},s=(b,g,_,y,v,w,M)=>{const S=g.length;let O="";for(let x=S-1;x>=0;--x)O+=`
        k = m[${x}] - ${w[x]};
        if (k < 0)  return constant;
        if (k >= ${g[x]}) return constant;
        offset += k * ${_[x]};
        `;return`
      float padA(int m[${S}]) {
        const float constant = float(${M});
        int offset = 0;
        int k = 0;
        ${O}
        vec2 coords = offsetToCoords(offset, ${y}, ${v});
        float value = getColorAsFloat(${b.texture2D}(A, coords));
        return value;
      }
      `},u=(b,g,_,y,v,w)=>{const M=g.length;let S="";for(let O=M-1;O>=0;--O)S+=`
        k = m[${O}] - ${w[O]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(g[O]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${g[O]}) { k = _2n_1 - k; }
        }
        offset += k * ${_[O]};
        `;return`
      float padA(int m[${M}]) {
        int offset = 0;
        int k = 0;
        ${S}
        vec2 coords = offsetToCoords(offset, ${y}, ${v});
        float value = getColorAsFloat(${b.texture2D}(A, coords));
        return value;
      }
      `},m=(b,g,_,y,v,w)=>{const M=g.length;let S="";for(let O=M-1;O>=0;--O)S+=`
        k = m[${O}] - ${w[O]};
        if (k < 0)  k = 0;
        if (k >= ${g[O]}) k = ${g[O]-1};
        offset += k * ${_[O]};
      `;return`
      float padA(int m[${M}]) {
        int offset = 0;
        int k = 0;
        ${S}
        vec2 coords = offsetToCoords(offset, ${y}, ${v});
        float value = getColorAsFloat(${b.texture2D}(A, coords));
        return value;
      }
      `}},2143:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseMaxPoolAttributes=t.maxPool=t.parseGlobalAveragePoolAttributes=t.globalAveragePool=t.parseAveragePoolAttributes=t.averagePool=void 0;const r=i(246),o=i(2517),l=i(2039);t.averagePool=(m,b,g)=>{n(b);const _={name:"AveragePool",inputNames:["X"],inputTypes:[l.TextureType.unpacked],cacheHint:g.cacheKey};return[m.run(Object.assign(Object.assign({},_),{get:()=>a(b,_,!1,g)}),b)]},t.parseAveragePoolAttributes=m=>{const b=m.attributes.getString("auto_pad","NOTSET"),g=m.attributes.getInt("ceil_mode",0),_=m.attributes.getInt("count_include_pad",0)!==0,y=m.attributes.getInts("kernel_shape"),v=m.attributes.getInts("strides",[]),w=m.attributes.getInts("pads",[]);if(g!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,r.createAttributeWithCacheKey)({autoPad:b,ceilMode:g,countIncludePad:_,kernelShape:y,strides:v,pads:w})};const a=(m,b,g,_)=>{const[y,v]=p(m,_,g),w=o.ShapeUtil.size(y.kernelShape);let M="";y.countIncludePad?M+=`value /= float(${w});`:M+=`value /= float(${w} - pad);`;const S=`
        ${e(m[0].dims,y,"value += _X(x);",M,"0.0")}
      `;return Object.assign(Object.assign({},b),{output:{dims:v,type:m[0].type,textureType:l.TextureType.unpacked},shaderSource:S})};t.globalAveragePool=(m,b,g)=>{n(b);const _={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[l.TextureType.unpacked],cacheHint:`${g.countIncludePad}`};return[m.run(Object.assign(Object.assign({},_),{get:()=>a(b,_,!0,g)}),b)]},t.parseGlobalAveragePoolAttributes=m=>{const b=m.attributes.getInt("count_include_pad",0)!==0;return(0,r.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:b,kernelShape:[],strides:[],pads:[]})},t.maxPool=(m,b,g)=>{n(b);const _={name:"MaxPool",inputNames:["X"],inputTypes:[l.TextureType.unpacked],cacheHint:g.cacheKey};return[m.run(Object.assign(Object.assign({},_),{get:()=>f(b,_,!1,g)}),b)]},t.parseMaxPoolAttributes=m=>{const b=m.attributes.getString("auto_pad","NOTSET"),g=m.attributes.getInt("ceil_mode",0),_=m.attributes.getInts("kernel_shape"),y=m.attributes.getInts("strides",[]),v=m.attributes.getInts("pads",[]),w=m.attributes.getInt("storage_order",0),M=m.attributes.getInts("dilations",[]);if(w!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(g!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,r.createAttributeWithCacheKey)({autoPad:b,ceilMode:g,countIncludePad:!1,kernelShape:_,strides:y,pads:v,storageOrder:w,dilations:M})};const f=(m,b,g,_)=>{const[y,v]=p(m,_,g),w=`
      ${e(m[0].dims,y,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},b),{output:{dims:v,type:m[0].type,textureType:l.TextureType.unpacked},shaderSource:w})},p=(m,b,g)=>{const _=m[0].dims.slice(),y=Object.hasOwnProperty.call(b,"dilations"),v=b.kernelShape.slice(),w=b.strides.slice(),M=y?b.dilations.slice():[],S=b.pads.slice();o.PoolConvUtil.adjustPoolAttributes(g,_,v,w,M,S);const O=o.PoolConvUtil.computePoolOutputShape(g,_,w,M,v,S,b.autoPad),x=Object.assign({},b);return y?Object.assign(x,{kernelShape:v,strides:w,pads:S,dilations:M,cacheKey:b.cacheKey}):Object.assign(x,{kernelShape:v,strides:w,pads:S,cacheKey:b.cacheKey}),[x,O]},h={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},c={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[l.TextureType.unpacked]};t.globalMaxPool=(m,b)=>(n(b),[m.run(Object.assign(Object.assign({},c),{get:()=>f(b,c,!0,h)}),b)]);const n=m=>{if(!m||m.length!==1)throw new Error("Pool ops requires 1 input.");if(m[0].type!=="float32"&&m[0].type!=="float64")throw new Error("Invalid input type.")},e=(m,b,g,_,y)=>{const v=m.length;if(b.kernelShape.length<=2){const w=b.kernelShape[b.kernelShape.length-1],M=b.strides[b.strides.length-1],S=b.pads[b.pads.length/2-1],O=b.pads[b.pads.length-1],x=m[v-1];let T="",I="",F="";if(T=S+O!==0?`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${M} - ${S} + i;
            if (x[${v} - 1] < 0 || x[${v} - 1] >= ${x}) {
              pad++;
              continue;
            }
            ${g}
          }`:`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${M} - ${S} + i;
            ${g}
          }`,b.kernelShape.length===2){const C=b.kernelShape[b.kernelShape.length-2],N=b.strides[b.strides.length-2],B=b.pads[b.pads.length/2-2],k=b.pads[b.pads.length-2],R=m[v-2];I=B+k!==0?`
            for (int j = 0; j < ${C}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${N} - ${B} + j;
              if (x[${v} - 2] < 0 || x[${v} - 2] >= ${R}) {
                pad+= ${w};
                continue;
              }
          `:`
            for (int j = 0; j < ${C}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${N} - ${B} + j;
            `,F=`
          }
        `}return`
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);

          float value = ${y};
          int pad = 0;
          ${I}
          ${T}
          ${F}
          ${_}
          return value;
        }
      `}{const w=o.ShapeUtil.size(b.kernelShape),M=o.ShapeUtil.computeStrides(b.kernelShape),S=M.length,O=b.pads.length,x=u(S),T=s(m,"inputDims"),I=s(b.pads,"pads"),F=s(M,"kernelStrides"),C=s(b.strides,"strides");let N="";return N=b.pads.reduce((B,k)=>B+k)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${g}
          }`:`
          }
          ${g}
        `,`
        ${x}
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);
          int offset[${S}];
          int pads[${O}];
          int inputDims[${v}];
          int kernelStrides[${S}];
          int strides[${S}];
          ${I}
          ${T}
          ${C}
          ${F}

          float value = ${y};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${w}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${v} - ${S}; j < ${v}; j++) {
              x[j] = indices[j] * strides[j - ${v} + ${S}]
                + offset[j - ${v} + ${S}] - pads[j - 2];
              ${N}
          }
          ${_}

          return value;
        }
      `}},s=(m,b)=>{let g="";for(let _=0;_<m.length;_++)g+=`
      ${b}[${_}] = ${m[_]};
    `;return g},u=m=>`
  void offsetToIndices(int offset, int[${m}] strides, out int[${m}] indices) {
    if (${m} == 0) {
      return;
    }
    for (int i = 0; i < ${m} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${m} - 1] = offset;
  }`},4939:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.reduceLogSumSquare=t.reduceLogSum=t.reduceProd=t.reduceMin=t.reduceMax=t.reduceMean=t.reduceSum=t.parseReduceAttributes=void 0;const r=i(246),o=i(782),l=i(2517),a=i(2039),f=(c,n,e,s,u)=>{h(n);const m={name:s,inputNames:["A"],inputTypes:[a.TextureType.unpacked]};return[c.run(Object.assign(Object.assign({},m),{cacheHint:e.cacheKey,get:()=>p(c,n,e,s,u,m)}),n)]};t.parseReduceAttributes=c=>{const n=c.attributes.getInts("axes",[]),e=c.attributes.getInt("keepdims",1)===1;return(0,r.createAttributeWithCacheKey)({axes:n,keepDims:e})};const p=(c,n,e,s,u,m)=>{const b=[],g=n[0].dims.length||1,_=[],y=l.ShapeUtil.normalizeAxes(e.axes,n[0].dims.length),v=u(n,y);let w=v[1];for(let S=0;S<n[0].dims.length;S++)y.indexOf(S)>=0||y.length===0?(e.keepDims&&b.push(1),w=`
          for(int j${S} = 0; j${S} < ${n[0].dims[S]}; j${S}++) {
            inputIdx[${S}] = j${S};
            ${w}
          }`):(_.push(`inputIdx[${S}] = outputIdx[${b.length}];`),b.push(n[0].dims[S]));const M=`
      float process(int outputIdx[${b.length||1}]) {
        float value;                 // final result
        int inputIdx[${g}];      // addressing input data
        ${_.join(`
`)}
        ${v[0]}       // init ops for reduce max/min
        ${w}
        ${v[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},m),{output:{dims:b,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:M})},h=c=>{if(!c||c.length!==1)throw new Error("Reduce op requires 1 input.");if(o.NUMBER_TYPES.indexOf(c[0].type)===-1)throw new Error("Invalid input type.")};t.reduceSum=(c,n,e)=>f(c,n,e,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),t.reduceMean=(c,n,e)=>f(c,n,e,"ReduceMean",(s,u)=>{let m=1;for(let b=0;b<s[0].dims.length;b++)(u.indexOf(b)>=0||u.length===0)&&(m*=s[0].dims[b]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${m}.;`]}),t.reduceMax=(c,n,e)=>f(c,n,e,"ReduceMax",(s,u)=>{const m=[];for(let b=0;b<s[0].dims.length;b++)(u.indexOf(b)>=0||u.length===0)&&m.push(`inputIdx[${b}] = 0;`);return[`${m.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),t.reduceMin=(c,n,e)=>f(c,n,e,"ReduceMin",(s,u)=>{const m=[];for(let b=0;b<s[0].dims.length;b++)(u.indexOf(b)>=0||u.length===0)&&m.push(`inputIdx[${b}] = 0;`);return[`${m.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),t.reduceProd=(c,n,e)=>f(c,n,e,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),t.reduceLogSum=(c,n,e)=>f(c,n,e,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),t.reduceLogSumSquare=(c,n,e)=>f(c,n,e,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7019:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isReshapeCheap=t.processDims3D=t.createPackedReshape3DProgramInfoLoader=void 0;const r=i(2517),o=i(5060),l=i(2039),a=i(2827);t.createPackedReshape3DProgramInfoLoader=(f,p,h)=>{const c=(n=>({name:"Reshape (packed)",inputTypes:[l.TextureType.packed],inputNames:["A"],cacheHint:`${n}`}))(h);return Object.assign(Object.assign({},c),{get:()=>((n,e,s,u)=>{const m=e.dims,b=u;let g="";for(let v=0;v<4;v++){let w="";switch(v){case 0:w="outputCoords = rc;";break;case 1:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:w="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}g+=`
        ${w}
        ${v>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${v}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${v>0?"}":""}
      `}const _=(0,o.getGlsl)(n.session.backend.glContext.version),y=`
      ${function(v){const w=r.ShapeUtil.computeStrides(v),M=["b","r","c"],S="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${w.map((O,x)=>`int ${M[x]} = ${S} / ${O}; ${x===w.length-1?`int ${M[x+1]} = ${S} - ${M[x]} * ${O}`:`index -= ${M[x]} * ${O}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(m)}
      ${function(v){const w=r.ShapeUtil.computeStrides(v);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${w[0]} + coords.z * ${w[1]} + coords.y;
  }
`}(b)}
      ${(0,a.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${b[2]};
        int cols = ${b[1]};

        ${g}
        ${_.output} = result;
      }
    `;return Object.assign(Object.assign({},s),{output:{dims:b,type:e.type,textureType:l.TextureType.packed},shaderSource:y,hasMain:!0})})(f,p,c,h)})},t.processDims3D=function(f){if(f.length===0)return[1,1,1];let p=1;for(let h=0;h<f.length-2;++h)p*=f[h];return[p,f.length>1?f[f.length-2]:1,f[f.length-1]]},t.isReshapeCheap=function(f,p){let h=!1;return h=f.length===0||p.length===0||(f.length<2||p.length<2?f[f.length-1]===p[p.length-1]:f[f.length-1]===p[p.length-1]&&f[f.length-2]===p[p.length-2]),h}},718:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.reshape=void 0;const r=i(2517);t.reshape=(o,l)=>{const a=r.ShapeUtil.calculateReshapedDims(l[0].dims,l[1].integerData);return o.session.pack?[o.reshapePacked(l[0],a)]:[o.reshapeUnpacked(l[0],a)]}},2268:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributesV11=t.parseResizeAttributesV10=t.resize=void 0;const r=i(5060),o=i(2039),l=i(9390),a=i(2827),f=i(9793),p={name:"Resize",inputNames:["A"],inputTypes:[o.TextureType.packed]};t.resize=(s,u,m)=>((0,f.validateInputs)(u,m),[s.run(Object.assign(Object.assign({},p),{cacheHint:m.cacheKey,get:()=>h(s,u,m)}),u)]),t.parseResizeAttributesV10=s=>(0,f.parseUpsampleAttributes)(s,10),t.parseResizeAttributesV11=s=>(0,f.parseUpsampleAttributes)(s,11);const h=(s,u,m)=>{const b=(0,r.getGlsl)(s.session.backend.glContext.version),[g,_]=c(u,m);if(g.every(N=>N===1)&&m.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},p),{output:{dims:_,type:u[0].type,textureType:o.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${b.texture2D}(X, TexCoords);
                    ${b.output} = v;
                }`});const y=_.length;if(y<2)throw new Error(`output dimension should be at least 2, but got ${y}`);const v=_[y-2],w=_[y-1],M=u[0].dims;if(y!==M.length)throw new Error(`output dimension should match input ${M.length}, but got ${y}`);const S=M[y-2],O=M[y-1],x=g[y-2],T=g[y-1];let I="";if(m.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${m.mode}'`);switch(m.coordinateTransformMode){case"asymmetric":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${w}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${w}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${w}.0 - 1.0, ${v}.0 - 1.0, ${w}.0 - 1.0,
                            ${v}.0 - 1.0);
                        vec4 original = vec4(${O}.0 - 1.0, ${S}.0 - 1.0, ${O}.0 - 1.0,
                            ${S}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${m.coordinateTransformMode}'`)}const F=(0,l.getCoordsDataType)(y),C=`
            const vec2 inputWH = vec2(${S}.0, ${O}.0);
            const vec4 scaleWHWH = vec4(float(${x}), float(${T}), float(${x}), float(${T}));
            ${(0,a.unpackFromChannel)()}
            ${I}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${F} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${v-1};
                bool hasNextCol = rc.z < ${w-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${b.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},p),{output:{dims:_,type:u[0].type,textureType:o.TextureType.packed},hasMain:!0,shaderSource:C})},c=(s,u)=>{const m=s[0].dims;let b,g=u.scales;if(g.length===0){const y=s[u.scalesInputIdx];if(y&&y.size!==0){if(s[u.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");g=n(y,u.mode,u.isResize)}else{const v=s[u.sizesInputIdx];if(!v||v.size===0)throw new Error("Either scales or sizes MUST be provided as input.");b=Array.from(v.integerData),g=e(b,m,u.mode,u.isResize)}}else if(s[u.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const _=b||m.map((y,v)=>Math.floor(y*g[v]));return[g,_]},n=(s,u,m)=>{const b=Array.from(s.floatData);return(0,f.scalesValidation)(b,u,m),b},e=(s,u,m,b)=>{const g=u.length,_=new Array(g);for(let y=0,v=g;y<v;y++)if(u[y]===0){if(s[y]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");_[y]=1}else _[y]=s[y]/u[y];return(0,f.scalesValidation)(_,m,b),_}},8117:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.shape=void 0;const r=i(9162);t.shape=(l,a)=>(o(a),[new r.Tensor([a[0].dims.length],"int32",void 0,void 0,new Int32Array(a[0].dims))]);const o=l=>{if(!l||l.length!==1)throw new Error("Shape requires 1 input.")}},2278:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sliceV10=t.parseSliceAttributes=t.slice=void 0;const r=i(246),o=i(782),l=i(2517),a=i(2039),f={name:"Slice",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.slice=(e,s,u)=>(h(s),[e.run(Object.assign(Object.assign({},f),{cacheHint:u.cacheKey,get:()=>p(e,s[0],u)}),s)]),t.parseSliceAttributes=e=>{const s=e.attributes.getInts("starts"),u=e.attributes.getInts("ends"),m=e.attributes.getInts("axes",[]);return(0,r.createAttributeWithCacheKey)({starts:s,ends:u,axes:m})};const p=(e,s,u)=>{const m=u.axes.length===0?s.dims.slice(0).map((M,S)=>S):u.axes,b=l.ShapeUtil.normalizeAxes(m,s.dims.length),g=u.starts.map((M,S)=>M>s.dims[b[S]]-1?s.dims[b[S]]:l.ShapeUtil.normalizeAxis(M,s.dims[b[S]])),_=u.ends.map((M,S)=>M>s.dims[b[S]]-1?s.dims[b[S]]:l.ShapeUtil.normalizeAxis(M,s.dims[b[S]])),y=s.dims.slice(),v=[];for(let M=0;M<b.length;M++)y[b[M]]=_[M]-g[M],g[M]>0&&v.push(`outputIdx[${b[M]}] += ${g[M]};`);const w=`
      float process(int outputIdx[${y.length}]) {
        ${v.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},f),{output:{dims:y,type:s.type,textureType:a.TextureType.unpacked},shaderSource:w})},h=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(o.NUMBER_TYPES.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")};t.sliceV10=(e,s)=>{n(s);const u=c(e,s);return[e.run(Object.assign(Object.assign({},f),{cacheHint:u.cacheKey,get:()=>p(e,s[0],u)}),[s[0]])]};const c=(e,s)=>{if(!e.session.isInitializer(s[1].dataId)||!e.session.isInitializer(s[2].dataId)||s.length>=4&&!e.session.isInitializer(s[3].dataId)||s.length>=5&&!e.session.isInitializer(s[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(s.length>=5&&s[4].integerData.some(g=>g!==1))throw new Error("currently non-1 steps is not supported for Slice");const u=Array.from(s[1].integerData),m=Array.from(s[2].integerData),b=s.length>=4?Array.from(s[3].integerData):[];return{starts:u,ends:m,axes:b,cacheKey:`${b};${u};${m}`}},n=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}},5524:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.softmaxV13=t.parseSoftmaxAttributesV13=t.parseSoftmaxAttributes=t.softmax=void 0;const r=i(246),o=i(2517),l=i(5060),a=i(2039),f=i(3738),p={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[a.TextureType.unpacked]},h={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},c={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};t.softmax=(b,g,_)=>{m(g);const y=g[0].dims.slice(),v=o.ShapeUtil.normalizeAxis(_.axis,y.length),w=o.ShapeUtil.sizeToDimension(y,v),M=o.ShapeUtil.sizeFromDimension(y,v);return n(b,g,_,w,M)},t.parseSoftmaxAttributes=b=>(0,r.createAttributeWithCacheKey)({axis:b.attributes.getInt("axis",1)}),t.parseSoftmaxAttributesV13=b=>(0,r.createAttributeWithCacheKey)({axis:b.attributes.getInt("axis",-1)}),t.softmaxV13=(b,g,_)=>{m(g);const y=g[0].dims.slice(),v=o.ShapeUtil.normalizeAxis(_.axis,y.length),w=y.length,M=v!==w-1,S=[];let O,x=[],T=[];M&&(x=Array.from({length:w}).map((N,B)=>B),x[v]=w-1,x[w-1]=v,x.map(N=>S.push(y[N])),O=(0,r.createAttributeWithCacheKey)({perm:x}),T=(0,f.transpose)(b,g,O));const I=M?o.ShapeUtil.sizeToDimension(S,w-1):o.ShapeUtil.sizeToDimension(y,w-1),F=M?o.ShapeUtil.sizeFromDimension(S,w-1):o.ShapeUtil.sizeFromDimension(y,w-1),C=n(b,M?T:g,_,I,F);return M?(0,f.transpose)(b,C,O):C};const n=(b,g,_,y,v)=>{const w=e(b,g[0],y,v,[y]),M=b.run(Object.assign(Object.assign({},p),{cacheHint:_.cacheKey,get:()=>w}),g),S=s(b,g[0],y,v,w.output.dims,[y]),O=b.run(Object.assign(Object.assign({},h),{cacheHint:_.cacheKey,get:()=>S}),[g[0],M]),x=u(b,g[0],y,v,w.output.dims,S.output.dims);return[b.run(Object.assign(Object.assign({},c),{cacheHint:_.cacheKey,get:()=>x}),[g[0],M,O])]},e=(b,g,_,y,v)=>{const[w,M]=b.calculateTextureWidthAndHeight(g.dims,a.TextureType.unpacked),S=v.length;if(_<1||y<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1)throw new Error("Dimensionality of the output should be 1");if(v[0]!==_)throw new Error("Shape of the output should be equal to logical row count");const O=(0,l.getGlsl)(b.session.backend.glContext.version),x=`
      float process(int[${S}] indices) {
        int logical_row_start_offset = indices[0] * ${y};

        float max = getColorAsFloat(${O.texture2D}(A, offsetToCoords(logical_row_start_offset, ${w},
        ${M} )));
        for(int i=1; i<${y}; ++i)
        {
          float current = getColorAsFloat(${O.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${w}, ${M})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},p),{output:{dims:v,type:g.type,textureType:a.TextureType.unpacked},shaderSource:x})},s=(b,g,_,y,v,w)=>{const[M,S]=b.calculateTextureWidthAndHeight(g.dims,a.TextureType.unpacked),O=w.length;if(_<1||y<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(w.length!==1)throw new Error("Dimensionality of the output should be 1");if(w[0]!==_)throw new Error("Shape of the output should be equal to logical row count");if(v.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==_)throw new Error("Shape of the intermediate results should be equal to logical row count");const x=`
      float process(int[${O}] indices) {
        int logical_row_start_offset = indices[0] * ${y};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${y}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,l.getGlsl)(b.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${M}, ${S}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},h),{output:{dims:w,type:g.type,textureType:a.TextureType.unpacked},shaderSource:x})},u=(b,g,_,y,v,w)=>{const[M,S]=b.calculateTextureWidthAndHeight(g.dims,a.TextureType.unpacked),O=g.dims.length;if(_<1||y<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1||w.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==_||w[0]!==_)throw new Error("Shape of the intermediate results should be equal to logical row count");const x=`
      float process(int[${O}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${M}, ${S});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${y};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},c),{output:{dims:g.dims,type:g.type,textureType:a.TextureType.unpacked},shaderSource:x})},m=b=>{if(!b||b.length!==1)throw new Error("Softmax requires 1 input.");if(b[0].type!=="float32"&&b[0].type!=="float64")throw new Error("Invalid input type")}},5975:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const r=i(246),o=i(2517),l=i(2039),a={name:"Split",inputNames:["A"],inputTypes:[l.TextureType.unpacked]};t.split=(c,n,e)=>{h(n);const s=o.ShapeUtil.normalizeAxis(e.axis,n[0].dims.length),u=f(c,n,s,e),m=[];for(let b=0;b<u;++b)m.push(c.run(Object.assign(Object.assign({},a),{cacheHint:`${e.cacheKey};${b}`,get:()=>p(c,n[0],e,s,b)}),n));return m},t.parseSplitAttributes=c=>{const n=c.attributes.getInt("axis",0),e=c.attributes.getInts("split",[]),s=c.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:n,split:e,numOutputs:s})};const f=(c,n,e,s)=>{const[,u]=o.SplitUtil.splitShape(n[0].dims,e,s.split,s.numOutputs);return u.length},p=(c,n,e,s,u)=>{const[m,b]=o.SplitUtil.splitShape(n.dims,s,e.split,e.numOutputs),g=b[u],_=m[u],y=`
      float process(int indices[${_.length}]) {
        indices[${s}] += ${g};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},a),{cacheHint:`${e.cacheKey}:${u}`,output:{dims:_,type:n.type,textureType:l.TextureType.unpacked},shaderSource:y})},h=c=>{if(!c||c.length!==1)throw new Error("Split requires one input.");if(c[0].type!=="int8"&&c[0].type!=="uint8"&&c[0].type!=="int16"&&c[0].type!=="uint16"&&c[0].type!=="int32"&&c[0].type!=="uint32"&&c[0].type!=="float32"&&c[0].type!=="float64"&&c[0].type!=="bool")throw new Error("Invalid input type.")}},3933:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSqueezeAttributes=t.squeezeV13=t.squeeze=void 0;const r=i(2517);t.squeeze=(a,f,p)=>{o(f);const h=r.ShapeUtil.squeezeShape(f[0].dims,p);return[a.reshapeUnpacked(f[0],h)]},t.squeezeV13=(a,f)=>(l(f),(0,t.squeeze)(a,[f[0]],Array.from(f[1].integerData))),t.parseSqueezeAttributes=a=>a.attributes.getInts("axes");const o=a=>{if(!a||a.length!==1)throw new Error("Squeeze requires 1 input.");if(a[0].type==="string")throw new Error("invalid input tensor types.")},l=a=>{if(!a||a.length!==2)throw new Error("Squeeze requires 2 inputs.");if(a[1].type!=="int32")throw new Error("Invalid input type.")}},6558:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sum=void 0;const r=i(5060),o=i(2039);t.sum=(f,p)=>{a(p);const h={name:"Sum",inputNames:p.map((c,n)=>`X${n}`),inputTypes:new Array(p.length).fill(o.TextureType.unpacked)};return[f.run(Object.assign(Object.assign({},h),{get:()=>l(f,p,h)}),p)]};const l=(f,p,h)=>{const c=(0,r.getGlsl)(f.session.backend.glContext.version),n=p[0].dims.slice(),e=`
      void main() {
        vec4 result = ${p.map((s,u)=>`${c.texture2D}(X${u},TexCoords)`).join(" + ")};
        ${c.output} = result;
      }
    `;return Object.assign(Object.assign({},h),{output:{dims:n,type:p[0].type,textureType:o.TextureType.unpacked},hasMain:!0,shaderSource:e})},a=f=>{if(!f||f.length===0)throw new Error("Sum requires inputs.");const p=f[0].dims.length;for(let h=1;h<f.length;h++){if(p!==f[h].dims.length)throw new Error("Input shapes are mismatched.");for(let c=0;c<p;c++)if(f[0].dims[c]!==f[h].dims[c])throw new Error("Input shapes are not matched.")}if(f[0].type!=="float32"&&f[0].type!=="float64")throw new Error("Invalid input type.");for(let h=1;h<f.length;h++)if(f[0].type!==f[h].type)throw new Error("Input types are not matched.")}},5723:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.tile=void 0;const r=i(782),o=i(2039);t.tile=(f,p)=>{a(p);const h={name:"Tile",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};return[f.run(Object.assign(Object.assign({},h),{get:()=>l(f,p,h)}),p)]};const l=(f,p,h)=>{const c=p[0].dims.slice(),n=new Array(c.length),e=[];for(let m=0;m<c.length;m++)n[m]=c[m]*p[1].numberData[m],e.push(`inputIdx[${m}] = int(mod(float(outputIdx[${m}]), ${c[m]}.));`);const s=n.length,u=`
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${e.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},h),{output:{dims:n,type:p[0].type,textureType:o.TextureType.unpacked},shaderSource:u})},a=f=>{if(!f||f.length!==2)throw new Error("Tile requires 2 input.");if(f[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(f[1].dims[0]!==f[0].dims.length)throw new Error("Invalid input shape.");if(r.NUMBER_TYPES.indexOf(f[0].type)===-1)throw new Error("Invalid input type.");if(f[1].type!=="int32"&&f[1].type!=="int16")throw new Error("Invalid repeat type.")}},3738:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=void 0;const r=i(246),o=i(2517),l=i(2039),a={name:"Transpose",inputNames:["A"],inputTypes:[l.TextureType.unpacked]};t.transpose=(e,s,u)=>(n(s),[e.run(Object.assign(Object.assign({},a),{cacheHint:u.cacheKey,get:()=>f(e,s[0],u.perm)}),s)]),t.parseTransposeAttributes=e=>(0,r.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});const f=(e,s,u)=>{const m=s.dims;u=p(m,u);const b=h(m,u),g=m.length,_=`
      ${c("perm",u,g)}
      float process(int indices[${g}]) {
        int a[${g}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},a),{output:{dims:b,type:s.type,textureType:l.TextureType.unpacked},shaderSource:_})},p=(e,s)=>(s&&s.length!==e.length&&(s=[...e.keys()].reverse()),s),h=(e,s)=>(s=p(e,s),o.ShapeUtil.sortBasedOnPerm(e,s)),c=(e,s,u)=>{const m=[];m.push(`void ${e}(out int a[${u}], int src[${u}]) {`);for(let b=0;b<u;++b)m.push(`	a[${s[b]}]=src[${b}];`);return m.push("	}"),m.join(`
`)},n=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}},8710:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.encodeAsUint8=void 0;const r=i(5060),o=i(2039);t.encodeAsUint8=(l,a)=>{const f=a.shape,p=(0,r.getGlsl)(l.session.backend.glContext.version),h=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${p.texture2D}(X,TexCoords).r;
      ${p.output} = encodeAsUint8(value);
    }`,c={name:"Uint8Encode",inputTypes:[o.TextureType.unpacked],inputNames:["X"],output:{dims:f,type:a.tensor.type,textureType:o.TextureType.downloadUint8AsFloat},shaderSource:h,hasMain:!0};return l.executeProgram(c,[a.tensor])}},4909:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.tanh=t.tan=t.sqrt=t.sin=t.sigmoid=t.relu=t.not=t.neg=t.log=t.parseLeakyReluAttributes=t.leakyRelu=t.identity=t.floor=t.exp=t.parseEluAttributes=t.elu=t.cos=t.ceil=t.clipV11=t.parseClipAttributes=t.clip=t.atan=t.asin=t.acos=t.abs=t.glslTanh=t.glslTan=t.glslSqrt=t.glslSigmoid=t.glslRelu=t.glslSin=t.glslNot=t.glslNeg=t.glslLog=t.glslLeakyRelu=t.glslIdentity=t.glslClip=t.glslFloor=t.glslExp=t.glslElu=t.glslCos=t.glslCeil=t.glslAtan=t.glslAsin=t.glslAcos=t.glslAbs=void 0;const r=i(246),o=i(2517),l=i(8520),a=i(5060),f=i(2039);function p(){return C("abs")}function h(){return C("acos")}function c(){return C("asin")}function n(){return C("atan")}function e(){return C("ceil")}function s(){return C("cos")}function u(k){const R="elu";return{body:`
  const float alpha = float(${k});

  float ${R}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${R}_(vec4 v) {
    return vec4(${R}_(v.x), ${R}_(v.y), ${R}_(v.z), ${R}_(v.w));
  }
  `,name:R,type:l.FunctionType.ValueBased}}function m(){return C("exp")}function b(){return C("floor")}function g(k,R){const X="clip";return{body:`
  const float min = float(${k});
  const float max = float(${R});

  float ${X}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${X}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:X,type:l.FunctionType.ValueBased}}function _(){const k="indentity";return{body:`
  float ${k}_(float a) {
    return a;
  }
  vec4 ${k}_(vec4 v) {
    return v;
  }
  `,name:k,type:l.FunctionType.ValueBased}}function y(k){const R="leakyRelu";return{body:`
  const float alpha = float(${k});

  float ${R}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${R}_(vec4 v) {
    return vec4(${R}_(v.x), ${R}_(v.y), ${R}_(v.z), ${R}_(v.w));
  }
  `,name:R,type:l.FunctionType.ValueBased}}function v(){return C("log")}function w(){const k="neg";return{body:`
  float ${k}_(float a) {
    return -a;
  }
  vec4 ${k}_(vec4 v) {
    return -v;
  }
  `,name:k,type:l.FunctionType.ValueBased}}function M(){const k="not";return{body:`
  float ${k}_(float a) {
    return float( ! bool(a) );
  }
  bool ${k}_(bool a) {
    return !a;
  }
  vec4 ${k}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${k}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:k,type:l.FunctionType.ValueBased}}function S(){return C("sin")}function O(){const k="relu";return{body:`
  float ${k}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${k}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:k,type:l.FunctionType.ValueBased}}function x(){const k="sigmoid";return{body:`
  float ${k}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${k}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:k,type:l.FunctionType.ValueBased}}function T(){return C("sqrt")}function I(){return C("tan")}function F(){const k="tanh";return{body:`
  float ${k}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${k}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:k,type:l.FunctionType.ValueBased}}function C(k){return{body:`
  float ${k}_(float a) {
    return ${k}(a);
  }
  vec4 ${k}_(vec4 v) {
    return ${k}(v);
  }
  `,name:k,type:l.FunctionType.ValueBased}}t.glslAbs=p,t.glslAcos=h,t.glslAsin=c,t.glslAtan=n,t.glslCeil=e,t.glslCos=s,t.glslElu=u,t.glslExp=m,t.glslFloor=b,t.glslClip=g,t.glslIdentity=_,t.glslLeakyRelu=y,t.glslLog=v,t.glslNeg=w,t.glslNot=M,t.glslSin=S,t.glslRelu=O,t.glslSigmoid=x,t.glslSqrt=T,t.glslTan=I,t.glslTanh=F;const N=(k,R,X,U)=>{const K=k.session.pack?f.TextureType.packed:f.TextureType.unpacked,Q={name:X.name,inputTypes:[K],inputNames:["A"],cacheHint:U};return Object.assign(Object.assign({},Q),{get:()=>((se,te,ae,ne)=>{const ce=se.session.pack?f.TextureType.packed:f.TextureType.unpacked,oe=(0,a.getGlsl)(se.session.backend.glContext.version);return Object.assign(Object.assign({},te),{output:{dims:ae.dims,type:ae.type,textureType:ce},shaderSource:`
     ${ne.body}
     void main() {
       vec4 v = ${oe.texture2D}(A, TexCoords);
       v = ${ne.name}_(v);
       ${oe.output} = v;
     }
     `,hasMain:!0})})(k,Q,R,X)})};t.abs=(k,R)=>[k.run(N(k,R[0],p()),R)],t.acos=(k,R)=>[k.run(N(k,R[0],h()),R)],t.asin=(k,R)=>[k.run(N(k,R[0],c()),R)],t.atan=(k,R)=>[k.run(N(k,R[0],n()),R)],t.clip=(k,R,X)=>[k.run(N(k,R[0],g(X.min,X.max),X.cacheKey),R)],t.parseClipAttributes=k=>(0,r.createAttributeWithCacheKey)({min:k.attributes.getFloat("min",o.MIN_CLIP),max:k.attributes.getFloat("max",o.MAX_CLIP)}),t.clipV11=(k,R)=>{const X=B(k,R);return(0,t.clip)(k,[R[0]],X)};const B=(k,R)=>{if(R.length>=3&&(!k.session.isInitializer(R[1].dataId)||!k.session.isInitializer(R[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const X=R.length>=3?R[1].numberData[0]:o.MIN_CLIP,U=R.length>=3?R[2].numberData[0]:o.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:X,max:U})};t.ceil=(k,R)=>[k.run(N(k,R[0],e()),R)],t.cos=(k,R)=>[k.run(N(k,R[0],s()),R)],t.elu=(k,R,X)=>[k.run(N(k,R[0],u(X.alpha),X.cacheKey),R)],t.parseEluAttributes=k=>(0,r.createAttributeWithCacheKey)({alpha:k.attributes.getFloat("alpha",1)}),t.exp=(k,R)=>[k.run(N(k,R[0],m()),R)],t.floor=(k,R)=>[k.run(N(k,R[0],b()),R)],t.identity=(k,R)=>[k.run(N(k,R[0],_()),R)],t.leakyRelu=(k,R,X)=>[k.run(N(k,R[0],y(X.alpha),X.cacheKey),R)],t.parseLeakyReluAttributes=k=>(0,r.createAttributeWithCacheKey)({alpha:k.attributes.getFloat("alpha",.01)}),t.log=(k,R)=>[k.run(N(k,R[0],v()),R)],t.neg=(k,R)=>[k.run(N(k,R[0],w()),R)],t.not=(k,R)=>[k.run(N(k,R[0],M()),R)],t.relu=(k,R)=>[k.run(N(k,R[0],O()),R)],t.sigmoid=(k,R)=>[k.run(N(k,R[0],x()),R)],t.sin=(k,R)=>[k.run(N(k,R[0],S()),R)],t.sqrt=(k,R)=>[k.run(N(k,R[0],T()),R)],t.tan=(k,R)=>[k.run(N(k,R[0],I()),R)],t.tanh=(k,R)=>[k.run(N(k,R[0],F()),R)]},5611:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackProgramInfoLoader=t.createUnpackProgramInfo=void 0;const r=i(5060),o=i(2039),l=i(9390),a=i(2827),f={name:"unpack",inputNames:["A"],inputTypes:[o.TextureType.packed]};t.createUnpackProgramInfo=(p,h)=>{const c=h.dims.length,n=(0,a.getChannels)("rc",c),e=n.slice(-2),s=(0,l.getCoordsDataType)(c),u=(0,a.unpackFromChannel)(),m=h.dims.length===0?"":function(_,y){if(_===1)return"rc";let v="";for(let w=0;w<_;w++)v+=y[w],w<_-1&&(v+=",");return v}(c,n),b=c<=1?"rc":`vec2(${e.join(",")})`,g=`
    ${u}
    void main() {
      ${s} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${m});

       ${(0,r.getGlsl)(p.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${b}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},f),{hasMain:!0,output:{dims:h.dims,type:h.type,textureType:o.TextureType.unpacked},shaderSource:g})},t.createUnpackProgramInfoLoader=(p,h)=>Object.assign(Object.assign({},f),{get:()=>(0,t.createUnpackProgramInfo)(p,h)})},8428:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseUnsqueezeAttributes=t.unsqueezeV13=t.unsqueeze=void 0;const r=i(2517);t.unsqueeze=(a,f,p)=>{o(f);const h=r.ShapeUtil.unsqueezeShape(f[0].dims,p);return[a.reshapeUnpacked(f[0],h)]},t.unsqueezeV13=(a,f)=>(l(f),(0,t.unsqueeze)(a,[f[0]],Array.from(f[1].integerData))),t.parseUnsqueezeAttributes=a=>a.attributes.getInts("axes");const o=a=>{if(!a||a.length!==1)throw new Error("Unsqueeze requires 1 input.");if(a[0].type==="string")throw new Error("invalid input tensor types.")},l=a=>{if(!a||a.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(a[1].type!=="int32")throw new Error("Invalid input type.")}},9793:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.scalesValidation=t.validateInputs=t.parseUpsampleAttributes=t.parseUpsampleAttributesV9=t.parseUpsampleAttributesV7=t.upsample=void 0;const r=i(246),o=i(5060),l=i(2039),a={name:"Upsample",inputNames:["X"],inputTypes:[l.TextureType.unpacked]};t.upsample=(p,h,c)=>((0,t.validateInputs)(h,c),[p.run(Object.assign(Object.assign({},a),{cacheHint:c.cacheKey,get:()=>f(p,h,c)}),h)]),t.parseUpsampleAttributesV7=p=>(0,t.parseUpsampleAttributes)(p,7),t.parseUpsampleAttributesV9=p=>(0,t.parseUpsampleAttributes)(p,9),t.parseUpsampleAttributes=(p,h)=>{const c=h>=10,n=p.attributes.getString("mode","nearest");if(n!=="nearest"&&n!=="linear"&&(h<11||n!=="cubic"))throw new Error(`unrecognized mode: ${n}`);let e=[];h<9&&(e=p.attributes.getFloats("scales"),(0,t.scalesValidation)(e,n,c));const s=p.attributes.getFloat("extrapolation_value",0),u=h>10?p.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(u)===-1)throw new Error(`coordinate_transform_mode '${u}' is not supported`);const m=u==="tf_crop_and_resize",b=m,g=n==="nearest"&&h>=11?p.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(g)===-1)throw new Error(`nearest_mode '${g}' is not supported`);const _=p.attributes.getFloat("cubic_coeff_a",-.75),y=p.attributes.getInt("exclude_outside",0)!==0;if(y&&n!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const v=h<11||n==="nearest"&&u==="asymmetric"&&g==="floor";let w=0,M=0,S=0;return h>10?p.inputs.length>2?(w=1,M=2,S=3):(M=1,S=2):h===9&&(M=1),(0,r.createAttributeWithCacheKey)({opset:h,isResize:c,mode:n,scales:e,extrapolationValue:s,coordinateTransformMode:u,useExtrapolation:b,needRoiInput:m,nearestMode:g,cubicCoefficientA:_,excludeOutside:y,useNearest2xOptimization:v,roiInputIdx:w,scalesInputIdx:M,sizesInputIdx:S})};const f=(p,h,c)=>{const n=(0,o.getGlsl)(p.session.backend.glContext.version),[e,s]=p.calculateTextureWidthAndHeight(h[0].dims,l.TextureType.unpacked),u=h[0].dims.map((S,O)=>Math.floor(S*c.scales[O])),[m,b]=p.calculateTextureWidthAndHeight(u,l.TextureType.unpacked),g=u.length,_=new Array(g),y=new Array(g);let v=`
      int output_pitches[${g}];
      int input_pitches[${g}];
      `;for(let S=g-1;S>=0;S--)_[S]=S===g-1?1:_[S+1]*u[S+1],y[S]=S===g-1?1:y[S+1]*h[0].dims[S+1],v+=`
        output_pitches[${S}] = ${_[S]};
        input_pitches[${S}] = ${y[S]};
        `;const w=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${e}, ${s});
        float value = getColorAsFloat(${n.texture2D}(X, coords));
        return value;
      }
      `,M=c.mode==="nearest"?`
    ${w}
    float process(int indices[${g}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${m}, ${b});

      ${v}

      int d, m;
      for (int dim = 0; dim < ${g}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:g===4?`
    ${w}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${m}, ${b});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${h[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${w}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${m}, ${b});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${h[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},a),{output:{dims:u,type:h[0].type,textureType:l.TextureType.unpacked},shaderSource:M,variables:[{name:"scales",type:"int",arrayLength:c.scales.length,data:c.scales.map(S=>Math.ceil(S))}]})};t.validateInputs=(p,h)=>{if(!p||h.opset<9&&p.length!==1||h.opset>=9&&h.opset<11&&p.length!==2||h.opset>=11&&p.length<2)throw new Error("invalid inputs.");if(h.scales.length>0&&p[0].dims.length!==h.scales.length)throw new Error("Invalid input shape.");if(p[0].type==="string")throw new Error("Invalid input tensor types.")},t.scalesValidation=(p,h,c)=>{if(c){for(const n of p)if(n<=0)throw new Error("Scale value should be greater than 0.")}else for(const n of p)if(n<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(h!=="linear"&&h!=="cubic"||p.length===2||p.length===4&&p[0]===1&&p[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${c?"Resize":"Upsample"} opeartor.`)}},1958:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=i(1670),o=i(6231),l=i(8879),a=i(5060);t.ProgramManager=class{constructor(f,p,h){this.profiler=f,this.glContext=p,this.textureLayoutStrategy=h,this.repo=new Map,this.attributesBound=!1}getArtifact(f){return this.repo.get(f)}setArtifact(f,p){this.repo.set(f,p)}run(f,p,h){var c;this.profiler.event("op",`ProgramManager.run ${(c=f.programInfo.name)!==null&&c!==void 0?c:"unknown kernel"}`,()=>{var n;const e=this.glContext.gl,s=f.program;e.useProgram(s);try{this.bindOutput(h),this.attributesBound||this.bindAttributes(f.attribLocations),this.bindUniforms(f.uniformLocations,(n=f.programInfo.variables)!==null&&n!==void 0?n:[],p)}catch(u){throw o.Logger.error("ProgramManager",f.programInfo.shaderSource),u}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(f=>this.glContext.deleteProgram(f.program))}build(f,p,h){return this.profiler.event("backend","ProgramManager.build",()=>{const c=new l.GlslPreprocessor(this.glContext,f,p,h),n=c.preprocess(),e=this.compile(n);return{programInfo:f,program:e,uniformLocations:this.getUniformLocations(e,c.context.programInfo.inputNames,c.context.programInfo.variables),attribLocations:this.getAttribLocations(e)}})}compile(f){if(!this.vertexShader){o.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const c=(0,a.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(c,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&o.Logger.verbose("ProrgramManager",`FragShader:
${f}
`);const p=this.glContext.compileShader(f,this.glContext.gl.FRAGMENT_SHADER),h=this.glContext.createProgram(this.vertexShader,p);return this.glContext.deleteShader(p),h}bindOutput(f){const p=f.width,h=f.height;o.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${p}/${h}, shape=${f.shape}, type=${f.tensor.type}`),this.glContext.attachFramebuffer(f.texture,p,h)}bindAttributes(f){const p=f.position,h=f.textureCoord;this.glContext.setVertexAttributes(p,h),this.attributesBound=!0}bindUniforms(f,p,h){var c;const n=this.glContext.gl;let e=0;for(const{name:s,type:u,location:m,arrayLength:b}of f){const g=(c=p.find(_=>_.name===s))===null||c===void 0?void 0:c.data;if(u!=="sampler2D"&&!g)throw new Error(`variable '${s}' does not have data defined in program info`);switch(u){case"sampler2D":this.bindTexture(h[e],m,e),e++;break;case"float":b?n.uniform1fv(m,g):n.uniform1f(m,g);break;case"int":b?n.uniform1iv(m,g):n.uniform1i(m,g);break;default:throw new Error(`Uniform not implemented: ${u}`)}}}bindTexture(f,p,h){this.glContext.bindTextureToUniform(f.texture,h,p)}getAttribLocations(f){return{position:this.getAttribLocation(f,"position"),textureCoord:this.getAttribLocation(f,"textureCoord")}}getUniformLocations(f,p,h){const c=[];if(p)for(const n of p)c.push({name:n,type:"sampler2D",location:this.getUniformLocation(f,n)});if(h)for(const n of h)c.push(Object.assign(Object.assign({},n),{location:this.getUniformLocation(f,n.name)}));return c}getUniformLocation(f,p){const h=this.glContext.gl.getUniformLocation(f,p);if(h===null)throw new Error(`Uniform ${p} not found.`);return h}getAttribLocation(f,p){return this.glContext.gl.getAttribLocation(f,p)}}},6416:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLSessionHandler=void 0;const r=i(6231),o=i(1047),l=i(8316),a=i(1640),f=i(1958),p=i(7859),h=i(5702);t.WebGLSessionHandler=class{constructor(c,n){this.backend=c,this.context=n,this.layoutStrategy=new p.PreferLogicalStrategy(c.glContext.maxTextureSize),this.programManager=new f.ProgramManager(this.context.profiler,c.glContext,this.layoutStrategy),this.textureManager=new h.TextureManager(c.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:c.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=c.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new l.WebGLInferenceHandler(this)}onGraphInitialized(c){const n=c.getValues().filter(e=>e.from===-1&&e.tensor).map(e=>e.tensor.dataId);this.initializers=new Set(n)}isInitializer(c){return!!this.initializers&&this.initializers.has(c)}addInitializer(c){this.initializers.add(c)}getTextureData(c,n){return n?this.packedTextureDataCache.get(c):this.unpackedTextureDataCache.get(c)}setTextureData(c,n,e=!1){r.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),e?this.packedTextureDataCache.set(c,n):this.unpackedTextureDataCache.set(c,n)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(c=>this.textureManager.releaseTexture(c,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(c=>this.textureManager.releaseTexture(c,!0)),this.unpackedTextureDataCache=new Map}resolve(c,n,e){const s=(0,o.resolveOperator)(c,n,a.WEBGL_OP_RESOLVE_RULES);return{impl:s.opImpl,context:s.opInit?s.opInit(c,e):c}}}},7769:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Uint8DataEncoder=t.RGBAFloatDataEncoder=t.RedFloat32DataEncoder=void 0;const r=i(6231);t.RedFloat32DataEncoder=class{constructor(o,l=1){if(l===1)this.internalFormat=o.R32F,this.format=o.RED,this.textureType=o.FLOAT,this.channelSize=l;else{if(l!==4)throw new Error(`Invalid number of channels: ${l}`);this.internalFormat=o.RGBA32F,this.format=o.RGBA,this.textureType=o.FLOAT,this.channelSize=l}}encode(o,l){let a,f;return o.constructor!==Float32Array&&(r.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),f=new Float32Array(o)),l*this.channelSize>o.length?(r.Logger.warning("Encoder","Source data too small. Allocating larger array"),f=o,a=this.allocate(l*this.channelSize),f.forEach((p,h)=>a[h]=p)):(f=o,a=f),a}allocate(o){return new Float32Array(4*o)}decode(o,l){return this.channelSize===1?o.filter((a,f)=>f%4==0).subarray(0,l):o.subarray(0,l)}},t.RGBAFloatDataEncoder=class{constructor(o,l=1,a){if(l!==1&&l!==4)throw new Error(`Invalid number of channels: ${l}`);this.internalFormat=o.RGBA,this.format=o.RGBA,this.channelSize=l,this.textureType=a||o.FLOAT}encode(o,l){let a=o;return this.channelSize===1&&(r.Logger.verbose("Encoder","Exploding into a larger array"),a=this.allocate(l),o.forEach((f,p)=>a[4*p]=f)),a}allocate(o){return new Float32Array(4*o)}decode(o,l){return this.channelSize===1?o.filter((a,f)=>f%4==0).subarray(0,l):o.subarray(0,l)}},t.Uint8DataEncoder=class{constructor(o,l=1){if(this.channelSize=4,l===1)this.internalFormat=o.ALPHA,this.format=o.ALPHA,this.textureType=o.UNSIGNED_BYTE,this.channelSize=l;else{if(l!==4)throw new Error(`Invalid number of channels: ${l}`);this.internalFormat=o.RGBA,this.format=o.RGBA,this.textureType=o.UNSIGNED_BYTE,this.channelSize=l}}encode(o,l){return new Uint8Array(o.buffer,o.byteOffset,o.byteLength)}allocate(o){return new Uint8Array(o*this.channelSize)}decode(o,l){if(o instanceof Uint8Array)return o.subarray(0,l);throw new Error(`Invalid array type: ${o.constructor}`)}}},7859:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getBatchDim=t.sizeToSquarishShape=t.getRowsCols=t.sizeFromShape=t.isInt=t.parseAxisParam=t.squeezeShape=t.PreferLogicalStrategy=t.AlwaysKeepOriginalSizeStrategy=void 0;const r=i(6231),o=i(2517);function l(c,n){const e=[],s=[],u=n!=null&&Array.isArray(n)&&n.length===0,m=n==null||u?null:a(n,c).sort();let b=0;for(let g=0;g<c.length;++g){if(m!=null){if(m[b]===g&&c[g]!==1)throw new Error(`Can't squeeze axis ${g} since its dim '${c[g]}' is not 1`);(m[b]==null||m[b]>g)&&c[g]===1&&(e.push(c[g]),s.push(g)),m[b]<=g&&b++}c[g]!==1&&(e.push(c[g]),s.push(g))}return{newShape:e,keptDims:s}}function a(c,n){const e=n.length;return c=c==null?n.map((s,u)=>u):[].concat(c),(0,o.assert)(c.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${c}`),(0,o.assert)(c.every(f),()=>`All values in axis param must be integers but got axis ${c}`),c.map(s=>s<0?e+s:s)}function f(c){return c%1==0}function p(c){if(c.length===0)return 1;let n=c[0];for(let e=1;e<c.length;e++)n*=c[e];return n}function h(c){const n=Math.ceil(Math.sqrt(c));return[n,Math.ceil(c/n)]}t.AlwaysKeepOriginalSizeStrategy=class{constructor(c){this.maxTextureSize=c}computeTextureWH(c,n){if(c.length===0)return[1,1];const e=this.maxTextureSize;if(n&&n.breakAxis!==void 0){const m=n.breakAxis>=c.length?1:c.slice(n.breakAxis).reduce((g,_)=>g*_),b=n.breakAxis<=0?1:c.slice(0,n.breakAxis).reduce((g,_)=>g*_);if(!(m>e||b>e))return[m,b];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${c}, breakAxis:${n.breakAxis}`)}const s=c.reduce((m,b)=>m*b);let u=Math.floor(Math.sqrt(s));for(;u<e&&u<s&&s%u!=0;u++);if(u>=e||s%u!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${c}`);return[u,s/u]}},t.PreferLogicalStrategy=class{constructor(c){this.maxTextureSize=c}computeTextureWH(c,n){const e=this.computeTexture(c,n);return n&&n.isPacked&&(e[0]/=2,e[1]/=2),n&&n.reverseWH?[e[1],e[0]]:e}computeTexture(c,n){const e=n&&n.isPacked;if(c.length===0)return e?[2,2]:[1,1];let s=this.maxTextureSize;if(n&&n.breakAxis!==void 0){const b=n.breakAxis>=c.length?1:c.slice(n.breakAxis).reduce((_,y)=>_*y),g=n.breakAxis<=0?1:c.slice(0,n.breakAxis).reduce((_,y)=>_*y);if(!(b>s||g>s))return[b,g];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${c}, breakAxis:${n.breakAxis}`)}let u=c.slice(0);e&&(s*=2,u=u.map((b,g)=>g>=u.length-2?u[g]%2==0?u[g]:u[g]+1:u[g]),u.length===1&&(u=[2,u[0]])),u.length!==2&&(u=l(u).newShape);const m=p(u);return u.length<=1&&m<=s?[1,m]:u.length===2&&u[0]<=s&&u[1]<=s?u:u.length===3&&u[0]*u[1]<=s&&u[2]<=s?[u[0]*u[1],u[2]]:u.length===3&&u[0]<=s&&u[1]*u[2]<=s?[u[0],u[1]*u[2]]:u.length===4&&u[0]*u[1]*u[2]<=s&&u[3]<=s?[u[0]*u[1]*u[2],u[3]]:u.length===4&&u[0]<=s&&u[1]*u[2]*u[3]<=s?[u[0],u[1]*u[2]*u[3]]:e?h(m/4).map(b=>2*b):h(m)}},t.squeezeShape=l,t.parseAxisParam=a,t.isInt=f,t.sizeFromShape=p,t.getRowsCols=function(c){if(c.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[c.length>1?c[c.length-2]:1,c[c.length-1]]},t.sizeToSquarishShape=h,t.getBatchDim=function(c,n=2){return p(c.slice(0,c.length-n))}},4057:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createTextureLayoutFromShape=t.calculateTextureWidthAndHeight=t.createTextureLayoutFromTextureType=void 0;const r=i(2517),o=i(2039);t.createTextureLayoutFromTextureType=(l,a,f)=>{const p=f===o.TextureType.unpacked||f===o.TextureType.unpackedReversed?1:4,h=f===o.TextureType.packed,c=f===o.TextureType.unpackedReversed||f===o.TextureType.packed,n=f===o.TextureType.packedLastDimension?a.length-1:void 0,e=f===o.TextureType.packedLastDimension?a.map((s,u)=>u===a.length-1?4*s:s):void 0;return(0,t.createTextureLayoutFromShape)(l,a,p,e,{isPacked:h,reverseWH:c,breakAxis:n})},t.calculateTextureWidthAndHeight=(l,a,f)=>{const p=(0,t.createTextureLayoutFromTextureType)(l,a,f);return[p.width,p.height]},t.createTextureLayoutFromShape=(l,a,f=1,p,h)=>{const c=!(!h||!h.isPacked),[n,e]=l.computeTextureWH(c&&p||a,h),s=a.length;let u=a.slice(0);if(s===0&&(u=[1]),f===1)p=a;else if(c){if(f!==4)throw new Error("a packed texture must be 4-channel");p=a,s>0&&(u[s-1]=Math.ceil(u[s-1]/2)),s>1&&(u[s-2]=Math.ceil(u[s-2]/2))}else if(!p)throw new Error("Unpacked shape is needed when using channels > 1");return{width:n,height:e,channels:f,isPacked:c,shape:u,strides:r.ShapeUtil.computeStrides(u),unpackedShape:p,reversedWH:h&&h.reverseWH}}},5702:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TextureManager=void 0;const r=i(6231);t.TextureManager=class{constructor(o,l,a,f){this.glContext=o,this.layoutStrategy=l,this.profiler=a,this.config=f,this.pendingRead=new Map,f.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(o,l,a,f){const p=this.toEncoderType(o),h=this.glContext.getEncoder(p,l.channels||1,f);if(l.isPacked&&f===1)throw new Error("not implemented");const c=l.width,n=l.height;let e,s;if(this.config.reuseTextures){e=`${c}x${n}_${h.format}_${h.internalFormat}_${h.textureType}`,s=this.inUseTextures.get(e),s||(s=[],this.inUseTextures.set(e,s));const m=this.idleTextures.get(e);if(m&&m.length>0){const b=m.pop();return s.push(b),f===1&&this.glContext.updateTexture(b,c,n,h,this.toTextureData(o,a)),b}}r.Logger.verbose("TextureManager",`Creating new texture of size ${l.width}x${l.height}`);const u=this.glContext.allocateTexture(c,n,h,this.toTextureData(o,a));return this.config.reuseTextures&&(s.push(u),this.textureLookup.set(u,e)),u}readTexture(o,l,a){return a||(a=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const f=o.shape.reduce((h,c)=>h*c)*a,p=this.glContext.readTexture(o.texture,o.width,o.height,f,this.toEncoderType(l),a);return this.toTensorData(l,p)})}async readTextureAsync(o,l,a){const f=o.tensor.dataId;if(a||(a=1),this.pendingRead.has(f)){const p=this.pendingRead.get(f);return new Promise(h=>p==null?void 0:p.push(h))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(f,[]);const p=o.shape.reduce((e,s)=>e*s)*a;await this.glContext.createAndWaitForFence();const h=this.glContext.readTexture(o.texture,o.width,o.height,p,this.toEncoderType(l),a),c=this.toTensorData(l,h),n=this.pendingRead.get(f);return this.pendingRead.delete(f),n==null||n.forEach(e=>e(c)),c})}readUint8TextureAsFloat(o){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const l=o.shape.reduce((f,p)=>f*p),a=this.glContext.readTexture(o.texture,o.width,o.height,4*l,"byte",4);return new Float32Array(a.buffer,a.byteOffset,l)})}releaseTexture(o,l){let a;if(this.config.reuseTextures&&(a=this.textureLookup.get(o.texture),a)){l&&this.textureLookup.delete(a);const f=this.inUseTextures.get(a);if(f){const p=f.indexOf(o.texture);if(p!==-1){f.splice(p,1);let h=this.idleTextures.get(a);h||(h=[],this.idleTextures.set(a,h)),h.push(o.texture)}}}a&&!l||(r.Logger.verbose("TextureManager",`Deleting texture of size ${o.width}x${o.height}`),this.glContext.deleteTexture(o.texture))}toTensorData(o,l){switch(o){case"int16":return l instanceof Int16Array?l:Int16Array.from(l);case"int32":return l instanceof Int32Array?l:Int32Array.from(l);case"int8":return l instanceof Int8Array?l:Int8Array.from(l);case"uint16":return l instanceof Uint16Array?l:Uint16Array.from(l);case"uint32":return l instanceof Uint32Array?l:Uint32Array.from(l);case"uint8":case"bool":return l instanceof Uint8Array?l:Uint8Array.from(l);case"float32":return l instanceof Float32Array?l:Float32Array.from(l);case"float64":return l instanceof Float64Array?l:Float64Array.from(l);default:throw new Error(`TensorData type ${o} is not supported`)}}toTextureData(o,l){if(l)return l instanceof Float32Array?l:new Float32Array(l)}toEncoderType(o){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(d,t)=>{var i;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureType=void 0,(i=t.TextureType||(t.TextureType={}))[i.unpacked=0]="unpacked",i[i.unpackedReversed=1]="unpackedReversed",i[i.packed=2]="packed",i[i.downloadUint8AsFloat=3]="downloadUint8AsFloat",i[i.packedLastDimension=4]="packedLastDimension"},9390:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getGlChannels=t.getCoordsDataType=t.getSqueezedParams=t.squeezeInputShape=t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=t.generateShaderFuncNameFromInputSamplerName=t.repeatedTry=t.getPackedShape=void 0;const r=i(2517);t.getPackedShape=function(o){const l=o.length;return o.slice(0,l-1).concat(o[l-1]/4)},t.repeatedTry=async function(o,l=f=>0,a){return new Promise((f,p)=>{let h=0;const c=()=>{if(o())return void f();h++;const n=l(h);a!=null&&h>=a?p():setTimeout(c,n)};c()})},t.generateShaderFuncNameFromInputSamplerName=function(o){return(0,r.assert)(o!==void 0&&o.length!==0,()=>"empty string found for sampler name"),"get"+o.charAt(0).toUpperCase()+o.slice(1)},t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(o){return(0,r.assert)(o!==void 0&&o.length!==0,()=>"empty string found for sampler name"),"get"+o.charAt(0).toUpperCase()+o.slice(1)+"AtOutCoords"},t.squeezeInputShape=function(o,l){let a=JSON.parse(JSON.stringify(o));return a=l,a},t.getSqueezedParams=function(o,l){return l.map(a=>o[a]).join(", ")},t.getCoordsDataType=function(o){if(o<=1)return"int";if(o===2)return"ivec2";if(o===3)return"ivec3";if(o===4)return"ivec4";if(o===5)return"ivec5";if(o===6)return"ivec6";throw Error(`GPU for rank ${o} is not yet supported`)},t.getGlChannels=function(o=6){return["x","y","z","w","u","v"].slice(0,o)}},7305:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createNewWebGLContext=t.createWebGLContext=void 0;const r=i(6231),o=i(1713),l={};function a(f){const p=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const n=document.createElement("canvas");return n.width=1,n.height=1,n}();let h;const c={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!f||f==="webgl2")&&(h=p.getContext("webgl2",c),h))try{return new o.WebGLContext(h,2)}catch(n){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!f||f==="webgl")&&(h=p.getContext("webgl",c)||p.getContext("experimental-webgl",c),h))try{return new o.WebGLContext(h,1)}catch(n){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw new Error("WebGL is not supported")}t.createWebGLContext=function f(p){let h;p&&p!=="webgl2"||!("webgl2"in l)?p&&p!=="webgl"||!("webgl"in l)||(h=l.webgl):h=l.webgl2,h=h||a(p),p=p||h.version===1?"webgl":"webgl2";const c=h.gl;return l[p]=h,c.isContextLost()?(delete l[p],f(p)):(c.disable(c.DEPTH_TEST),c.disable(c.STENCIL_TEST),c.disable(c.BLEND),c.disable(c.DITHER),c.disable(c.POLYGON_OFFSET_FILL),c.disable(c.SAMPLE_COVERAGE),c.enable(c.SCISSOR_TEST),c.enable(c.CULL_FACE),c.cullFace(c.BACK),h)},t.createNewWebGLContext=a},1713:function(d,t,i){var r=this&&this.__createBinding||(Object.create?function(c,n,e,s){s===void 0&&(s=e);var u=Object.getOwnPropertyDescriptor(n,e);u&&!("get"in u?!n.__esModule:u.writable||u.configurable)||(u={enumerable:!0,get:function(){return n[e]}}),Object.defineProperty(c,s,u)}:function(c,n,e,s){s===void 0&&(s=e),c[s]=n[e]}),o=this&&this.__setModuleDefault||(Object.create?function(c,n){Object.defineProperty(c,"default",{enumerable:!0,value:n})}:function(c,n){c.default=n}),l=this&&this.__importStar||function(c){if(c&&c.__esModule)return c;var n={};if(c!=null)for(var e in c)e!=="default"&&Object.prototype.hasOwnProperty.call(c,e)&&r(n,c,e);return o(n,c),n};Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLContext=t.linearSearchLastTrue=void 0;const a=i(1670),f=l(i(7769)),p=i(9390);function h(c){let n=0;for(;n<c.length&&c[n]();++n);return n-1}t.linearSearchLastTrue=h,t.WebGLContext=class{constructor(c,n){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=c,this.version=n,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(c,n,e,s){const u=this.gl,m=u.createTexture();u.bindTexture(u.TEXTURE_2D,m),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MIN_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MAG_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE);const b=s?e.encode(s,c*n):null;return u.texImage2D(u.TEXTURE_2D,0,e.internalFormat,c,n,0,e.format,e.textureType,b),this.checkError(),m}updateTexture(c,n,e,s,u){const m=this.gl;m.bindTexture(m.TEXTURE_2D,c);const b=s.encode(u,n*e);m.texSubImage2D(m.TEXTURE_2D,0,0,0,n,e,s.format,s.textureType,b),this.checkError()}attachFramebuffer(c,n,e){const s=this.gl;s.bindTexture(s.TEXTURE_2D,c),s.bindFramebuffer(s.FRAMEBUFFER,this.framebuffer),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,c,0),this.checkError(),s.viewport(0,0,n,e),s.scissor(0,0,n,e)}readTexture(c,n,e,s,u,m){const b=this.gl;m||(m=1),this.frameBufferBound||this.attachFramebuffer(c,n,e);const g=this.getEncoder(u,m),_=g.allocate(n*e);return b.bindTexture(b.TEXTURE_2D,c),b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,c,0),b.readPixels(0,0,n,e,b.RGBA,g.textureType,_),this.checkError(),g.decode(_,s)}isFramebufferReady(){return!0}getActiveTexture(){const c=this.gl;return"TEXTURE"+(c.getParameter(this.gl.ACTIVE_TEXTURE)-c.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(c,n){const e=this.gl;e.vertexAttribPointer(c,3,e.FLOAT,!1,20,0),e.enableVertexAttribArray(c),n!==-1&&(e.vertexAttribPointer(n,2,e.FLOAT,!1,20,12),e.enableVertexAttribArray(n)),this.checkError()}createProgram(c,n){const e=this.gl,s=e.createProgram();return e.attachShader(s,c),e.attachShader(s,n),e.linkProgram(s),s}compileShader(c,n){const e=this.gl,s=e.createShader(n);if(!s)throw new Error(`createShader() returned null with type ${n}`);if(e.shaderSource(s,c),e.compileShader(s),e.getShaderParameter(s,e.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${e.getShaderInfoLog(s)}
Shader source:
${c}`);return s}deleteShader(c){this.gl.deleteShader(c)}bindTextureToUniform(c,n,e){const s=this.gl;s.activeTexture(s.TEXTURE0+n),this.checkError(),s.bindTexture(s.TEXTURE_2D,c),this.checkError(),s.uniform1i(e,n),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(a.env.debug){const c=this.gl,n=c.getError();let e="";switch(n){case c.NO_ERROR:return;case c.INVALID_ENUM:e="INVALID_ENUM";break;case c.INVALID_VALUE:e="INVALID_VALUE";break;case c.INVALID_OPERATION:e="INVALID_OPERATION";break;case c.INVALID_FRAMEBUFFER_OPERATION:e="INVALID_FRAMEBUFFER_OPERATION";break;case c.OUT_OF_MEMORY:e="OUT_OF_MEMORY";break;case c.CONTEXT_LOST_WEBGL:e="CONTEXT_LOST_WEBGL";break;default:e=`Unknown WebGL Error: ${n.toString(16)}`}throw new Error(e)}}deleteTexture(c){this.gl.deleteTexture(c)}deleteProgram(c){this.gl.deleteProgram(c)}getEncoder(c,n,e=0){if(this.version===2)return new f.RedFloat32DataEncoder(this.gl,n);switch(c){case"float":return e===1||this.isRenderFloat32Supported?new f.RGBAFloatDataEncoder(this.gl,n):new f.RGBAFloatDataEncoder(this.gl,n,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new f.Uint8DataEncoder(this.gl,n);default:throw new Error(`Invalid dataType: ${c}`)}}clearActiveTextures(){const c=this.gl;for(let n=0;n<this.maxTextureImageUnits;++n)c.activeTexture(c.TEXTURE0+n),c.bindTexture(c.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const c=this.gl;c.bindFramebuffer(c.FRAMEBUFFER,null),c.deleteFramebuffer(this.framebuffer),c.bindBuffer(c.ARRAY_BUFFER,null),c.deleteBuffer(this.vertexbuffer),c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,null),c.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const c=this.gl,n=c.createBuffer();if(!n)throw new Error("createBuffer() returned null");const e=this.createDefaultGeometry();return c.bindBuffer(c.ARRAY_BUFFER,n),c.bufferData(c.ARRAY_BUFFER,e,c.STATIC_DRAW),this.checkError(),n}createFramebuffer(){const c=this.gl.createFramebuffer();if(!c)throw new Error("createFramebuffer returned null");return c}queryVitalParameters(){const c=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=c.getParameter(c.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=c.getParameter(c.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const c=this.gl,n=c.createTexture();c.bindTexture(c.TEXTURE_2D,n);const e=this.version===2?c.RGBA32F:c.RGBA;c.texImage2D(c.TEXTURE_2D,0,e,1,1,0,c.RGBA,c.FLOAT,null);const s=c.createFramebuffer();c.bindFramebuffer(c.FRAMEBUFFER,s),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,n,0);const u=c.checkFramebufferStatus(c.FRAMEBUFFER)===c.FRAMEBUFFER_COMPLETE;return c.bindTexture(c.TEXTURE_2D,null),c.bindFramebuffer(c.FRAMEBUFFER,null),c.deleteTexture(n),c.deleteFramebuffer(s),u}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const c=this.gl;let n,e,s,u,m;try{n=c.createTexture(),e=c.createFramebuffer(),c.bindTexture(c.TEXTURE_2D,n);const b=this.version===2?c.RGBA32F:c.RGBA;return c.texImage2D(c.TEXTURE_2D,0,b,1,1,0,c.RGBA,c.FLOAT,null),c.bindFramebuffer(c.FRAMEBUFFER,e),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,n,0),c.enable(c.BLEND),s=c.createShader(c.VERTEX_SHADER),!!s&&(c.shaderSource(s,"void main(){}"),c.compileShader(s),u=c.createShader(c.FRAGMENT_SHADER),!!u&&(c.shaderSource(u,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),c.compileShader(u),m=c.createProgram(),!!m&&(c.attachShader(m,s),c.attachShader(m,u),c.linkProgram(m),c.useProgram(m),c.drawArrays(c.POINTS,0,1),c.getError()===c.NO_ERROR)))}finally{c.disable(c.BLEND),m&&c.deleteProgram(m),s&&c.deleteShader(s),u&&c.deleteShader(u),e&&(c.bindFramebuffer(c.FRAMEBUFFER,null),c.deleteFramebuffer(e)),n&&(c.bindTexture(c.TEXTURE_2D,null),c.deleteTexture(n))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const c=this.gl,n=this.disjointTimerQueryWebgl2Extension,e=c.createQuery();return c.beginQuery(n.TIME_ELAPSED_EXT,e),e}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const c=this.gl,n=this.disjointTimerQueryWebgl2Extension;c.endQuery(n.TIME_ELAPSED_EXT)}}isTimerResultAvailable(c){let n=!1,e=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const s=this.gl,u=this.disjointTimerQueryWebgl2Extension;n=s.getQueryParameter(c,s.QUERY_RESULT_AVAILABLE),e=s.getParameter(u.GPU_DISJOINT_EXT)}return n&&!e}getTimerResult(c){let n=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const e=this.gl;n=e.getQueryParameter(c,e.QUERY_RESULT),e.deleteQuery(c)}return n/1e6}async waitForQueryAndGetTime(c){return await(0,p.repeatedTry)(()=>this.isTimerResultAvailable(c)),this.getTimerResult(c)}async createAndWaitForFence(){const c=this.createFence(this.gl);return this.pollFence(c)}createFence(c){let n;const e=c,s=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return c.flush(),n=s===null?()=>!0:()=>{const u=e.clientWaitSync(s,0,0);return u===e.ALREADY_SIGNALED||u===e.CONDITION_SATISFIED},{query:s,isFencePassed:n}}async pollFence(c){return new Promise(n=>{this.addItemToPoll(()=>c.isFencePassed(),()=>n())})}pollItems(){const c=h(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=c;++n){const{resolveFn:e}=this.itemsToPoll[n];e()}this.itemsToPoll=this.itemsToPoll.slice(c+1)}async addItemToPoll(c,n){this.itemsToPoll.push({isDoneFn:c,resolveFn:n}),this.itemsToPoll.length>1||await(0,p.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},1036:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ExecutionPlan=void 0;const r=i(6231);class o{constructor(a,f){this.op=a,this.node=f}}t.ExecutionPlan=class{constructor(l,a,f){this.graph=l,this.profiler=f,this.initialize(a)}initialize(l){this.profiler.event("session","ExecutionPlan.initialize",()=>{const a=this.graph.getNodes();if(a.length!==l.length)throw new Error("The size of nodes and OPs do not match.");this._ops=l.map((f,p)=>new o(f,a[p])),this.reset(),this._starter=[],this._ops.forEach((f,p)=>{let h=!0;for(const c of f.node.inputs)if(!this._values[c]&&this.graph.getInputIndices().indexOf(c)===-1){h=!1;break}h&&this._starter.push(p)})})}reset(){this._values=this.graph.getValues().map(l=>l.tensor)}async execute(l,a){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const f=l.createInferenceHandler(),p=this.graph.getInputIndices();if(a.length!==p.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${a.length} expected: ${p.length}`);a.forEach((u,m)=>{const b=p[m];this._values[b]=u});const h=this._starter.slice(0),c=this.graph.getValues(),n=this.graph.getNodes();let e=0;for(;e<h.length;){const u=h[e++],m=this._ops[u],b=m.node.inputs.map(v=>this._values[v]);if(b.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${m.node}`);const g=b;r.Logger.verbose("ExecPlan",`Runing op:${m.node.name} (${g.map((v,w)=>`'${m.node.inputs[w]}': ${v.type}[${v.dims.join(",")}]`).join(", ")})`);const _=await this.profiler.event("node",m.node.name,async()=>m.op.impl(f,g,m.op.context));if(_.length!==m.node.outputs.length)throw new Error("the size of output does not match model definition.");_.forEach((v,w)=>{const M=m.node.outputs[w];if(this._values[M])throw new Error(`output [${M}] already has value: op:${m.node.name}`);this._values[M]=v});const y=new Set;_.forEach((v,w)=>{const M=m.node.outputs[w];for(const S of c[M].to){const O=n[S];let x=!0;for(const T of O.inputs)if(!this._values[T]){x=!1;break}x&&y.add(S)}}),h.push(...y)}const s=[];for(let u=0;u<this.graph.getOutputIndices().length;u++){const m=this.graph.getOutputIndices()[u],b=this._values[m];if(b===void 0)throw new Error(`required output [${m}] does not have value`);m===0?await b.getData():b.data,s.push(b)}return r.Logger.verbose("ExecPlan","disposing of inferenceHandler"),f.dispose(),s})}}},7070:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Graph=void 0;const r=i(1446),o=i(7778),l=i(9395),a=i(9162),f=i(2517);var p=l.onnxruntime.experimental.fbs;t.Graph={from:(e,s)=>new n(e,s)};class h{constructor(s){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,s&&(this.type=f.ProtoUtil.tensorValueTypeFromProto(s.type.tensorType))}get from(){return this._from}get to(){return this._to}}class c{constructor(s,u){s instanceof r.onnx.NodeProto?(this.name=s.name,this.opType=s.opType,this.attributes=new o.Attribute(s.attribute)):s instanceof p.Node&&(this.name=u??s.name(),this.opType=s.opType(),this.attributes=new o.Attribute(f.ProtoUtil.tensorAttributesFromORTFormat(s))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class n{constructor(s,u){if(!s)throw new TypeError("graph is empty");this.buildGraph(s),this.transformGraph(u),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(s){if(s instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(s);else{if(!(s instanceof p.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(s)}}buildGraphFromOnnxFormat(s){const u=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const m=new Map;if(!s.input)throw new Error("missing information in graph: input");const b=[];for(const g of s.input){if(u.has(g.name))throw new Error(`duplicated input name: ${g.name}`);const _=this._allData.push(new h(g))-1;u.set(g.name,_),b.push(g.name)}if(!s.initializer)throw new Error("missing information in graph: initializer");for(const g of s.initializer){let _=u.get(g.name);if(_===void 0){const y=new h;y.type={shape:{dims:f.ProtoUtil.tensorDimsFromProto(g.dims)},tensorType:f.ProtoUtil.tensorDataTypeFromProto(g.dataType)},_=this._allData.push(y)-1,u.set(g.name,_)}this._allData[_]._from=-1,this._allData[_].tensor=a.Tensor.fromProto(g)}for(let g=0;g<this._allData.length;g++)this._allData[g].tensor||(this._allInputIndices.push(g),this._allInputNames.push(b[g]));if(!s.output)throw new Error("missing information in graph: output");for(const g of s.output){if(u.has(g.name))throw new Error(`duplicated output name: ${g.name}`);const _=this._allData.push(new h(g))-1;u.set(g.name,_),this._allOutputIndices.push(_),this._allOutputNames.push(g.name)}if(!s.node)throw new Error("missing information in graph: node");for(const g of s.node){if(!g.name)for(let y=0;;y++){const v=`unnamed_${g.opType}_${y}`;if(!m.has(v)){g.name=v;break}}if(m.has(g.name))throw new Error(`duplicated node name: ${g.name}`);const _=this._nodes.push(new c(g))-1;m.set(g.name,_)}for(let g=0;g<this._nodes.length;g++){const _=this._nodes[g],y=s.node[g];if(!y.output)throw new Error(`missing output for node: ${y.name}`);for(const v of y.output){let w=u.get(v);if(w===void 0&&(w=this._allData.push(new h)-1,u.set(v,w)),_.outputs.push(w),this._allData[w]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${w}`);if(this._allData[w]._from=g,y.opType==="Constant"){if(!y.attribute||y.attribute.length!==1||!y.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!y.output||y.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");_.outputs.pop(),_.executeNode=!1,this._allData[w]._from=-1,this._allData[w].tensor=a.Tensor.fromProto(y.attribute[0].t)}}}for(let g=0;g<this._nodes.length;g++){const _=this._nodes[g],y=s.node[g];if(!y.input)throw new Error(`missing input for node: ${y.name}`);for(const v of y.input){const w=u.get(v);if(w===void 0){if(v===""&&y.input.length===3&&y.opType==="Resize")continue;throw new Error(`unrecognized input '${v}' for node: ${y.name}`)}_.inputs.push(w),this._allData[w]._to.push(g)}}return!0}buildGraphFromOrtFormat(s){var u,m,b;const g=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const _=new Map,y=[];for(let v=0;v<s.inputsLength();v++){const w=s.inputs(v);if(g.has(w))throw new Error(`duplicated input name: ${w}`);for(let M=0;M<s.nodeArgsLength();M++)if(((u=s.nodeArgs(M))===null||u===void 0?void 0:u.name())===w){const S=new h;if(((b=(m=s.nodeArgs(M))===null||m===void 0?void 0:m.type())===null||b===void 0?void 0:b.valueType())!==p.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const O=s.nodeArgs(M).type().value(new p.TensorTypeAndShape),x=f.ProtoUtil.tensorDataTypeFromProto(O.elemType()),T=O.shape(),I=[];for(let C=0;C<T.dimLength();C++)I.push(f.LongUtil.longToNumber(T.dim(C).value().dimValue()));S.type={shape:{dims:I},tensorType:x};const F=this._allData.push(S)-1;g.set(w,F),y.push(w)}}for(let v=0;v<s.initializersLength();v++){const w=s.initializers(v);let M=g.get(w.name());if(M===void 0){const S=new h,O=f.ProtoUtil.tensorDimsFromORTFormat(w),x=f.ProtoUtil.tensorDataTypeFromProto(w.dataType());S.type={shape:{dims:O},tensorType:x},M=this._allData.push(S)-1,g.set(w.name(),M)}this._allData[M]._from=-1,this._allData[M].tensor=a.Tensor.fromOrtTensor(w)}for(let v=0;v<this._allData.length;v++)this._allData[v].tensor||(this._allInputIndices.push(v),this._allInputNames.push(y[v]));for(let v=0;v<s.outputsLength();v++){const w=s.outputs(v);if(g.has(w))throw new Error(`duplicated output name: ${w}`);const M=this._allData.push(new h)-1;g.set(w,M),this._allOutputIndices.push(M),this._allOutputNames.push(w)}if(!s.nodes)throw new Error("missing information in graph: node");for(let v=0;v<s.nodesLength();v++){const w=s.nodes(v);let M=w.name();if(!M)for(let O=0;M=`unnamed_${w.opType()}_${O}`,_.has(M);O++);if(_.has(M))throw new Error(`duplicated node name: ${M}`);const S=this._nodes.push(new c(w,M))-1;_.set(M,S)}for(let v=0;v<this._nodes.length;v++){const w=this._nodes[v],M=s.nodes(v);if(M==null)throw new Error(`No node exists at index ${v}`);if((M==null?void 0:M.outputsLength())===0)throw new Error(`missing output for node: ${M.name}`);for(let S=0;S<(M==null?void 0:M.outputsLength());S++){const O=M==null?void 0:M.outputs(S);let x=g.get(O);if(x===void 0&&(x=this._allData.push(new h)-1,g.set(O,x)),w.outputs.push(x),this._allData[x]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${x}`);if(this._allData[x]._from=v,M.opType()==="Constant"){if(M.attributesLength()!==1||!M.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(M.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");w.outputs.pop(),w.executeNode=!1,this._allData[x]._from=-1,this._allData[x].tensor=a.Tensor.fromOrtTensor(M.attributes(0).t())}}}for(let v=0;v<this._nodes.length;v++){const w=this._nodes[v],M=s.nodes(v);if(M.inputsLength()===0)throw new Error(`missing input for node: ${M.name}`);for(let S=0;S<M.inputsLength();S++){const O=M.inputs(S),x=g.get(O);if(x===void 0)throw new Error(`unrecognized input '${O}' for node: ${M.name()}`);w.inputs.push(x),this._allData[x]._to.push(v)}}}checkIsAcyclic(){const s=new Set;this._allInputIndices.forEach(b=>{this._allData[b]._to.forEach(g=>{s.add(g)})});const u=Array.from(s),m=new Array(this._nodes.length).fill("white");for(;u.length>0;){const b=u.pop();m[b]==="gray"?m[b]="black":(u.push(b),m[b]="gray",this._nodes[b].outputs.forEach(g=>{const _=this._allData[g];if(_.tensor!==void 0)throw new Error("node outputs should not be initialized");if(_._from!==b)throw new Error("from property of the Value object doesn't match index of Node being processed");_._to.forEach(y=>{if(m[y]==="gray")throw new Error("model graph is cyclic");m[y]==="white"&&u.push(y)})}))}}transformGraph(s){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),s&&s.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let s=0;for(let u=0;u<this._nodes.length;u++)this._nodes[u].executeNode?s>0&&(this._nodes[u].inputs.forEach(m=>{const b=this._allData[m]._to.indexOf(u+s);b!==-1&&(this._allData[m]._to[b]=u)}),this._nodes[u].outputs.forEach(m=>{this._allData[m]._from&&this._allData[m]._from===u+s&&(this._allData[m]._from=u)})):(s++,this._nodes[u].outputs.forEach(m=>{this._allData[m]._from=-2}),this._nodes.splice(u,1),u--);s=0;for(let u=0;u<this._allData.length;u++)if(this._allData[u].from!==-2||this._allOutputIndices.indexOf(u+s)!==-1){if(s>0){let m=-1;this._allData[u].from!==void 0&&this._allData[u].from!==-1?(m=this._nodes[this._allData[u].from].outputs.indexOf(u+s),m!==-1&&(this._nodes[this._allData[u].from].outputs[m]=u)):(m=this._allInputIndices.indexOf(u+s),m!==-1&&(this._allInputIndices[m]=u)),this._allData[u].to.forEach(b=>{m=this._nodes[b].inputs.indexOf(u+s),m!==-1&&(this._nodes[b].inputs[m]=u)}),this._allData[u].to.length===0&&(m=this._allOutputIndices.indexOf(u+s),m!==-1&&(this._allOutputIndices[m]=u))}}else s++,this._allData.splice(u,1),u--}deleteNode(s){const u=this._nodes[s];if(u.outputs.length>1){for(let v=1;v<u.outputs.length;v++)if(this._allData[u.outputs[v]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}u.executeNode=!1;const m=u.inputs[0],b=u.outputs[0],g=this._allData[b].to,_=this._allData[m].to.indexOf(s);if(_===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[m].to.splice(_,1),this._allData[b]._to=[];const y=this._allOutputIndices.indexOf(b);if(y!==-1&&(this._allOutputIndices[y]=m),g&&g.length>0)for(const v of g){const w=this._nodes[v].inputs.indexOf(b);if(w===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[v].inputs[w]=m,this._allData[m].to.push(v)}}removeAllDropoutNodes(){let s=0;for(const u of this._nodes){if(u.opType==="Dropout"){if(u.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(u.outputs.length!==1&&u.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(u.outputs.length===2&&this._allData[u.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(s)}s++}}removeAllIdentityNodes(){let s=0;for(const u of this._nodes)u.opType==="Identity"&&this.deleteNode(s),s++}isActivation(s){switch(s.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const s of this._nodes)if(s.opType==="Conv"){const u=this._allData[s.outputs[0]]._to;if(u.length===1&&this.isActivation(this._nodes[u[0]])){const m=this._nodes[u[0]];if(m.opType==="Clip")if(m.inputs.length===1)try{s.attributes.set("activation_params","floats",[m.attributes.getFloat("min"),m.attributes.getFloat("max")])}catch{s.attributes.set("activation_params","floats",[f.MIN_CLIP,f.MAX_CLIP])}else{if(!(m.inputs.length>=3&&this._allData[m.inputs[1]].tensor!==void 0&&this._allData[m.inputs[2]].tensor!==void 0))continue;s.attributes.set("activation_params","floats",[this._allData[m.inputs[1]].tensor.floatData[0],this._allData[m.inputs[2]].tensor.floatData[0]])}s.attributes.set("activation","string",m.opType),this.deleteNode(u[0])}}}}},6231:(d,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.now=t.Profiler=t.Logger=void 0;const i={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(c,n,e){}},console:new class{log(c,n,e){console.log(`${this.color(c)} ${e?"\x1B[35m"+e+"\x1B[0m ":""}${n}`)}color(c){switch(c){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${c}`)}}}},o={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let l={"":o};function a(c,n,e,s){if(n===void 0)return u=c,{verbose:a.verbose.bind(null,u),info:a.info.bind(null,u),warning:a.warning.bind(null,u),error:a.error.bind(null,u),fatal:a.fatal.bind(null,u)};if(e===void 0)f(c,n);else if(typeof e=="number"&&s===void 0)f(c,n);else if(typeof e=="string"&&s===void 0)f(c,e,0,n);else{if(typeof e!="string"||typeof s!="number")throw new TypeError("input is valid");f(c,e,0,n)}var u}function f(c,n,e,s){const u=l[s||""]||l[""];i[c]<i[u.minimalSeverity]||(u.logDateTime&&(n=`${new Date().toISOString()}|${n}`),u.logSourceLocation,r[u.provider].log(c,n,s))}(function(c){function n(s){l={},e("",s||{})}function e(s,u){if(s==="*")n(u);else{const m=l[s]||o;l[s]={provider:u.provider||m.provider,minimalSeverity:u.minimalSeverity||m.minimalSeverity,logDateTime:u.logDateTime===void 0?m.logDateTime:u.logDateTime,logSourceLocation:u.logSourceLocation===void 0?m.logSourceLocation:u.logSourceLocation}}}c.verbose=function(s,u){c("verbose",s,u)},c.info=function(s,u){c("info",s,u)},c.warning=function(s,u){c("warning",s,u)},c.error=function(s,u){c("error",s,u)},c.fatal=function(s,u){c("fatal",s,u)},c.reset=n,c.set=e,c.setWithEnv=function(s){const u={};s.logLevel&&(u.minimalSeverity=s.logLevel),e("",u)}})(a||(a={})),t.Logger=a;class p{constructor(n,e,s,u,m,b){this.category=n,this.name=e,this.startTime=s,this.endCallback=u,this.timer=m,this.ctx=b}end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class h{constructor(n,e,s,u){this.category=n,this.name=e,this.startTime=s,this.endTime=u}}t.Profiler=class{static create(c){return c===void 0?new this:new this(c.maxNumberEvents,c.flushBatchSize,c.flushIntervalInMilliseconds)}constructor(c,n,e){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=c===void 0?1e4:c,this._flushBatchSize=n===void 0?10:n,this._flushIntervalInMilliseconds=e===void 0?5e3:e}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,t.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(c,n,e,s){const u=this._started?this.begin(c,n,s):void 0;let m=!1;const b=e();if(b&&typeof b.then=="function")return m=!0,new Promise((g,_)=>{b.then(async y=>{u&&await u.end(),g(y)},async y=>{u&&await u.end(),_(y)})});if(!m&&u){const g=u.end();if(g&&typeof g.then=="function")return new Promise((_,y)=>{g.then(()=>{_(b)},v=>{y(v)})})}return b}begin(c,n,e){if(!this._started)throw new Error("profiler is not started yet");if(e===void 0){const s=(0,t.now)();return this.flush(s),new p(c,n,s,u=>this.endSync(u))}{const s=e.beginTimer();return new p(c,n,0,async u=>this.end(u),s,e)}}async end(c){const n=await c.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new h(c.category,c.name,c.startTime,n)),this.flush(n))}endSync(c){const n=(0,t.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new h(c.category,c.name,c.startTime,n)),this.flush(n))}logOneEvent(c){t.Logger.verbose(`Profiler.${c.category}`,`${(c.endTime-c.startTime).toFixed(2)}ms on event '${c.name}' at ${c.endTime.toFixed(2)}`)}flush(c){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||c-this._flushTime>=this._flushIntervalInMilliseconds){for(const n=this._flushPointer;this._flushPointer<n+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,t.now)()}}get started(){return this._started}},t.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},2644:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Model=void 0;const r=i(5686),o=i(1446),l=i(7070),a=i(9395),f=i(2517);var p=a.onnxruntime.experimental.fbs;t.Model=class{constructor(){}load(h,c,n){if(!n)try{return void this.loadFromOnnxFormat(h,c)}catch(e){if(n!==void 0)throw e}this.loadFromOrtFormat(h,c)}loadFromOnnxFormat(h,c){const n=o.onnx.ModelProto.decode(h);if(f.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map(e=>({domain:e.domain,version:f.LongUtil.longToNumber(e.version)})),this._graph=l.Graph.from(n.graph,c)}loadFromOrtFormat(h,c){const n=new r.flatbuffers.ByteBuffer(h),e=p.InferenceSession.getRootAsInferenceSession(n).model();if(f.LongUtil.longToNumber(e.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let s=0;s<e.opsetImportLength();s++){const u=e.opsetImport(s);this._opsets.push({domain:u==null?void 0:u.domain(),version:f.LongUtil.longToNumber(u.version())})}this._graph=l.Graph.from(e.graph(),c)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(d,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FLOAT_TYPES=t.INT_TYPES=t.NUMBER_TYPES=void 0,t.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],t.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],t.FLOAT_TYPES=["float32","float64"]},1047:(d,t)=>{function i(r,o){if(o.endsWith("+")){const l=Number.parseInt(o.substring(0,o.length-1),10);return!isNaN(l)&&l<=r}if(o.split("-").length===2){const l=o.split("-"),a=Number.parseInt(l[0],10),f=Number.parseInt(l[1],10);return!isNaN(a)&&!isNaN(f)&&a<=r&&r<=f}return Number.parseInt(o,10)===r}Object.defineProperty(t,"__esModule",{value:!0}),t.resolveOperator=void 0,t.resolveOperator=function(r,o,l){for(const a of l){const f=a[0],p=a[1],h=a[2],c=a[3],n=a[4];if(r.opType===f){for(const e of o)if((e.domain===p||e.domain==="ai.onnx"&&p==="")&&i(e.version,h))return{opImpl:c,opInit:n}}}throw new TypeError(`cannot resolve operator '${r.opType}' with opsets: ${o.map(a=>`${a.domain||"ai.onnx"} v${a.version}`).join(", ")}`)}},9395:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.onnxruntime=void 0;const r=i(5686);var o,l;o=t.onnxruntime||(t.onnxruntime={}),function(a){(function(f){f[f.UNDEFINED=0]="UNDEFINED",f[f.FLOAT=1]="FLOAT",f[f.INT=2]="INT",f[f.STRING=3]="STRING",f[f.TENSOR=4]="TENSOR",f[f.GRAPH=5]="GRAPH",f[f.FLOATS=6]="FLOATS",f[f.INTS=7]="INTS",f[f.STRINGS=8]="STRINGS",f[f.TENSORS=9]="TENSORS",f[f.GRAPHS=10]="GRAPHS",f[f.SPARSE_TENSOR=11]="SPARSE_TENSOR",f[f.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(a.AttributeType||(a.AttributeType={}))}((l=o.experimental||(o.experimental={})).fbs||(l.fbs={})),function(a){(function(f){(function(p){(function(h){h[h.UNKNOWN=0]="UNKNOWN",h[h.VALUE=1]="VALUE",h[h.PARAM=2]="PARAM"})(p.DimensionValueType||(p.DimensionValueType={}))})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){(function(h){h[h.UNDEFINED=0]="UNDEFINED",h[h.FLOAT=1]="FLOAT",h[h.UINT8=2]="UINT8",h[h.INT8=3]="INT8",h[h.UINT16=4]="UINT16",h[h.INT16=5]="INT16",h[h.INT32=6]="INT32",h[h.INT64=7]="INT64",h[h.STRING=8]="STRING",h[h.BOOL=9]="BOOL",h[h.FLOAT16=10]="FLOAT16",h[h.DOUBLE=11]="DOUBLE",h[h.UINT32=12]="UINT32",h[h.UINT64=13]="UINT64",h[h.COMPLEX64=14]="COMPLEX64",h[h.COMPLEX128=15]="COMPLEX128",h[h.BFLOAT16=16]="BFLOAT16"})(p.TensorDataType||(p.TensorDataType={}))})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){(function(h){h[h.Primitive=0]="Primitive",h[h.Fused=1]="Fused"})(p.NodeType||(p.NodeType={}))})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){(function(h){h[h.NONE=0]="NONE",h[h.tensor_type=1]="tensor_type",h[h.sequence_type=2]="sequence_type",h[h.map_type=3]="map_type"})(p.TypeInfoValue||(p.TypeInfoValue={}))})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsShape(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}dim(n,e){let s=this.bb.__offset(this.bb_pos,4);return s?(e||new a.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,e){n.addFieldOffset(0,e,0)}static createDimVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startDimVector(n,e){n.startVector(4,e,4)}static endShape(n){return n.endObject()}static createShape(n,e){return h.startShape(n),h.addDim(n,e),h.endShape(n)}}p.Shape=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsDimension(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}value(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new a.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}denotation(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}static startDimension(n){n.startObject(2)}static addValue(n,e){n.addFieldOffset(0,e,0)}static addDenotation(n,e){n.addFieldOffset(1,e,0)}static endDimension(n){return n.endObject()}static createDimension(n,e,s){return h.startDimension(n),h.addValue(n,e),h.addDenotation(n,s),h.endDimension(n)}}p.Dimension=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsDimensionValue(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):a.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,e){n.addFieldInt8(0,e,a.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(n,e){n.addFieldInt64(1,e,n.createLong(0,0))}static addDimParam(n,e){n.addFieldOffset(2,e,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,e,s,u){return h.startDimensionValue(n),h.addDimType(n,e),h.addDimValue(n,s),h.addDimParam(n,u),h.endDimensionValue(n)}}p.DimensionValue=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTensorTypeAndShape(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):a.experimental.fbs.TensorDataType.UNDEFINED}shape(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new a.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,e){n.addFieldInt32(0,e,a.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(n,e){n.addFieldOffset(1,e,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,e,s){return h.startTensorTypeAndShape(n),h.addElemType(n,e),h.addShape(n,s),h.endTensorTypeAndShape(n)}}p.TensorTypeAndShape=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsMapType(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):a.experimental.fbs.TensorDataType.UNDEFINED}valueType(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new a.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,e){n.addFieldInt32(0,e,a.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(n,e){n.addFieldOffset(1,e,0)}static endMapType(n){return n.endObject()}static createMapType(n,e,s){return h.startMapType(n),h.addKeyType(n,e),h.addValueType(n,s),h.endMapType(n)}}p.MapType=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSequenceType(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new a.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,e){n.addFieldOffset(0,e,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,e){return h.startSequenceType(n),h.addElemType(n,e),h.endSequenceType(n)}}p.SequenceType=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(f.fbs||(f.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(p,h){return this.bb_pos=p,this.bb=h,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(p,h,c,n){return p.prep(4,12),p.writeInt32(n),p.writeInt32(c),p.writeInt32(h),p.offset()}}})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsNodeEdge(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,e){let s=this.bb.__offset(this.bb_pos,6);return s?(e||new a.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+s)+12*n,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,e){let s=this.bb.__offset(this.bb_pos,8);return s?(e||new a.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+s)+12*n,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,e){n.addFieldInt32(0,e,0)}static addInputEdges(n,e){n.addFieldOffset(1,e,0)}static startInputEdgesVector(n,e){n.startVector(12,e,4)}static addOutputEdges(n,e){n.addFieldOffset(2,e,0)}static startOutputEdgesVector(n,e){n.startVector(12,e,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,e,s,u){return h.startNodeEdge(n),h.addNodeIndex(n,e),h.addInputEdges(n,s),h.addOutputEdges(n,u),h.endNodeEdge(n)}}p.NodeEdge=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsNode(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}domain(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):a.experimental.fbs.NodeType.Primitive}executionProviderType(n){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,n):null}inputs(n,e){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*n,e):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,e){let s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*n,e):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,e){let s=this.bb.__offset(this.bb_pos,24);return s?(e||new a.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*n):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,e){let s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*n,e):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addDomain(n,e){n.addFieldOffset(2,e,0)}static addSinceVersion(n,e){n.addFieldInt32(3,e,0)}static addIndex(n,e){n.addFieldInt32(4,e,0)}static addOpType(n,e){n.addFieldOffset(5,e,0)}static addType(n,e){n.addFieldInt32(6,e,a.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(n,e){n.addFieldOffset(7,e,0)}static addInputs(n,e){n.addFieldOffset(8,e,0)}static createInputsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startInputsVector(n,e){n.startVector(4,e,4)}static addOutputs(n,e){n.addFieldOffset(9,e,0)}static createOutputsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startOutputsVector(n,e){n.startVector(4,e,4)}static addAttributes(n,e){n.addFieldOffset(10,e,0)}static createAttributesVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startAttributesVector(n,e){n.startVector(4,e,4)}static addInputArgCounts(n,e){n.addFieldOffset(11,e,0)}static createInputArgCountsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addInt32(e[s]);return n.endVector()}static startInputArgCountsVector(n,e){n.startVector(4,e,4)}static addImplicitInputs(n,e){n.addFieldOffset(12,e,0)}static createImplicitInputsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startImplicitInputsVector(n,e){n.startVector(4,e,4)}static endNode(n){return n.endObject()}static createNode(n,e,s,u,m,b,g,_,y,v,w,M,S,O){return h.startNode(n),h.addName(n,e),h.addDocString(n,s),h.addDomain(n,u),h.addSinceVersion(n,m),h.addIndex(n,b),h.addOpType(n,g),h.addType(n,_),h.addExecutionProviderType(n,y),h.addInputs(n,v),h.addOutputs(n,w),h.addAttributes(n,M),h.addInputArgCounts(n,S),h.addImplicitInputs(n,O),h.endNode(n)}}p.Node=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsValueInfo(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}type(n){let e=this.bb.__offset(this.bb_pos,8);return e?(n||new a.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addType(n,e){n.addFieldOffset(2,e,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,e,s,u){return h.startValueInfo(n),h.addName(n,e),h.addDocString(n,s),h.addType(n,u),h.endValueInfo(n)}}p.ValueInfo=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTypeInfo(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):a.experimental.fbs.TypeInfoValue.NONE}value(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(n,this.bb_pos+e):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,e){n.addFieldOffset(0,e,0)}static addValueType(n,e){n.addFieldInt8(1,e,a.experimental.fbs.TypeInfoValue.NONE)}static addValue(n,e){n.addFieldOffset(2,e,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,e,s,u){return h.startTypeInfo(n),h.addDenotation(n,e),h.addValueType(n,s),h.addValue(n,u),h.endTypeInfo(n)}}p.TypeInfo=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsOperatorSetId(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,e){n.addFieldOffset(0,e,0)}static addVersion(n,e){n.addFieldInt64(1,e,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,e,s){return h.startOperatorSetId(n),h.addDomain(n,e),h.addVersion(n,s),h.endOperatorSetId(n)}}p.OperatorSetId=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTensor(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}dims(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):a.experimental.fbs.TensorDataType.UNDEFINED}rawData(n){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,e){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*n,e):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addDims(n,e){n.addFieldOffset(2,e,0)}static createDimsVector(n,e){n.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)n.addInt64(e[s]);return n.endVector()}static startDimsVector(n,e){n.startVector(8,e,8)}static addDataType(n,e){n.addFieldInt32(3,e,a.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(n,e){n.addFieldOffset(4,e,0)}static createRawDataVector(n,e){n.startVector(1,e.length,1);for(let s=e.length-1;s>=0;s--)n.addInt8(e[s]);return n.endVector()}static startRawDataVector(n,e){n.startVector(1,e,1)}static addStringData(n,e){n.addFieldOffset(5,e,0)}static createStringDataVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startStringDataVector(n,e){n.startVector(4,e,4)}static endTensor(n){return n.endObject()}static createTensor(n,e,s,u,m,b,g){return h.startTensor(n),h.addName(n,e),h.addDocString(n,s),h.addDims(n,u),h.addDataType(n,m),h.addRawData(n,b),h.addStringData(n,g),h.endTensor(n)}}p.Tensor=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSparseTensor(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}values(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}indices(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}dims(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,e){n.addFieldOffset(0,e,0)}static addIndices(n,e){n.addFieldOffset(1,e,0)}static addDims(n,e){n.addFieldOffset(2,e,0)}static createDimsVector(n,e){n.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)n.addInt64(e[s]);return n.endVector()}static startDimsVector(n,e){n.startVector(8,e,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,e,s,u){return h.startSparseTensor(n),h.addValues(n,e),h.addIndices(n,s),h.addDims(n,u),h.endSparseTensor(n)}}p.SparseTensor=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsAttribute(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):a.experimental.fbs.AttributeType.UNDEFINED}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,n):null}t(n){let e=this.bb.__offset(this.bb_pos,16);return e?(n||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}g(n){let e=this.bb.__offset(this.bb_pos,18);return e?(n||new a.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}floats(n){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*n):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,e){let s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*n,e):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,e){let s=this.bb.__offset(this.bb_pos,26);return s?(e||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,e){let s=this.bb.__offset(this.bb_pos,28);return s?(e||new a.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addType(n,e){n.addFieldInt32(2,e,a.experimental.fbs.AttributeType.UNDEFINED)}static addF(n,e){n.addFieldFloat32(3,e,0)}static addI(n,e){n.addFieldInt64(4,e,n.createLong(0,0))}static addS(n,e){n.addFieldOffset(5,e,0)}static addT(n,e){n.addFieldOffset(6,e,0)}static addG(n,e){n.addFieldOffset(7,e,0)}static addFloats(n,e){n.addFieldOffset(8,e,0)}static createFloatsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addFloat32(e[s]);return n.endVector()}static startFloatsVector(n,e){n.startVector(4,e,4)}static addInts(n,e){n.addFieldOffset(9,e,0)}static createIntsVector(n,e){n.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)n.addInt64(e[s]);return n.endVector()}static startIntsVector(n,e){n.startVector(8,e,8)}static addStrings(n,e){n.addFieldOffset(10,e,0)}static createStringsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startStringsVector(n,e){n.startVector(4,e,4)}static addTensors(n,e){n.addFieldOffset(11,e,0)}static createTensorsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startTensorsVector(n,e){n.startVector(4,e,4)}static addGraphs(n,e){n.addFieldOffset(12,e,0)}static createGraphsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startGraphsVector(n,e){n.startVector(4,e,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,e,s,u,m,b,g,_,y,v,w,M,S,O){return h.startAttribute(n),h.addName(n,e),h.addDocString(n,s),h.addType(n,u),h.addF(n,m),h.addI(n,b),h.addS(n,g),h.addT(n,_),h.addG(n,y),h.addFloats(n,v),h.addInts(n,w),h.addStrings(n,M),h.addTensors(n,S),h.addGraphs(n,O),h.endAttribute(n)}}p.Attribute=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsGraph(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,e){let s=this.bb.__offset(this.bb_pos,4);return s?(e||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,e){let s=this.bb.__offset(this.bb_pos,6);return s?(e||new a.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,e){let s=this.bb.__offset(this.bb_pos,8);return s?(e||new a.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,e){let s=this.bb.__offset(this.bb_pos,12);return s?(e||new a.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,e){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*n,e):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,e){let s=this.bb.__offset(this.bb_pos,16);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*n,e):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,e){let s=this.bb.__offset(this.bb_pos,18);return s?(e||new a.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,e){n.addFieldOffset(0,e,0)}static createInitializersVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startInitializersVector(n,e){n.startVector(4,e,4)}static addNodeArgs(n,e){n.addFieldOffset(1,e,0)}static createNodeArgsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startNodeArgsVector(n,e){n.startVector(4,e,4)}static addNodes(n,e){n.addFieldOffset(2,e,0)}static createNodesVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startNodesVector(n,e){n.startVector(4,e,4)}static addMaxNodeIndex(n,e){n.addFieldInt32(3,e,0)}static addNodeEdges(n,e){n.addFieldOffset(4,e,0)}static createNodeEdgesVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startNodeEdgesVector(n,e){n.startVector(4,e,4)}static addInputs(n,e){n.addFieldOffset(5,e,0)}static createInputsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startInputsVector(n,e){n.startVector(4,e,4)}static addOutputs(n,e){n.addFieldOffset(6,e,0)}static createOutputsVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startOutputsVector(n,e){n.startVector(4,e,4)}static addSparseInitializers(n,e){n.addFieldOffset(7,e,0)}static createSparseInitializersVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startSparseInitializersVector(n,e){n.startVector(4,e,4)}static endGraph(n){return n.endObject()}static createGraph(n,e,s,u,m,b,g,_,y){return h.startGraph(n),h.addInitializers(n,e),h.addNodeArgs(n,s),h.addNodes(n,u),h.addMaxNodeIndex(n,m),h.addNodeEdges(n,b),h.addInputs(n,g),h.addOutputs(n,_),h.addSparseInitializers(n,y),h.endGraph(n)}}p.Graph=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsModel(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,e){let s=this.bb.__offset(this.bb_pos,6);return s?(e||new a.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}producerVersion(n){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,n):null}domain(n){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,n):null}graph(n){let e=this.bb.__offset(this.bb_pos,18);return e?(n||new a.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}graphDocString(n){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,e){n.addFieldInt64(0,e,n.createLong(0,0))}static addOpsetImport(n,e){n.addFieldOffset(1,e,0)}static createOpsetImportVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startOpsetImportVector(n,e){n.startVector(4,e,4)}static addProducerName(n,e){n.addFieldOffset(2,e,0)}static addProducerVersion(n,e){n.addFieldOffset(3,e,0)}static addDomain(n,e){n.addFieldOffset(4,e,0)}static addModelVersion(n,e){n.addFieldInt64(5,e,n.createLong(0,0))}static addDocString(n,e){n.addFieldOffset(6,e,0)}static addGraph(n,e){n.addFieldOffset(7,e,0)}static addGraphDocString(n,e){n.addFieldOffset(8,e,0)}static endModel(n){return n.endObject()}static createModel(n,e,s,u,m,b,g,_,y,v){return h.startModel(n),h.addIrVersion(n,e),h.addOpsetImport(n,s),h.addProducerName(n,u),h.addProducerVersion(n,m),h.addDomain(n,b),h.addModelVersion(n,g),h.addDocString(n,_),h.addGraph(n,y),h.addGraphDocString(n,v),h.endModel(n)}}p.Model=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsKernelCreateInfos(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*n):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,e){n.addFieldOffset(0,e,0)}static createNodeIndicesVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addInt32(e[s]);return n.endVector()}static startNodeIndicesVector(n,e){n.startVector(4,e,4)}static addKernelDefHashes(n,e){n.addFieldOffset(1,e,0)}static createKernelDefHashesVector(n,e){n.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)n.addInt64(e[s]);return n.endVector()}static startKernelDefHashesVector(n,e){n.startVector(8,e,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,e,s){return h.startKernelCreateInfos(n),h.addNodeIndices(n,e),h.addKernelDefHashes(n,s),h.endKernelCreateInfos(n)}}p.KernelCreateInfos=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSubGraphSessionState(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}sessionState(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new a.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,e){n.addFieldOffset(0,e,0)}static addSessionState(n,e){n.addFieldOffset(1,e,0)}static endSubGraphSessionState(n){let e=n.endObject();return n.requiredField(e,4),e}static createSubGraphSessionState(n,e,s){return h.startSubGraphSessionState(n),h.addGraphId(n,e),h.addSessionState(n,s),h.endSubGraphSessionState(n)}}p.SubGraphSessionState=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSessionState(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new a.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}subGraphSessionStates(n,e){let s=this.bb.__offset(this.bb_pos,6);return s?(e||new a.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*n),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,e){n.addFieldOffset(0,e,0)}static addSubGraphSessionStates(n,e){n.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(n,e){n.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)n.addOffset(e[s]);return n.endVector()}static startSubGraphSessionStatesVector(n,e){n.startVector(4,e,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,e,s){return h.startSessionState(n),h.addKernels(n,e),h.addSubGraphSessionStates(n,s),h.endSessionState(n)}}p.SessionState=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(a){(function(f){(function(p){class h{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsInferenceSession(n,e){return(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,e){return n.setPosition(n.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new h).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}model(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new a.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}sessionState(n){let e=this.bb.__offset(this.bb_pos,8);return e?(n||new a.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,e){n.addFieldOffset(0,e,0)}static addModel(n,e){n.addFieldOffset(1,e,0)}static addSessionState(n,e){n.addFieldOffset(2,e,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,e){n.finish(e,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,e){n.finish(e,"ORTM",!0)}static createInferenceSession(n,e,s,u){return h.startInferenceSession(n),h.addOrtVersion(n,e),h.addModel(n,s),h.addSessionState(n,u),h.endInferenceSession(n)}}p.InferenceSession=h})(f.fbs||(f.fbs={}))})(a.experimental||(a.experimental={}))}(t.onnxruntime||(t.onnxruntime={}))},7448:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxjsSessionHandler=void 0;const r=i(1670),o=i(9162);t.OnnxjsSessionHandler=class{constructor(l){this.session=l,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(l,a,f){const p=new Map;for(const n in l)if(Object.hasOwnProperty.call(l,n)){const e=l[n];p.set(n,new o.Tensor(e.dims,e.type,void 0,void 0,e.data))}const h=await this.session.run(p),c={};return h.forEach((n,e)=>{c[e]=new r.Tensor(n.type,n.data,n.dims)}),c}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Session=void 0;const r=i(7067),o=i(1296),l=i(7091),a=i(1036),f=i(6231),p=i(2644);t.Session=class{constructor(h={}){this._initialized=!1,this.backendHint=h.backendHint,this.profiler=f.Profiler.create(h.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(h,c,n){await this.profiler.event("session","Session.loadModel",async()=>{const e=await(0,l.resolveBackend)(this.backendHint);if(this.sessionHandler=e.createSessionHandler(this.context),this._model=new p.Model,typeof h=="string"){const s=h.endsWith(".ort");if(typeof fetch>"u"){const u=await(0,o.promisify)(r.readFile)(h);this.initialize(u,s)}else{const u=await fetch(h),m=await u.arrayBuffer();this.initialize(new Uint8Array(m),s)}}else if(ArrayBuffer.isView(h))this.initialize(h);else{const s=new Uint8Array(h,c||0,n||h.byteLength);this.initialize(s)}})}initialize(h,c){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(h,n,c),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new a.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(h){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const c=this.normalizeAndValidateInputs(h),n=await this._executionPlan.execute(this.sessionHandler,c);return this.createOutput(n)})}normalizeAndValidateInputs(h){const c=this._model.graph.getInputNames();if(Array.isArray(h)){if(h.length!==c.length)throw new Error(`incorrect input array length: expected ${c.length} but got ${h.length}`)}else{if(h.size!==c.length)throw new Error(`incorrect input map size: expected ${c.length} but got ${h.size}`);const n=new Array(h.size);let e=0;for(let s=0;s<c.length;++s){const u=h.get(c[s]);if(!u)throw new Error(`missing input tensor for: '${name}'`);n[e++]=u}h=n}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,h,!1);else{const n=this._model.graph.getInputIndices(),e=this._model.graph.getValues(),s=new Array(n.length);for(let u=0;u<n.length;++u){const m=e[n[u]];s[u]=m.type.shape.dims,this.context.graphInputTypes.push(m.type.tensorType),this.context.graphInputDims.push(h[u].dims)}this.validateInputTensorDims(s,h,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,h),h}validateInputTensorTypes(h,c){for(let n=0;n<c.length;n++){const e=h[n],s=c[n].type;if(e!==s)throw new Error(`input tensor[${n}] check failed: expected type '${e}' but got ${s}`)}}validateInputTensorDims(h,c,n){for(let e=0;e<c.length;e++){const s=h[e],u=c[e].dims;if(!this.compareTensorDims(s,u,n))throw new Error(`input tensor[${e}] check failed: expected shape '[${s.join(",")}]' but got [${u.join(",")}]`)}}compareTensorDims(h,c,n){if(h.length!==c.length)return!1;for(let e=0;e<h.length;++e)if(h[e]!==c[e]&&(!n||h[e]!==0))return!1;return!0}createOutput(h){const c=this._model.graph.getOutputNames();if(h.length!==c.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let e=0;e<c.length;++e)n.set(c[e],h[e]);return n}initializeOps(h){const c=h.getNodes();this._ops=new Array(c.length);for(let n=0;n<c.length;n++)this._ops[n]=this.sessionHandler.resolve(c[n],this._model.opsets,h)}}},9162:function(d,t,i){var r=this&&this.__importDefault||function(m){return m&&m.__esModule?m:{default:m}};Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const o=i(3442),l=r(i(3720)),a=i(1446),f=i(9395),p=i(2517);var h=f.onnxruntime.experimental.fbs;class c{get data(){if(this.cache===void 0){const b=this.dataProvider(this.dataId);if(b.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=b}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(b){return this.data[p.ShapeUtil.indicesToOffset(b,this.strides)]}set(b,g){this.data[p.ShapeUtil.indicesToOffset(b,this.strides)]=g}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=p.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(b,g,_,y,v,w=o.Guid.create()){this.dims=b,this.type=g,this.dataProvider=_,this.asyncDataProvider=y,this.cache=v,this.dataId=w,this.size=p.ShapeUtil.validateDimsAndCalcSize(b);const M=this.size,S=_===void 0&&y===void 0&&v===void 0;if(v!==void 0&&v.length!==M)throw new RangeError("Input dims doesn't match data length.");if(g==="string"){if(!(v===void 0||Array.isArray(v)&&v.every(O=>typeof O=="string")))throw new TypeError("cache should be a string array");S&&(this.cache=new Array(M))}else{if(v!==void 0){const O=e(g);if(!(v instanceof O))throw new TypeError(`cache should be type ${O.name}`)}if(S){const O=new ArrayBuffer(M*function(x){switch(x){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${x}`)}}(g));this.cache=function(x,T){return new(e(T))(x)}(O,g)}}}static fromProto(b){if(!b)throw new Error("cannot construct Value from an empty tensor");const g=p.ProtoUtil.tensorDataTypeFromProto(b.dataType),_=p.ProtoUtil.tensorDimsFromProto(b.dims),y=new c(_,g);if(g==="string")b.stringData.forEach((v,w)=>{y.data[w]=(0,p.decodeUtf8String)(v)});else if(b.rawData&&typeof b.rawData.byteLength=="number"&&b.rawData.byteLength>0){const v=y.data,w=new DataView(b.rawData.buffer,b.rawData.byteOffset,b.rawData.byteLength),M=n(b.dataType),S=b.rawData.byteLength/M;if(b.rawData.byteLength%M!=0)throw new Error("invalid buffer length");if(v.length!==S)throw new Error("buffer length mismatch");for(let O=0;O<S;O++){const x=u(w,b.dataType,O*M);v[O]=x}}else{let v;switch(b.dataType){case a.onnx.TensorProto.DataType.FLOAT:v=b.floatData;break;case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.INT16:case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.BOOL:v=b.int32Data;break;case a.onnx.TensorProto.DataType.INT64:v=b.int64Data;break;case a.onnx.TensorProto.DataType.DOUBLE:v=b.doubleData;break;case a.onnx.TensorProto.DataType.UINT32:case a.onnx.TensorProto.DataType.UINT64:v=b.uint64Data;break;default:throw new Error("unspecific error")}if(v==null)throw new Error("failed to populate data from a tensorproto value");const w=y.data;if(w.length!==v.length)throw new Error("array length mismatch");for(let M=0;M<v.length;M++){const S=v[M];l.default.isLong(S)?w[M]=s(S,b.dataType):w[M]=S}}return y}static fromData(b,g,_){return new c(g,_,void 0,void 0,b)}static fromOrtTensor(b){if(!b)throw new Error("cannot construct Value from an empty tensor");const g=p.ProtoUtil.tensorDimsFromORTFormat(b),_=p.ProtoUtil.tensorDataTypeFromProto(b.dataType()),y=new c(g,_);if(_==="string")for(let v=0;v<b.stringDataLength();v++)y.data[v]=b.stringData(v);else if(b.rawDataArray()&&typeof b.rawDataLength()=="number"&&b.rawDataLength()>0){const v=y.data,w=new DataView(b.rawDataArray().buffer,b.rawDataArray().byteOffset,b.rawDataLength()),M=n(b.dataType()),S=b.rawDataLength()/M;if(b.rawDataLength()%M!=0)throw new Error("invalid buffer length");if(v.length!==S)throw new Error("buffer length mismatch");for(let O=0;O<S;O++){const x=u(w,b.dataType(),O*M);v[O]=x}}return y}}function n(m){switch(m){case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.BOOL:return 1;case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT16:return 2;case a.onnx.TensorProto.DataType.FLOAT:case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.UINT32:return 4;case a.onnx.TensorProto.DataType.INT64:case a.onnx.TensorProto.DataType.DOUBLE:case a.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[m]}`)}}function e(m){switch(m){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function s(m,b){if(b===a.onnx.TensorProto.DataType.INT64||b===h.TensorDataType.INT64){if(m.greaterThanOrEqual(2147483648)||m.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(b!==a.onnx.TensorProto.DataType.UINT32&&b!==h.TensorDataType.UINT32&&b!==a.onnx.TensorProto.DataType.UINT64&&b!==h.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[b]}`);if(m.greaterThanOrEqual(4294967296)||m.lessThan(0))throw new TypeError("uint64 is not supported")}return m.toNumber()}function u(m,b,g){switch(b){case a.onnx.TensorProto.DataType.BOOL:case a.onnx.TensorProto.DataType.UINT8:return m.getUint8(g);case a.onnx.TensorProto.DataType.INT8:return m.getInt8(g);case a.onnx.TensorProto.DataType.UINT16:return m.getUint16(g,!0);case a.onnx.TensorProto.DataType.INT16:return m.getInt16(g,!0);case a.onnx.TensorProto.DataType.FLOAT:return m.getFloat32(g,!0);case a.onnx.TensorProto.DataType.INT32:return m.getInt32(g,!0);case a.onnx.TensorProto.DataType.UINT32:return m.getUint32(g,!0);case a.onnx.TensorProto.DataType.INT64:return s(l.default.fromBits(m.getUint32(g,!0),m.getUint32(g+4,!0),!1),b);case a.onnx.TensorProto.DataType.DOUBLE:return m.getFloat64(g,!0);case a.onnx.TensorProto.DataType.UINT64:return s(l.default.fromBits(m.getUint32(g,!0),m.getUint32(g+4,!0),!0),b);default:throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[b]}`)}}t.Tensor=c},2517:function(d,t,i){var r=this&&this.__importDefault||function(b){return b&&b.__esModule?b:{default:b}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeUtf8String=t.MAX_CLIP=t.MIN_CLIP=t.PoolConvUtil=t.ReduceUtil=t.SplitUtil=t.MathUtil=t.ShapeUtil=t.LongUtil=t.ProtoUtil=t.GemmUtil=t.arrayCopyHelper=t.BroadcastUtil=t.MatMulUtil=t.ArrayUtil=t.assert=t.checkInputsShape=void 0;const o=i(5686),l=r(i(3720)),a=i(1446),f=i(9162);t.checkInputsShape=function(b,...g){if(!b||b.length!==g.length)return!1;for(let _=0;_<b.length;_++)if(!b[_].dims||b[_].dims.length!==g[_])return!1;return!0},t.assert=function(b,g){if(!b)throw new Error(typeof g=="string"?g:g())},t.ArrayUtil=class{static arraysEqual(b,g){if(b.length!==g.length)return!1;for(let _=0;_<b.length;_++)if(b[_]!==g[_])return!1;return!0}};class p{static preprocessInputShapes(g,_){return[g.length===1?[1,g[0]]:g,_.length===1?[_[0],1]:_]}static postprocessOutputShape(g,_,y){_===1&&g.splice(g.length-2,1),y===1&&g.pop()}static calcMatMulShape(g,_){return g[1]!==_[0]?void 0:[g[0],_[1]]}}t.MatMulUtil=p;class h{static calcShape(g,_,y=!1){const v=g.length,w=_.length;if(v===0)return _;if(w===0)return g;const M=Math.max(g.length,_.length),S=new Array(M);if(y){if(v<2||w<2)return;const O=p.calcMatMulShape([g[v-2],g[v-1]],[_[w-2],_[w-1]]);if(O===void 0)return;[S[M-2],S[M-1]]=O}for(let O=y?3:1;O<=M;O++){const x=v-O<0?1:g[v-O],T=w-O<0?1:_[w-O];if(x!==T&&x>1&&T>1)return;S[M-O]=Math.max(x,T)}return S}static index(g,_){const y=new Array(_.length);return h.fillIndex(g,_,y),y}static fillIndex(g,_,y){const v=g.length-_.length;for(let w=0;w<_.length;w++)y[w]=g[v+w]%_[w]}static calc(g,_,y,v,w){const M=h.calcShape(g.dims,_.dims);if(M){if(v&&!e.areEqual(M,g.dims))return;const S=e.size(M),O=v?g:new f.Tensor(M,w||g.type);if(M.length===0)O.set([],y(g.get([]),_.get([])));else{const x=new Array(M.length),T=new Array(g.dims.length),I=new Array(_.dims.length);let F,C=0,N=0,B=!1,k=!1;g.dims.length===0&&(C=g.get([]),B=!0),_.dims.length===0&&(N=_.get([]),k=!0);for(let R=0;R<S;R++){F=R;for(let X=M.length-1;X>=0;X--)x[X]=F%M[X],F=Math.floor(F/M[X]);B||(h.fillIndex(x,g.dims,T),C=g.get(T)),k||(h.fillIndex(x,_.dims,I),N=_.get(I)),O.set(x,y(C,N))}}return O}}static isValidBroadcast(g,_){const y=g.length,v=_.length;if(y>v)return!1;for(let w=1;w<=y;w++)if(g[y-w]!==1&&g[y-w]!==_[v-w])return!1;return!0}static getBroadcastDims(g,_){const y=g.length,v=[];for(let w=0;w<y;w++){const M=y-1-w,S=g[M]||1;(_[_.length-1-w]||1)>1&&S===1&&v.unshift(M)}return v}}t.BroadcastUtil=h,t.arrayCopyHelper=function(b,g,_,y,v){if(y<0||y>=g.length)throw new Error("sourceIndex out of bounds");if(_<0||_>=b.length)throw new Error("targetIndex out of bounds");if(y+v>g.length)throw new Error("source indices to be copied are outside bounds");if(_+v>b.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)b[_+w]=g[y+w]},t.GemmUtil=class{static getShapeOfGemmResult(b,g,_,y,v){if(b.length!==2||_.length!==2)throw new Error("shape need to be of size 2");let w,M,S;g?(w=b[1],M=b[0]):(w=b[0],M=b[1]);let O=-1;if(y?(S=_[0],O=1):(S=_[1],O=0),_[O]!==M)throw new Error("dimension mismatch");if(w<=0||S<=0||M<=0)throw new Error("invalid shape specified");if(v&&!h.isValidBroadcast(v,[w,S]))throw new Error("gemm: invalid bias shape for broadcast");return[w,S,M]}};class c{static tensorDataTypeFromProto(g){switch(g){case a.onnx.TensorProto.DataType.INT8:return"int8";case a.onnx.TensorProto.DataType.UINT8:return"uint8";case a.onnx.TensorProto.DataType.BOOL:return"bool";case a.onnx.TensorProto.DataType.INT16:return"int16";case a.onnx.TensorProto.DataType.UINT16:return"uint16";case a.onnx.TensorProto.DataType.INT32:return"int32";case a.onnx.TensorProto.DataType.UINT32:return"uint32";case a.onnx.TensorProto.DataType.FLOAT:return"float32";case a.onnx.TensorProto.DataType.DOUBLE:return"float64";case a.onnx.TensorProto.DataType.STRING:return"string";case a.onnx.TensorProto.DataType.INT64:return"int32";case a.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[g]}`)}}static tensorDataTypeStringToEnum(g){switch(g){case"int8":return a.onnx.TensorProto.DataType.INT8;case"uint8":return a.onnx.TensorProto.DataType.UINT8;case"bool":return a.onnx.TensorProto.DataType.BOOL;case"int16":return a.onnx.TensorProto.DataType.INT16;case"uint16":return a.onnx.TensorProto.DataType.UINT16;case"int32":return a.onnx.TensorProto.DataType.INT32;case"uint32":return a.onnx.TensorProto.DataType.UINT32;case"float32":return a.onnx.TensorProto.DataType.FLOAT;case"float64":return a.onnx.TensorProto.DataType.DOUBLE;case"string":return a.onnx.TensorProto.DataType.STRING;case"int64":return a.onnx.TensorProto.DataType.INT64;case"uint64":return a.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${g}`)}}static tensorDimsFromProto(g){return g.map(_=>l.default.isLong(_)?_.toNumber():_)}static tensorValueTypeFromProto(g){return{tensorType:c.tensorDataTypeFromProto(g.elemType),shape:{dims:c.tensorDimsFromProto(g.shape.dim.map(_=>_.dimValue))}}}static tensorDimsFromORTFormat(g){const _=[];for(let y=0;y<g.dimsLength();y++)_.push(n.longToNumber(g.dims(y)));return _}static tensorAttributesFromORTFormat(g){const _=[];for(let y=0;y<g.attributesLength();y++)_.push(g.attributes(y));return _}}t.ProtoUtil=c;class n{static longToNumber(g,_){return l.default.isLong(g)?g.toNumber():g instanceof o.flatbuffers.Long?l.default.fromValue({low:g.low,high:g.high,unsigned:_!=null&&_}).toNumber():g}static isLong(g){return l.default.isLong(g)||g instanceof o.flatbuffers.Long}}t.LongUtil=n;class e{static size(g){return e.getSizeFromDimensionRange(g,0,g.length)}static sizeFromDimension(g,_){if(_<0||_>g.length)throw new Error(`invalid dimension of ${_} for sizeFromDimension as Tensor has ${g.length} dimensions.`);return e.getSizeFromDimensionRange(g,_,g.length)}static sizeToDimension(g,_){if(_<0||_>g.length)throw new Error(`invalid dimension of ${_} for sizeToDimension as Tensor has ${g.length} dimensions.`);return e.getSizeFromDimensionRange(g,0,_)}static getSizeFromDimensionRange(g,_,y){let v=1;for(let w=_;w<y;w++){if(g[w]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");v*=g[w]}return v}static computeStrides(g){const _=g.length;if(_===0)return[];if(_===1)return[1];const y=new Array(_);y[_-1]=1,y[_-2]=g[_-1];for(let v=_-3;v>=0;--v)y[v]=y[v+1]*g[v+1];return y}static transpose(g){return g.slice().reverse()}static indicesToOffset(g,_,y){y===void 0&&(y=g.length);let v=0;for(let w=0;w<y;++w)v+=_[w]*g[w];return v}static offsetToIndices(g,_){const y=_.length;if(y===0)return[];if(y===1)return[g*_[0]];const v=new Array(_.length);for(let w=0;w<v.length-1;++w)v[w]=Math.floor(g/_[w]),g-=v[w]*_[w];return v[v.length-1]=g,v}static normalizeAxis(g,_){if(g<-_&&g>=_)throw new Error("unsupported axis for this operation.");return g<0?g+_:g}static normalizeAxes(g,_){return g.map(y=>this.normalizeAxis(y,_))}static incrementIndex(g,_,y){if(_.length===0||g.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(y===void 0)y=_.length;else if(y<=0||y>_.length)throw new Error("Incorrect axis to increment on");for(let v=y-1;v>=0&&(g[v]++,!(g[v]<_[v]));--v)g[v]=0}static calculateReshapedDims(g,_){if(_.length===0){if(g.length===0||e.size(g)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const y=_.length,v=new Array(y);let w=-1,M=1;for(let O=0;O<y;O++){if(_[O]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(_[O]===-1){if(w!==-1)throw new Error("at most one dimension in shape hints can be -1");w=O}else{if(_[O]===0){if(O>=g.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");v[O]=g[O]}else v[O]=_[O];M*=v[O]}}const S=e.size(g);if(w!==-1){if(S%M!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${g}] Output shape: [${_}]`);v[w]=S/M}else if(M!==S)throw new Error("reshapedDims and originalDims don't have matching sizes");return v}static sortBasedOnPerm(g,_){return _?_.map(y=>g[y]):g.slice().reverse()}static padShape(g,_){const y=g.length;return g.map((v,w)=>v+_[w]+_[w+y])}static areEqual(g,_){return g.length===_.length&&g.every((y,v)=>y===_[v])}static validateDimsAndCalcSize(g){if(g.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let _=1;for(const y of g){if(!Number.isInteger(y))throw new TypeError(`Invalid shape: ${y} is not an integer`);if(y<0||y>2147483647)throw new TypeError(`Invalid shape: length ${y} is not allowed`);_*=y}return _}static flattenShape(g,_){_<0&&(_+=g.length);const y=g.reduce((w,M)=>w*M,1),v=g.slice(_).reduce((w,M)=>w*M,1);return[y/v,v]}static squeezeShape(g,_){const y=new Array;_=e.normalizeAxes(_,g.length);for(let v=0;v<g.length;v++){const w=_.indexOf(v)>=0;if(w&&g[v]!==1)throw new Error("squeeze an axis of size different than 1");(_.length===0&&g[v]>1||_.length>0&&!w)&&y.push(g[v])}return y}static unsqueezeShape(g,_){const y=new Array(g.length+_.length);y.fill(0);for(let w=0;w<_.length;w++){const M=e.normalizeAxis(_[w],y.length);if(M>=y.length)throw new Error("'axes' has an out of range axis");if(y[M]!==0)throw new Error("'axes' has a duplicate axis");y[M]=1}let v=0;for(let w=0;w<y.length;w++)y[w]===0&&(y[w]=g[v++]);if(v!==g.length)throw new Error("the unsqueezed dimension could not be established");return y}}t.ShapeUtil=e,t.MathUtil=class{static sqr(b,g,_,y,v){if(y<0||y>=g.length)throw new Error("sourceIndex out of bounds");if(_<0||_>=b.length)throw new Error("targetIndex out of bounds");if(y+v>g.length)throw new Error("source indices to be copied are outside bounds");if(_+v>b.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)b[_+w]+=Math.pow(g[y+w],2)}static axpy(b,g,_,y,v,w){if(y<0||y>=g.length)throw new Error("sourceIndex out of bounds");if(_<0||_>=b.length)throw new Error("targetIndex out of bounds");if(y+v>g.length)throw new Error("source indices to be copied are outside bounds");if(_+v>b.length)throw new Error("target array is too small to hold result");for(let M=0;M<v;M++)b[_+M]+=w*g[y+M]}static powx(b,g,_,y,v,w){if(y<0||y>=g.length)throw new Error("sourceIndex out of bounds");if(_<0||_>=b.length)throw new Error("targetIndex out of bounds");if(y+v>g.length)throw new Error("source indices to be copied are outside bounds");if(_+v>b.length)throw new Error("target array is too small to hold result");for(let M=0;M<v;M++)b[_+M]=Math.pow(g[y+M],w)}static mul(b,g,_,y,v){if(y<0||y>=g.length)throw new Error("sourceIndex out of bounds");if(_<0||_>=b.length)throw new Error("targetIndex out of bounds");if(y+v>g.length)throw new Error("source indices to be copied are outside bounds");if(_+v>b.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)b[_+w]=g[y+w]*b[_+w]}};class s{static splitShape(g,_,y,v){if(y.length===0){if(!v)throw new Error("need to know number of outputs when the 'split' attribute is not specified");s.determineSplit(g[_],v,y)}const w=[],M=[0];for(let S=0;S<y.length;++S){S!==0&&M.push(M[S-1]+y[S-1]);const O=g.slice();O[_]=y[S],w.push(O)}return[w,M]}static determineSplit(g,_,y){if(g%_!=0)throw new Error("cannot split tensor to equal sized parts");for(let v=0;v<_;++v)y.push(g/_)}}t.SplitUtil=s;class u{static calcReduce(g,_,y,v,w){const M=g.dims.slice(0);_.length===0&&M.forEach((C,N)=>_.push(N));const S=u.calcReduceShape(M,_,!0),O=e.size(S),x=new f.Tensor(S,g.type),T=e.computeStrides(S),I=e.computeStrides(M),F=new Array(M.length);for(let C=0;C<O;C++){const N=e.offsetToIndices(C,T);h.fillIndex(N,M,F),x.set(N,u.calcReduceByAxis(g.numberData,_,M,0,e.indicesToOffset(F,I),v,w))}return y?x:new f.Tensor(u.calcReduceShape(M,_,y),x.type,void 0,void 0,x.data,x.dataId)}static calcReduceByAxis(g,_,y,v,w,M,S){let O=0;if(v>=_.length)return M(g[w]);const x=_[v],T=x>=y.length?1:e.size(y.slice(x+1));for(let I=0;I<y[x];I++)O=I===0?u.calcReduceByAxis(g,_,y,v+1,w,M,S):S(O,u.calcReduceByAxis(g,_,y,v+1,w,M,S)),w+=T;return O}static calcReduceShape(g,_,y){const v=g.slice();for(let w=0;w<_.length;w++)v[_[w]]=y?1:0;return v.filter(w=>w!==0)}}t.ReduceUtil=u;class m{static adjustPoolAttributes(g,_,y,v,w,M){if(!g&&y.length!==_.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(g)for(let S=0;S<_.length-2;S++)S>=y.length?y.push(_[S+2]):y[S]=_[S+2];for(let S=0;S<y.length;S++)if(S<v.length){if(v[S]<0)throw new Error("strides should be greater than or equal to 1")}else v.push(1);for(let S=0;S<y.length;S++)if(S<w.length){if(w[S]<0)throw new Error("dilations should be greater than or equal to 1")}else w.push(1);for(let S=0;S<2*y.length;S++)if(S<M.length){if(M[S]<0)throw new Error("pad should be greater than or equal to 1")}else M.push(0);for(let S=0;S<y.length;S++){if(y[S]<=0)throw new Error("kernel shapes need to be greater than 0");if(M[S]>=y[S]||M[S+y.length]>=y[S])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(g,_,y,v,w,M){if(M){if(w.length!==2*(g.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(_.length!==g.length-2)throw new Error("length of strides should be the length of data dimensions");if(v.length!==g.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let S=0;S<g.length-2;S++)m.adjustPadAndReturnShape(g[S+2],_[S],y[S],v[S],w,S,S+g.length-2,M)}}static computePoolOutputShape(g,_,y,v,w,M,S){if(_.length<=0)throw new Error("input shape must be of size greater than 0");const O=[_[0],_[1]];return m.computeShapeHelper(g,_,O,y,v,w,M,S),O}static computeConvOutputShape(g,_,y,v,w,M,S){if(g.length<=0||_.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const O=[g[0],_[0]];return m.computeShapeHelper(!1,g,O,y,v,w,M,S),O}static computeShapeHelper(g,_,y,v,w,M,S,O){if(g)for(let x=0;x<_.length-2;x++)y.push(1);else for(let x=0;x<_.length-2;x++)y.push(m.adjustPadAndReturnShape(_[x+2],v[x],w[x],M[x],S,x,x+_.length-2,O))}static adjustPadAndReturnShape(g,_,y,v,w,M,S,O){const x=y*(v-1)+1;if(!O||O==="NOTSET")return Math.floor((g+w[M]+w[S]-x)/_+1);switch(O){case"VALID":return w[M]=0,w[S]=0,Math.floor((g-x)/_+1);case"SAME_LOWER":case"SAME_UPPER":if(y!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const T=((g+_-1)/_-1)*_+v-g;return w[M]=Math.floor(O==="SAME_LOWER"?(T+1)/2:T/2),w[S]=T-w[M],Math.floor((g+T-v)/_+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=m,t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22,t.decodeUtf8String=function(b){return new TextDecoder().decode(b)}},7967:(d,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(i,r,o,l)=>{if(typeof i=="object"&&i!==null){if(o.has(i))throw new Error("Circular reference in options");o.add(i)}Object.entries(i).forEach(([a,f])=>{const p=r?r+a:a;if(typeof f=="object")(0,t.iterateExtraOptions)(f,p+".",o,l);else if(typeof f=="string"||typeof f=="number")l(p,f.toString());else{if(typeof f!="boolean")throw new Error("Can't handle extra config type: "+typeof f);l(p,f?"1":"0")}})}},2157:function(d,t,i){var r,o=this&&this.__createBinding||(Object.create?function(T,I,F,C){C===void 0&&(C=F);var N=Object.getOwnPropertyDescriptor(I,F);N&&!("get"in N?!I.__esModule:N.writable||N.configurable)||(N={enumerable:!0,get:function(){return I[F]}}),Object.defineProperty(T,C,N)}:function(T,I,F,C){C===void 0&&(C=F),T[C]=I[F]}),l=this&&this.__setModuleDefault||(Object.create?function(T,I){Object.defineProperty(T,"default",{enumerable:!0,value:I})}:function(T,I){T.default=I}),a=this&&this.__importStar||function(T){if(T&&T.__esModule)return T;var I={};if(T!=null)for(var F in T)F!=="default"&&Object.prototype.hasOwnProperty.call(T,F)&&o(I,T,F);return l(I,T),I};Object.defineProperty(t,"__esModule",{value:!0}),t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=t.initWasm=void 0;const f=i(1670),p=a(i(349)),h=i(6361),c=()=>!!f.env.wasm.proxy&&typeof document<"u";let n,e,s,u=!1,m=!1,b=!1;const g=[],_=[],y=[],v=[],w=[],M=[],S=()=>{if(u||!m||b||!n)throw new Error("worker not ready")},O=T=>{switch(T.data.type){case"init-wasm":u=!1,T.data.err?(b=!0,e[1](T.data.err)):(m=!0,e[0]());break;case"init-ort":T.data.err?s[1](T.data.err):s[0]();break;case"create_allocate":T.data.err?g.shift()[1](T.data.err):g.shift()[0](T.data.out);break;case"create_finalize":T.data.err?_.shift()[1](T.data.err):_.shift()[0](T.data.out);break;case"create":T.data.err?y.shift()[1](T.data.err):y.shift()[0](T.data.out);break;case"release":T.data.err?v.shift()[1](T.data.err):v.shift()[0]();break;case"run":T.data.err?w.shift()[1](T.data.err):w.shift()[0](T.data.out);break;case"end-profiling":T.data.err?M.shift()[1](T.data.err):M.shift()[0]()}},x=typeof document<"u"?(r=document==null?void 0:document.currentScript)===null||r===void 0?void 0:r.src:void 0;t.initWasm=async()=>{if(c()){if(m)return;if(u)throw new Error("multiple calls to 'initWasm()' detected.");if(b)throw new Error("previous call to 'initWasm()' failed.");return u=!0,f.env.wasm.wasmPaths===void 0&&x&&x.indexOf("blob:")!==0&&(f.env.wasm.wasmPaths=x.substr(0,+x.lastIndexOf("/")+1)),new Promise((T,I)=>{n==null||n.terminate(),n=i(9710).Z(),n.onmessage=O,e=[T,I];const F={type:"init-wasm",in:f.env.wasm};n.postMessage(F)})}return(0,h.initializeWebAssembly)(f.env.wasm)},t.initOrt=async(T,I)=>{if(c())return S(),new Promise((F,C)=>{s=[F,C];const N={type:"init-ort",in:{numThreads:T,loggingLevel:I}};n.postMessage(N)});p.initOrt(T,I)},t.createSessionAllocate=async T=>c()?(S(),new Promise((I,F)=>{g.push([I,F]);const C={type:"create_allocate",in:{model:T}};n.postMessage(C,[T.buffer])})):p.createSessionAllocate(T),t.createSessionFinalize=async(T,I)=>c()?(S(),new Promise((F,C)=>{_.push([F,C]);const N={type:"create_finalize",in:{modeldata:T,options:I}};n.postMessage(N)})):p.createSessionFinalize(T,I),t.createSession=async(T,I)=>c()?(S(),new Promise((F,C)=>{y.push([F,C]);const N={type:"create",in:{model:T,options:I}};n.postMessage(N,[T.buffer])})):p.createSession(T,I),t.releaseSession=async T=>{if(c())return S(),new Promise((I,F)=>{v.push([I,F]);const C={type:"release",in:T};n.postMessage(C)});p.releaseSession(T)},t.run=async(T,I,F,C,N)=>c()?(S(),new Promise((B,k)=>{w.push([B,k]);const R={type:"run",in:{sessionId:T,inputIndices:I,inputs:F,outputIndices:C,options:N}};n.postMessage(R,p.extractTransferableBuffers(F))})):p.run(T,I,F,C,N),t.endProfiling=async T=>{if(c())return S(),new Promise((I,F)=>{M.push([I,F]);const C={type:"end-profiling",in:T};n.postMessage(C)});p.endProfiling(T)}},586:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=i(7967),o=i(4983),l=i(6361);t.setRunOptions=a=>{const f=(0,l.getInstance)();let p=0;const h=[],c=a||{};try{if((a==null?void 0:a.logSeverityLevel)===void 0)c.logSeverityLevel=2;else if(typeof a.logSeverityLevel!="number"||!Number.isInteger(a.logSeverityLevel)||a.logSeverityLevel<0||a.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${a.logSeverityLevel}`);if((a==null?void 0:a.logVerbosityLevel)===void 0)c.logVerbosityLevel=0;else if(typeof a.logVerbosityLevel!="number"||!Number.isInteger(a.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${a.logVerbosityLevel}`);(a==null?void 0:a.terminate)===void 0&&(c.terminate=!1);let n=0;if((a==null?void 0:a.tag)!==void 0&&(n=(0,o.allocWasmString)(a.tag,h)),p=f._OrtCreateRunOptions(c.logSeverityLevel,c.logVerbosityLevel,!!c.terminate,n),p===0)throw new Error("Can't create run options");return(a==null?void 0:a.extra)!==void 0&&(0,r.iterateExtraOptions)(a.extra,"",new WeakSet,(e,s)=>{const u=(0,o.allocWasmString)(e,h),m=(0,o.allocWasmString)(s,h);if(f._OrtAddRunConfigEntry(p,u,m)!==0)throw new Error(`Can't set a run config entry: ${e} - ${s}`)}),[p,h]}catch(n){throw p!==0&&f._OrtReleaseRunOptions(p),h.forEach(f._free),n}}},2306:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxruntimeWebAssemblySessionHandler=void 0;const r=i(2806),o=i(1670),l=i(2850),a=i(2157);let f;t.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(p){const h=await fetch(p),c=await h.arrayBuffer();return(0,a.createSessionAllocate)(new Uint8Array(c))}async loadModel(p,h){if(f||(await(0,a.initOrt)(o.env.wasm.numThreads,(c=>{switch(c){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${c}`)}})(o.env.logLevel)),f=!0),typeof p=="string")if(typeof fetch>"u"){const c=await(0,l.promisify)(r.readFile)(p);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(c,h)}else{const c=await this.createSessionAllocate(p);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSessionFinalize)(c,h)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(p,h)}async dispose(){return(0,a.releaseSession)(this.sessionId)}async run(p,h,c){const n=[],e=[];Object.entries(p).forEach(b=>{const g=b[0],_=b[1],y=this.inputNames.indexOf(g);if(y===-1)throw new Error(`invalid input '${g}'`);n.push(_),e.push(y)});const s=[];Object.entries(h).forEach(b=>{const g=b[0],_=this.outputNames.indexOf(g);if(_===-1)throw new Error(`invalid output '${g}'`);s.push(_)});const u=await(0,a.run)(this.sessionId,e,n.map(b=>[b.type,b.dims,b.data]),s,c),m={};for(let b=0;b<u.length;b++)m[this.outputNames[s[b]]]=new o.Tensor(u[b][0],u[b][2],u[b][1]);return m}startProfiling(){}endProfiling(){(0,a.endProfiling)(this.sessionId)}}},4919:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=i(7967),o=i(4983),l=i(6361);t.setSessionOptions=a=>{const f=(0,l.getInstance)();let p=0;const h=[],c=a||{};(n=>{n.extra||(n.extra={}),n.extra.session||(n.extra.session={});const e=n.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(c);try{(a==null?void 0:a.graphOptimizationLevel)===void 0&&(c.graphOptimizationLevel="all");const n=(u=>{switch(u){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${u}`)}})(c.graphOptimizationLevel);(a==null?void 0:a.enableCpuMemArena)===void 0&&(c.enableCpuMemArena=!0),(a==null?void 0:a.enableMemPattern)===void 0&&(c.enableMemPattern=!0),(a==null?void 0:a.executionMode)===void 0&&(c.executionMode="sequential");const e=(u=>{switch(u){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${u}`)}})(c.executionMode);let s=0;if((a==null?void 0:a.logId)!==void 0&&(s=(0,o.allocWasmString)(a.logId,h)),(a==null?void 0:a.logSeverityLevel)===void 0)c.logSeverityLevel=2;else if(typeof a.logSeverityLevel!="number"||!Number.isInteger(a.logSeverityLevel)||a.logSeverityLevel<0||a.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${a.logSeverityLevel}`);if((a==null?void 0:a.logVerbosityLevel)===void 0)c.logVerbosityLevel=0;else if(typeof a.logVerbosityLevel!="number"||!Number.isInteger(a.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${a.logVerbosityLevel}`);if((a==null?void 0:a.enableProfiling)===void 0&&(c.enableProfiling=!1),p=f._OrtCreateSessionOptions(n,!!c.enableCpuMemArena,!!c.enableMemPattern,e,!!c.enableProfiling,0,s,c.logSeverityLevel,c.logVerbosityLevel),p===0)throw new Error("Can't create session options");return a!=null&&a.executionProviders&&((u,m,b)=>{for(const g of m){let _=typeof g=="string"?g:g.name;switch(_){case"xnnpack":_="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${_}`)}const y=(0,o.allocWasmString)(_,b);if((0,l.getInstance)()._OrtAppendExecutionProvider(u,y)!==0)throw new Error(`Can't append execution provider: ${_}`)}})(p,a.executionProviders,h),(a==null?void 0:a.extra)!==void 0&&(0,r.iterateExtraOptions)(a.extra,"",new WeakSet,(u,m)=>{const b=(0,o.allocWasmString)(u,h),g=(0,o.allocWasmString)(m,h);if(f._OrtAddSessionConfigEntry(p,b,g)!==0)throw new Error(`Can't set a session config entry: ${u} - ${m}`)}),[p,h]}catch(n){throw p!==0&&f._OrtReleaseSessionOptions(p),h.forEach(f._free),n}}},4983:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=i(6361);t.allocWasmString=(o,l)=>{const a=(0,r.getInstance)(),f=a.lengthBytesUTF8(o)+1,p=a._malloc(f);return a.stringToUTF8(o,p,f),l.push(p),p}},349:(d,t,i)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=i(586),o=i(4919),l=i(4983),a=i(6361);t.initOrt=(n,e)=>{const s=(0,a.getInstance)()._OrtInit(n,e);if(s!==0)throw new Error(`Can't initialize onnxruntime. error code = ${s}`)};const f=new Map;t.createSessionAllocate=n=>{const e=(0,a.getInstance)(),s=e._malloc(n.byteLength);return e.HEAPU8.set(n,s),[s,n.byteLength]},t.createSessionFinalize=(n,e)=>{const s=(0,a.getInstance)();let u=0,m=0,b=[];try{if([m,b]=(0,o.setSessionOptions)(e),u=s._OrtCreateSession(n[0],n[1],m),u===0)throw new Error("Can't create a session")}finally{s._free(n[0]),s._OrtReleaseSessionOptions(m),b.forEach(s._free)}const g=s._OrtGetInputCount(u),_=s._OrtGetOutputCount(u),y=[],v=[],w=[],M=[];for(let S=0;S<g;S++){const O=s._OrtGetInputName(u,S);if(O===0)throw new Error("Can't get an input name");v.push(O),y.push(s.UTF8ToString(O))}for(let S=0;S<_;S++){const O=s._OrtGetOutputName(u,S);if(O===0)throw new Error("Can't get an output name");M.push(O),w.push(s.UTF8ToString(O))}return f.set(u,[u,v,M]),[u,y,w]},t.createSession=(n,e)=>{const s=(0,t.createSessionAllocate)(n);return(0,t.createSessionFinalize)(s,e)},t.releaseSession=n=>{const e=(0,a.getInstance)(),s=f.get(n);if(!s)throw new Error("invalid session id");const u=s[0],m=s[1],b=s[2];m.forEach(e._OrtFree),b.forEach(e._OrtFree),e._OrtReleaseSession(u),f.delete(n)};const p=n=>{switch(n){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${n}`)}},h=n=>{switch(n){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${n}`)}},c=n=>{switch(n){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${n}`)}};t.run=(n,e,s,u,m)=>{const b=(0,a.getInstance)(),g=f.get(n);if(!g)throw new Error("invalid session id");const _=g[0],y=g[1],v=g[2],w=e.length,M=u.length;let S=0,O=[];const x=[],T=[];try{[S,O]=(0,r.setRunOptions)(m);for(let k=0;k<w;k++){const R=s[k][0],X=s[k][1],U=s[k][2];let K,Q;if(Array.isArray(U)){Q=4*U.length,K=b._malloc(Q),T.push(K);let ae=K/4;for(let ne=0;ne<U.length;ne++){if(typeof U[ne]!="string")throw new TypeError(`tensor data at index ${ne} is not a string`);b.HEAPU32[ae++]=(0,l.allocWasmString)(U[ne],T)}}else Q=U.byteLength,K=b._malloc(Q),T.push(K),b.HEAPU8.set(new Uint8Array(U.buffer,U.byteOffset,Q),K);const se=b.stackSave(),te=b.stackAlloc(4*X.length);try{let ae=te/4;X.forEach(ce=>b.HEAP32[ae++]=ce);const ne=b._OrtCreateTensor(p(R),K,Q,te,X.length);if(ne===0)throw new Error("Can't create a tensor");x.push(ne)}finally{b.stackRestore(se)}}const I=b.stackSave(),F=b.stackAlloc(4*w),C=b.stackAlloc(4*w),N=b.stackAlloc(4*M),B=b.stackAlloc(4*M);try{let k=F/4,R=C/4,X=N/4,U=B/4;for(let se=0;se<w;se++)b.HEAPU32[k++]=x[se],b.HEAPU32[R++]=y[e[se]];for(let se=0;se<M;se++)b.HEAPU32[X++]=0,b.HEAPU32[U++]=v[u[se]];let K=b._OrtRun(_,C,F,w,B,M,N,S);const Q=[];if(K===0)for(let se=0;se<M;se++){const te=b.HEAPU32[N/4+se],ae=b.stackSave(),ne=b.stackAlloc(16);let ce,oe=0;try{if(K=b._OrtGetTensorData(te,ne,ne+4,ne+8,ne+12),K!==0)throw new Error(`Can't access output tensor data. error code = ${K}`);let De=ne/4;const $e=b.HEAPU32[De++];oe=b.HEAPU32[De++];const Te=b.HEAPU32[De++],Ne=b.HEAPU32[De++],Fe=[];for(let Se=0;Se<Ne;Se++)Fe.push(b.HEAPU32[Te/4+Se]);b._OrtFree(Te);const Ae=Fe.length===0?1:Fe.reduce((Se,Ue)=>Se*Ue);if(ce=h($e),ce==="string"){const Se=[];let Ue=oe/4;for(let Ge=0;Ge<Ae;Ge++){const He=b.HEAPU32[Ue++],Ze=Ge===Ae-1?void 0:b.HEAPU32[Ue]-He;Se.push(b.UTF8ToString(He,Ze))}Q.push([ce,Fe,Se])}else{const Se=new(c(ce))(Ae);new Uint8Array(Se.buffer,Se.byteOffset,Se.byteLength).set(b.HEAPU8.subarray(oe,oe+Se.byteLength)),Q.push([ce,Fe,Se])}}finally{b.stackRestore(ae),ce==="string"&&oe&&b._free(oe),b._OrtReleaseTensor(te)}}if(K===0)return Q;throw new Error(`failed to call OrtRun(). error code = ${K}.`)}finally{b.stackRestore(I)}}finally{x.forEach(b._OrtReleaseTensor),T.forEach(b._free),b._OrtReleaseRunOptions(S),O.forEach(b._free)}},t.endProfiling=n=>{const e=(0,a.getInstance)(),s=f.get(n);if(!s)throw new Error("invalid session id");const u=s[0],m=e._OrtEndProfiling(u);if(m===0)throw new Error("Can't get an profile file name");e._OrtFree(m)},t.extractTransferableBuffers=n=>{const e=[];for(const s of n){const u=s[2];!Array.isArray(u)&&u.buffer&&e.push(u.buffer)}return e}},6361:function(d,t,i){var r=this&&this.__createBinding||(Object.create?function(m,b,g,_){_===void 0&&(_=g);var y=Object.getOwnPropertyDescriptor(b,g);y&&!("get"in y?!b.__esModule:y.writable||y.configurable)||(y={enumerable:!0,get:function(){return b[g]}}),Object.defineProperty(m,_,y)}:function(m,b,g,_){_===void 0&&(_=g),m[_]=b[g]}),o=this&&this.__setModuleDefault||(Object.create?function(m,b){Object.defineProperty(m,"default",{enumerable:!0,value:b})}:function(m,b){m.default=b}),l=this&&this.__importStar||function(m){if(m&&m.__esModule)return m;var b={};if(m!=null)for(var g in m)g!=="default"&&Object.prototype.hasOwnProperty.call(m,g)&&r(b,m,g);return o(b,m),b},a=this&&this.__importDefault||function(m){return m&&m.__esModule?m:{default:m}};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const f=l(i(6449)),p=a(i(932)),h=i(3474);let c,n=!1,e=!1,s=!1;const u=(m,b)=>b?m?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":m?"ort-wasm-simd.wasm":"ort-wasm.wasm";t.initializeWebAssembly=async m=>{if(n)return Promise.resolve();if(e)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(s)throw new Error("previous call to 'initializeWebAssembly()' failed.");e=!0;const b=m.initTimeout,g=m.numThreads,_=m.simd,y=g>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),v=_&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),w=typeof m.wasmPaths=="string"?m.wasmPaths:void 0,M=u(!1,y),S=u(v,y),O=typeof m.wasmPaths=="object"?m.wasmPaths[S]:void 0;let x=!1;const T=[];if(b>0&&T.push(new Promise(I=>{setTimeout(()=>{x=!0,I()},b)})),T.push(new Promise((I,F)=>{const C=y?h:p.default,N={locateFile:(B,k)=>y&&B.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([i(4154)],{type:"text/javascript"})):B===M?O??(w??k)+S:k+B};if(y)if(typeof Blob>"u")N.mainScriptUrlOrBlob=f.join("/","ort-wasm-threaded.js");else{const B=`var ortWasmThreaded=(function(){var _scriptDir;return ${C.toString()}})();`;N.mainScriptUrlOrBlob=new Blob([B],{type:"text/javascript"})}C(N).then(B=>{e=!1,n=!0,c=B,I()},B=>{e=!1,s=!0,F(B)})})),await Promise.race(T),x)throw new Error(`WebAssembly backend initializing failed due to timeout: ${b}ms`)},t.getInstance=()=>{if(n&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var m;!n||e||s||(e=!0,(m=c.PThread)===null||m===void 0||m.terminateAllThreads(),c=void 0,e=!1,n=!1,s=!0)}},9710:(d,t,i)=>{i.d(t,{Z:()=>l});var r=i(477),o=i.n(r);function l(){return o()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:d=>{d.exports=function(t,i,r,o){var l=self||window;try{try{var a;try{a=new l.Blob([t])}catch{(a=new(l.BlobBuilder||l.WebKitBlobBuilder||l.MozBlobBuilder||l.MSBlobBuilder)).append(t),a=a.getBlob()}var f=l.URL||l.webkitURL,p=f.createObjectURL(a),h=new l[i](p,r);return f.revokeObjectURL(p),h}catch{return new l[i]("data:application/javascript,".concat(encodeURIComponent(t)),r)}}catch{if(!o)throw Error("Inline worker is not supported");return new l[i](o,r)}}},4154:d=>{d.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},1670:d=>{d.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(d,t,i)=>{i.r(t),i.d(t,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,r.Long=function(o,l){this.low=0|o,this.high=0|l},r.Long.create=function(o,l){return o==0&&l==0?r.Long.ZERO:new r.Long(o,l)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(o){return this.low==o.low&&this.high==o.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(o){if(o)l=o;else var l=1024;this.bb=r.ByteBuffer.allocate(l),this.space=l,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(o){this.force_defaults=o},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(o,l){o>this.minalign&&(this.minalign=o);for(var a=1+~(this.bb.capacity()-this.space+l)&o-1;this.space<a+o+l;){var f=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-f}this.pad(a)},r.Builder.prototype.pad=function(o){for(var l=0;l<o;l++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(o){this.bb.writeInt8(this.space-=1,o)},r.Builder.prototype.writeInt16=function(o){this.bb.writeInt16(this.space-=2,o)},r.Builder.prototype.writeInt32=function(o){this.bb.writeInt32(this.space-=4,o)},r.Builder.prototype.writeInt64=function(o){this.bb.writeInt64(this.space-=8,o)},r.Builder.prototype.writeFloat32=function(o){this.bb.writeFloat32(this.space-=4,o)},r.Builder.prototype.writeFloat64=function(o){this.bb.writeFloat64(this.space-=8,o)},r.Builder.prototype.addInt8=function(o){this.prep(1,0),this.writeInt8(o)},r.Builder.prototype.addInt16=function(o){this.prep(2,0),this.writeInt16(o)},r.Builder.prototype.addInt32=function(o){this.prep(4,0),this.writeInt32(o)},r.Builder.prototype.addInt64=function(o){this.prep(8,0),this.writeInt64(o)},r.Builder.prototype.addFloat32=function(o){this.prep(4,0),this.writeFloat32(o)},r.Builder.prototype.addFloat64=function(o){this.prep(8,0),this.writeFloat64(o)},r.Builder.prototype.addFieldInt8=function(o,l,a){(this.force_defaults||l!=a)&&(this.addInt8(l),this.slot(o))},r.Builder.prototype.addFieldInt16=function(o,l,a){(this.force_defaults||l!=a)&&(this.addInt16(l),this.slot(o))},r.Builder.prototype.addFieldInt32=function(o,l,a){(this.force_defaults||l!=a)&&(this.addInt32(l),this.slot(o))},r.Builder.prototype.addFieldInt64=function(o,l,a){!this.force_defaults&&l.equals(a)||(this.addInt64(l),this.slot(o))},r.Builder.prototype.addFieldFloat32=function(o,l,a){(this.force_defaults||l!=a)&&(this.addFloat32(l),this.slot(o))},r.Builder.prototype.addFieldFloat64=function(o,l,a){(this.force_defaults||l!=a)&&(this.addFloat64(l),this.slot(o))},r.Builder.prototype.addFieldOffset=function(o,l,a){(this.force_defaults||l!=a)&&(this.addOffset(l),this.slot(o))},r.Builder.prototype.addFieldStruct=function(o,l,a){l!=a&&(this.nested(l),this.slot(o))},r.Builder.prototype.nested=function(o){if(o!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},r.Builder.prototype.slot=function(o){this.vtable[o]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(o){var l=o.capacity();if(3221225472&l)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var a=l<<1,f=r.ByteBuffer.allocate(a);return f.setPosition(a-l),f.bytes().set(o.bytes(),a-l),f},r.Builder.prototype.addOffset=function(o){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-o+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(o){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=o;for(var l=0;l<o;l++)this.vtable[l]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var o=this.offset(),l=this.vtable_in_use-1;l>=0&&this.vtable[l]==0;l--);for(var a=l+1;l>=0;l--)this.addInt16(this.vtable[l]!=0?o-this.vtable[l]:0);this.addInt16(o-this.object_start);var f=(a+2)*r.SIZEOF_SHORT;this.addInt16(f);var p=0,h=this.space;e:for(l=0;l<this.vtables.length;l++){var c=this.bb.capacity()-this.vtables[l];if(f==this.bb.readInt16(c)){for(var n=r.SIZEOF_SHORT;n<f;n+=r.SIZEOF_SHORT)if(this.bb.readInt16(h+n)!=this.bb.readInt16(c+n))continue e;p=this.vtables[l];break}}return p?(this.space=this.bb.capacity()-o,this.bb.writeInt32(this.space,p-o)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-o,this.offset()-o)),this.isNested=!1,o},r.Builder.prototype.finish=function(o,l,a){var f=a?r.SIZE_PREFIX_LENGTH:0;if(l){var p=l;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+f),p.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var h=r.FILE_IDENTIFIER_LENGTH-1;h>=0;h--)this.writeInt8(p.charCodeAt(h))}this.prep(this.minalign,r.SIZEOF_INT+f),this.addOffset(o),f&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(o,l){this.finish(o,l,!0)},r.Builder.prototype.requiredField=function(o,l){var a=this.bb.capacity()-o,f=a-this.bb.readInt32(a);if(this.bb.readInt16(f+l)==0)throw new Error("FlatBuffers: field "+l+" must be set")},r.Builder.prototype.startVector=function(o,l,a){this.notNested(),this.vector_num_elems=l,this.prep(r.SIZEOF_INT,o*l),this.prep(a,o*l)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(o){if(o instanceof Uint8Array)var l=o;else{l=[];for(var a=0;a<o.length;){var f,p=o.charCodeAt(a++);(f=p<55296||p>=56320?p:(p<<10)+o.charCodeAt(a++)+-56613888)<128?l.push(f):(f<2048?l.push(f>>6&31|192):(f<65536?l.push(f>>12&15|224):l.push(f>>18&7|240,f>>12&63|128),l.push(f>>6&63|128)),l.push(63&f|128))}}this.addInt8(0),this.startVector(1,l.length,1),this.bb.setPosition(this.space-=l.length),a=0;for(var h=this.space,c=this.bb.bytes();a<l.length;a++)c[h++]=l[a];return this.endVector()},r.Builder.prototype.createLong=function(o,l){return r.Long.create(o,l)},r.ByteBuffer=function(o){this.bytes_=o,this.position_=0},r.ByteBuffer.allocate=function(o){return new r.ByteBuffer(new Uint8Array(o))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(o){this.position_=o},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(o){return this.readUint8(o)<<24>>24},r.ByteBuffer.prototype.readUint8=function(o){return this.bytes_[o]},r.ByteBuffer.prototype.readInt16=function(o){return this.readUint16(o)<<16>>16},r.ByteBuffer.prototype.readUint16=function(o){return this.bytes_[o]|this.bytes_[o+1]<<8},r.ByteBuffer.prototype.readInt32=function(o){return this.bytes_[o]|this.bytes_[o+1]<<8|this.bytes_[o+2]<<16|this.bytes_[o+3]<<24},r.ByteBuffer.prototype.readUint32=function(o){return this.readInt32(o)>>>0},r.ByteBuffer.prototype.readInt64=function(o){return new r.Long(this.readInt32(o),this.readInt32(o+4))},r.ByteBuffer.prototype.readUint64=function(o){return new r.Long(this.readUint32(o),this.readUint32(o+4))},r.ByteBuffer.prototype.readFloat32=function(o){return r.int32[0]=this.readInt32(o),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(o){return r.int32[r.isLittleEndian?0:1]=this.readInt32(o),r.int32[r.isLittleEndian?1:0]=this.readInt32(o+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(o,l){this.bytes_[o]=l},r.ByteBuffer.prototype.writeUint8=function(o,l){this.bytes_[o]=l},r.ByteBuffer.prototype.writeInt16=function(o,l){this.bytes_[o]=l,this.bytes_[o+1]=l>>8},r.ByteBuffer.prototype.writeUint16=function(o,l){this.bytes_[o]=l,this.bytes_[o+1]=l>>8},r.ByteBuffer.prototype.writeInt32=function(o,l){this.bytes_[o]=l,this.bytes_[o+1]=l>>8,this.bytes_[o+2]=l>>16,this.bytes_[o+3]=l>>24},r.ByteBuffer.prototype.writeUint32=function(o,l){this.bytes_[o]=l,this.bytes_[o+1]=l>>8,this.bytes_[o+2]=l>>16,this.bytes_[o+3]=l>>24},r.ByteBuffer.prototype.writeInt64=function(o,l){this.writeInt32(o,l.low),this.writeInt32(o+4,l.high)},r.ByteBuffer.prototype.writeUint64=function(o,l){this.writeUint32(o,l.low),this.writeUint32(o+4,l.high)},r.ByteBuffer.prototype.writeFloat32=function(o,l){r.float32[0]=l,this.writeInt32(o,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(o,l){r.float64[0]=l,this.writeInt32(o,r.int32[r.isLittleEndian?0:1]),this.writeInt32(o+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var o="",l=0;l<r.FILE_IDENTIFIER_LENGTH;l++)o+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+l));return o},r.ByteBuffer.prototype.__offset=function(o,l){var a=o-this.readInt32(o);return l<this.readInt16(a)?this.readInt16(a+l):0},r.ByteBuffer.prototype.__union=function(o,l){return o.bb_pos=l+this.readInt32(l),o.bb=this,o},r.ByteBuffer.prototype.__string=function(o,l){o+=this.readInt32(o);var a=this.readInt32(o),f="",p=0;if(o+=r.SIZEOF_INT,l===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(o,o+a);for(;p<a;){var h,c=this.readUint8(o+p++);if(c<192)h=c;else{var n=this.readUint8(o+p++);if(c<224)h=(31&c)<<6|63&n;else{var e=this.readUint8(o+p++);h=c<240?(15&c)<<12|(63&n)<<6|63&e:(7&c)<<18|(63&n)<<12|(63&e)<<6|63&this.readUint8(o+p++)}}h<65536?f+=String.fromCharCode(h):(h-=65536,f+=String.fromCharCode(55296+(h>>10),56320+(1023&h)))}return f},r.ByteBuffer.prototype.__indirect=function(o){return o+this.readInt32(o)},r.ByteBuffer.prototype.__vector=function(o){return o+this.readInt32(o)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(o){return this.readInt32(o+this.readInt32(o))},r.ByteBuffer.prototype.__has_identifier=function(o){if(o.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var l=0;l<r.FILE_IDENTIFIER_LENGTH;l++)if(o.charCodeAt(l)!=this.readInt8(this.position_+r.SIZEOF_INT+l))return!1;return!0},r.ByteBuffer.prototype.createLong=function(o,l){return r.Long.create(o,l)}}},__webpack_module_cache__={};function __webpack_require__(d){var t=__webpack_module_cache__[d];if(t!==void 0)return t.exports;var i=__webpack_module_cache__[d]={exports:{}};return __webpack_modules__[d].call(i.exports,i,i.exports,__webpack_require__),i.exports}__webpack_require__.n=d=>{var t=d&&d.__esModule?()=>d.default:()=>d;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(d,t)=>{for(var i in t)__webpack_require__.o(t,i)&&!__webpack_require__.o(d,i)&&Object.defineProperty(d,i,{enumerable:!0,get:t[i]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(d,t)=>Object.prototype.hasOwnProperty.call(d,t),__webpack_require__.r=d=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(d,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(d,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(6018);return __webpack_exports__})())})(ortWeb_min$1);var ortWeb_min=getDefaultExportFromCjs(ortWeb_minExports),ONNX_WEB=_mergeNamespaces({__proto__:null,default:ortWeb_min},[ortWeb_minExports]);let ONNX;const executionProviders=["wasm"];typeof process<"u"&&((Ie=process==null?void 0:process.release)==null?void 0:Ie.name)==="node"?(ONNX=sharp??ONNX_NODE,executionProviders.unshift("cpu")):(ONNX=ortWeb_min??ONNX_WEB,typeof navigator<"u"&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(ONNX.env.wasm.simd=!1));const{env:onnx_env}=ONNX,VERSION="2.13.0",WEB_CACHE_AVAILABLE=typeof self<"u"&&"caches"in self,FS_AVAILABLE=!isEmpty(sharp),PATH_AVAILABLE=!isEmpty(sharp),RUNNING_LOCALLY=FS_AVAILABLE&&PATH_AVAILABLE,__dirname=RUNNING_LOCALLY?sharp.dirname(sharp.dirname(sharp.fileURLToPath(document.currentScript&&document.currentScript.src||new URL("assets/worker-63d30b82.js",document.baseURI).href))):"./",DEFAULT_CACHE_DIR=RUNNING_LOCALLY?sharp.join(__dirname,"/.cache/"):null,DEFAULT_LOCAL_MODEL_PATH="/models/",localModelPath=RUNNING_LOCALLY?sharp.join(__dirname,DEFAULT_LOCAL_MODEL_PATH):DEFAULT_LOCAL_MODEL_PATH;onnx_env.wasm.wasmPaths=RUNNING_LOCALLY?sharp.join(__dirname,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`;const env$1={backends:{onnx:onnx_env,tfjs:{}},__dirname,version:VERSION,allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!0,localModelPath,useFS:FS_AVAILABLE,useBrowserCache:WEB_CACHE_AVAILABLE,useFSCache:FS_AVAILABLE,cacheDir:DEFAULT_CACHE_DIR,useCustomCache:!1,customCache:null};function isEmpty(d){return Object.keys(d).length===0}globalThis.ReadableStream||(globalThis.ReadableStream=sharp.ReadableStream);class FileResponse{constructor(t){Be(this,"_CONTENT_TYPE_MAP",{txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"});if(this.filePath=t,this.headers=new Headers,this.exists=sharp.existsSync(t),this.exists){this.status=200,this.statusText="OK";let i=sharp.statSync(t);this.headers.set("content-length",i.size.toString()),this.updateContentType();let r=this;this.body=new ReadableStream({start(o){r.arrayBuffer().then(l=>{o.enqueue(new Uint8Array(l)),o.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const t=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[t]??"application/octet-stream")}clone(){let t=new FileResponse(this.filePath);return t.exists=this.exists,t.status=this.status,t.statusText=this.statusText,t.headers=new Headers(this.headers),t}async arrayBuffer(){return(await sharp.promises.readFile(this.filePath)).buffer}async blob(){const t=await sharp.promises.readFile(this.filePath);return new Blob([t],{type:this.headers.get("content-type")})}async text(){return await sharp.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function isValidHttpUrl(d,t=null){let i;try{i=new URL(d)}catch{return!1}return t&&!t.includes(i.hostname)?!1:i.protocol==="http:"||i.protocol==="https:"}async function getFile(d){var t,i,r,o;if(env$1.useFS&&!isValidHttpUrl(d))return new FileResponse(d);if(typeof process<"u"&&((t=process==null?void 0:process.release)==null?void 0:t.name)==="node"){const l=!!((i=process.env)!=null&&i.TESTING_REMOTELY),a=env$1.version,f=new Headers;if(f.set("User-Agent",`transformers.js/${a}; is_ci/${l};`),isValidHttpUrl(d,["huggingface.co","hf.co"])){const h=((r=process.env)==null?void 0:r.HF_TOKEN)??((o=process.env)==null?void 0:o.HF_ACCESS_TOKEN);h&&f.set("Authorization",`Bearer ${h}`)}return fetch(d,{headers:f})}else return fetch(d)}const ERROR_MAPPING={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function handleError(d,t,i){if(!i)return null;const r=ERROR_MAPPING[d]??`Error (${d}) occurred while trying to load file`;throw Error(`${r}: "${t}".`)}class FileCache{constructor(t){this.path=t}async match(t){let i=sharp.join(this.path,t),r=new FileResponse(i);if(r.exists)return r}async put(t,i){const r=Buffer.from(await i.arrayBuffer());let o=sharp.join(this.path,t);try{await sharp.promises.mkdir(sharp.dirname(o),{recursive:!0}),await sharp.promises.writeFile(o,r)}catch(l){console.warn("An error occurred while writing the file to cache:",l)}}}async function tryCache(d,...t){for(let i of t)try{let r=await d.match(i);if(r)return r}catch{continue}}async function getModelFile(d,t,i=!0,r={}){dispatchCallback(r.progress_callback,{status:"initiate",name:d,file:t});let o;if(!o&&env$1.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{o=await caches.open("transformers-cache")}catch(g){console.warn("An error occurred while opening the browser cache:",g)}}if(!o&&env$1.useFSCache&&(o=new FileCache(r.cache_dir??env$1.cacheDir)),!o&&env$1.useCustomCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");const l=r.revision??"main";let a=pathJoin(d,t),f=pathJoin(env$1.localModelPath,a),p=pathJoin(env$1.remoteHost,env$1.remotePathTemplate.replaceAll("{model}",d).replaceAll("{revision}",l),t),h=l==="main"?a:pathJoin(d,l,t),c,n=o instanceof FileCache?h:p,e=!1,s;o&&(s=await tryCache(o,f,n));const u=s!==void 0;if(s===void 0){if(isValidHttpUrl(a)){if(r.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${a}.`)}else try{s=await getFile(f),c=f}catch(_){console.warn(`Unable to load from local path "${f}": "${_}"`)}if(s===void 0||s.status===404){if(r.local_files_only||!env$1.allowRemoteModels){if(i)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${f}".`);return null}if(s=await getFile(p),s.status!==200)return handleError(s.status,p,i);c=n}e=o&&typeof Response<"u"&&s instanceof Response&&s.status===200}dispatchCallback(r.progress_callback,{status:"download",name:d,file:t});const m={status:"progress",name:d,file:t};let b;return r.progress_callback?u&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(b=new Uint8Array(await s.arrayBuffer()),dispatchCallback(r.progress_callback,{...m,progress:100,loaded:b.length,total:b.length})):b=await readResponse(s,g=>{dispatchCallback(r.progress_callback,{...m,...g})}):b=new Uint8Array(await s.arrayBuffer()),e&&c&&await o.match(c)===void 0&&await o.put(c,new Response(b,{headers:s.headers})).catch(g=>{console.warn(`Unable to add response to browser cache: ${g}.`)}),dispatchCallback(r.progress_callback,{status:"done",name:d,file:t}),b}async function getModelJSON(d,t,i=!0,r={}){let o=await getModelFile(d,t,i,r);if(o===null)return{};let a=new TextDecoder("utf-8").decode(o);return JSON.parse(a)}async function readResponse(d,t){const i=d.headers.get("Content-Length");i===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let r=parseInt(i??"0"),o=new Uint8Array(r),l=0;const a=d.body.getReader();async function f(){const{done:p,value:h}=await a.read();if(p)return;let c=l+h.length;if(c>r){r=c;let e=new Uint8Array(r);e.set(o),o=e}o.set(h,l),l=c;const n=l/r*100;return t({progress:n,loaded:l,total:r}),f()}return await f(),o}function pathJoin(...d){return d=d.map((t,i)=>(i&&(t=t.replace(new RegExp("^/"),"")),i!==d.length-1&&(t=t.replace(new RegExp("/$"),"")),t)),d.join("/")}function interpolate_data(d,[t,i,r],[o,l],a="bilinear",f=!1){const p=l/r,h=o/i,c=new d.constructor(o*l*t),n=i*r,e=o*l;for(let s=0;s<o;++s)for(let u=0;u<l;++u){const m=s*l+u,b=(u+.5)/p-.5,g=(s+.5)/h-.5;let _=Math.floor(b),y=Math.floor(g);const v=Math.min(_+1,r-1),w=Math.min(y+1,i-1);_=Math.max(_,0),y=Math.max(y,0);const M=b-_,S=g-y,O=(1-M)*(1-S),x=M*(1-S),T=(1-M)*S,I=M*S,F=y*r,C=w*r,N=F+_,B=F+v,k=C+_,R=C+v;for(let X=0;X<t;++X){const U=X*n;c[X*e+m]=O*d[U+N]+x*d[U+B]+T*d[U+k]+I*d[U+R]}}return c}function transpose_data(d,t,i){const r=new Array(i.length),o=new Array(i.length);for(let f=i.length-1,p=1;f>=0;--f)o[f]=p,r[f]=t[i[f]],p*=r[f];const l=i.map((f,p)=>o[i.indexOf(p)]),a=new d.constructor(d.length);for(let f=0;f<d.length;++f){let p=0;for(let h=t.length-1,c=f;h>=0;--h)p+=c%t[h]*l[h],c=Math.floor(c/t[h]);a[p]=d[f]}return[a,r]}function softmax(d){const t=max$2(d)[0],i=d.map(l=>Math.exp(l-t)),r=i.reduce((l,a)=>l+a,0);return i.map(l=>l/r)}function log_softmax(d){return softmax(d).map(r=>Math.log(r))}function getTopItems(d,t=0){return d=Array.from(d).map((i,r)=>[r,i]).sort((i,r)=>r[1]-i[1]),t>0&&(d=d.slice(0,t)),d}function min$1(d){if(d.length===0)throw Error("Array must not be empty");let t=d[0],i=0;for(let r=1;r<d.length;++r)d[r]<t&&(t=d[r],i=r);return[t,i]}function max$2(d){if(d.length===0)throw Error("Array must not be empty");let t=d[0],i=0;for(let r=1;r<d.length;++r)d[r]>t&&(t=d[r],i=r);return[Number(t),i]}function isPowerOfTwo(d){return d>0&&(d&d-1)===0}class P2FFT{constructor(t){if(this.size=t|0,this.size<=1||!isPowerOfTwo(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=t<<1,this.table=new Float64Array(this.size*2);for(let r=0;r<this.table.length;r+=2){const o=Math.PI*r/this.size;this.table[r]=Math.cos(o),this.table[r+1]=-Math.sin(o)}let i=0;for(let r=1;this.size>r;r<<=1)++i;this._width=i%2===0?i-1:i,this._bitrev=new Int32Array(1<<this._width);for(let r=0;r<this._bitrev.length;++r){this._bitrev[r]=0;for(let o=0;o<this._width;o+=2){const l=this._width-o-2;this._bitrev[r]|=(r>>>o&3)<<l}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(t,i){const r=i||new Array(t.length>>>1);for(let o=0;o<t.length;o+=2)r[o>>>1]=t[o];return r}toComplexArray(t,i){const r=i||this.createComplexArray();for(let o=0;o<r.length;o+=2)r[o]=t[o>>>1],r[o+1]=0;return r}completeSpectrum(t){const i=this._csize,r=i>>>1;for(let o=2;o<r;o+=2)t[i-o]=t[o],t[i-o+1]=-t[o+1]}transform(t,i){if(t===i)throw new Error("Input and output buffers must be different");this._transform4(t,i,1)}realTransform(t,i){if(t===i)throw new Error("Input and output buffers must be different");this._realTransform4(t,i,1)}inverseTransform(t,i){if(t===i)throw new Error("Input and output buffers must be different");this._transform4(t,i,-1);for(let r=0;r<t.length;++r)t[r]/=this.size}_transform4(t,i,r){const o=this._csize;let a=1<<this._width,f=o/a<<1,p,h;const c=this._bitrev;if(f===4)for(p=0,h=0;p<o;p+=f,++h){const n=c[h];this._singleTransform2(i,t,p,n,a)}else for(p=0,h=0;p<o;p+=f,++h){const n=c[h];this._singleTransform4(i,t,p,n,a,r)}for(a>>=2;a>=2;a>>=2){f=o/a<<1;const n=f>>>2;for(p=0;p<o;p+=f){const e=p+n-1;for(let s=p,u=0;s<e;s+=2,u+=a){const m=s,b=m+n,g=b+n,_=g+n,y=t[m],v=t[m+1],w=t[b],M=t[b+1],S=t[g],O=t[g+1],x=t[_],T=t[_+1],I=this.table[u],F=r*this.table[u+1],C=w*I-M*F,N=w*F+M*I,B=this.table[2*u],k=r*this.table[2*u+1],R=S*B-O*k,X=S*k+O*B,U=this.table[3*u],K=r*this.table[3*u+1],Q=x*U-T*K,se=x*K+T*U,te=y+R,ae=v+X,ne=y-R,ce=v-X,oe=C+Q,De=N+se,$e=r*(C-Q),Te=r*(N-se);t[m]=te+oe,t[m+1]=ae+De,t[b]=ne+Te,t[b+1]=ce-$e,t[g]=te-oe,t[g+1]=ae-De,t[_]=ne-Te,t[_+1]=ce+$e}}}}_singleTransform2(t,i,r,o,l){const a=t[o],f=t[o+1],p=t[o+l],h=t[o+l+1];i[r]=a+p,i[r+1]=f+h,i[r+2]=a-p,i[r+3]=f-h}_singleTransform4(t,i,r,o,l,a){const f=l*2,p=l*3,h=t[o],c=t[o+1],n=t[o+l],e=t[o+l+1],s=t[o+f],u=t[o+f+1],m=t[o+p],b=t[o+p+1],g=h+s,_=c+u,y=h-s,v=c-u,w=n+m,M=e+b,S=a*(n-m),O=a*(e-b);i[r]=g+w,i[r+1]=_+M,i[r+2]=y+O,i[r+3]=v-S,i[r+4]=g-w,i[r+5]=_-M,i[r+6]=y-O,i[r+7]=v+S}_realTransform4(t,i,r){const o=this._csize;let a=1<<this._width,f=o/a<<1,p,h;const c=this._bitrev;if(f===4)for(p=0,h=0;p<o;p+=f,++h){const n=c[h];this._singleRealTransform2(i,t,p,n>>>1,a>>>1)}else for(p=0,h=0;p<o;p+=f,++h){const n=c[h];this._singleRealTransform4(i,t,p,n>>>1,a>>>1,r)}for(a>>=2;a>=2;a>>=2){f=o/a<<1;const n=f>>>2;for(p=0;p<o;p+=f){const e=p+n-1;for(let s=p,u=0;s<e;s+=2,u+=a){const m=s,b=m+n,g=b+n,_=g+n,y=t[m],v=t[m+1],w=t[b],M=t[b+1],S=t[g],O=t[g+1],x=t[_],T=t[_+1],I=this.table[u],F=r*this.table[u+1],C=w*I-M*F,N=w*F+M*I,B=this.table[2*u],k=r*this.table[2*u+1],R=S*B-O*k,X=S*k+O*B,U=this.table[3*u],K=r*this.table[3*u+1],Q=x*U-T*K,se=x*K+T*U,te=y+R,ae=v+X,ne=y-R,ce=v-X,oe=C+Q,De=N+se,$e=r*(C-Q),Te=r*(N-se);t[m]=te+oe,t[m+1]=ae+De,t[b]=ne+Te,t[b+1]=ce-$e,t[g]=te-oe,t[g+1]=ae-De,t[_]=ne-Te,t[_+1]=ce+$e}}}}_singleRealTransform2(t,i,r,o,l){const a=t[o],f=t[o+l];i[r]=a+f,i[r+1]=0,i[r+2]=a-f,i[r+3]=0}_singleRealTransform4(t,i,r,o,l,a){const f=l*2,p=l*3,h=t[o],c=t[o+l],n=t[o+f],e=t[o+p],s=h+n,u=h-n,m=c+e,b=a*(c-e);i[r]=s+m,i[r+1]=0,i[r+2]=u,i[r+3]=-b,i[r+4]=s-m,i[r+5]=0,i[r+6]=u,i[r+7]=b}}class NP2FFT{constructor(t){const i=2*(t-1),r=2*(2*t-1),o=2**Math.ceil(Math.log2(r));this.bufferSize=o,this._a=i;const l=new Float64Array(r),a=new Float64Array(o);this._chirpBuffer=new Float64Array(o),this._buffer1=new Float64Array(o),this._buffer2=new Float64Array(o),this._outBuffer1=new Float64Array(o),this._outBuffer2=new Float64Array(o);const f=-2*Math.PI/t,p=Math.cos(f),h=Math.sin(f);for(let c=0;c<r>>1;++c){const n=(c+1-t)**2/2,e=Math.sqrt(p**2+h**2)**n,s=n*Math.atan2(h,p),u=2*c;l[u]=e*Math.cos(s),l[u+1]=e*Math.sin(s),a[u]=l[u],a[u+1]=-l[u+1]}this._slicedChirpBuffer=l.subarray(i,r),this._f=new P2FFT(o>>1),this._f.transform(this._chirpBuffer,a)}_transform(t,i,r){const o=this._buffer1,l=this._buffer2,a=this._outBuffer1,f=this._outBuffer2,p=this._chirpBuffer,h=this._slicedChirpBuffer,c=this._a;if(r)for(let n=0;n<h.length;n+=2){const e=n+1,s=n>>1,u=i[s];o[n]=u*h[n],o[e]=u*h[e]}else for(let n=0;n<h.length;n+=2){const e=n+1;o[n]=i[n]*h[n]-i[e]*h[e],o[e]=i[n]*h[e]+i[e]*h[n]}this._f.transform(a,o);for(let n=0;n<p.length;n+=2){const e=n+1;l[n]=a[n]*p[n]-a[e]*p[e],l[e]=a[n]*p[e]+a[e]*p[n]}this._f.inverseTransform(f,l);for(let n=0;n<f.length;n+=2){const e=f[n+c],s=f[n+c+1],u=h[n],m=h[n+1];t[n]=e*u-s*m,t[n+1]=e*m+s*u}}transform(t,i){this._transform(t,i,!1)}realTransform(t,i){this._transform(t,i,!0)}}class FFT{constructor(t){this.fft_length=t,this.isPowerOfTwo=isPowerOfTwo(t),this.isPowerOfTwo?(this.fft=new P2FFT(t),this.outputBufferSize=2*t):(this.fft=new NP2FFT(t),this.outputBufferSize=this.fft.bufferSize)}realTransform(t,i){this.fft.realTransform(t,i)}transform(t,i){this.fft.transform(t,i)}}function medianFilter(d,t){if(t%2===0||t<=0)throw new Error("Window size must be a positive odd number");const i=new d.constructor(d.length),r=new d.constructor(t),o=Math.floor(t/2);for(let l=0;l<d.length;++l){let a=0;for(let f=-o;f<=o;++f){let p=l+f;p<0?p=Math.abs(p):p>=d.length&&(p=2*(d.length-1)-p),r[a++]=d[p]}r.sort(),i[l]=r[o]}return i}const DataTypeMap=Object.freeze({float32:Float32Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array}),ONNXTensor$1=ONNX.Tensor;class Tensor{constructor(...t){Be(this,"dims");Be(this,"type");Be(this,"data");Be(this,"size");return t[0]instanceof ONNXTensor$1?Object.assign(this,t[0]):Object.assign(this,new ONNXTensor$1(t[0],t[1],t[2])),new Proxy(this,{get:(i,r)=>{if(typeof r=="string"){let o=Number(r);if(Number.isInteger(o))return i._getitem(o)}return i[r]},set:(i,r,o)=>i[r]=o})}*[Symbol.iterator](){const[t,...i]=this.dims;if(i.length>0){const r=i.reduce((o,l)=>o*l);for(let o=0;o<t;++o)yield this._subarray(o,r,i)}else yield*this.data}_getitem(t){const[i,...r]=this.dims;if(t=safeIndex(t,i),r.length>0){const o=r.reduce((l,a)=>l*a);return this._subarray(t,o,r)}else return new Tensor(this.type,[this.data[t]],r)}indexOf(t){for(let i=0;i<this.data.length;++i)if(this.data[i]==t)return i;return-1}_subarray(t,i,r){const o=t*i,l=(t+1)*i,a="subarray"in this.data?this.data.subarray(o,l):this.data.slice(o,l);return new Tensor(this.type,a,r)}item(){if(this.data.length!==1)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return reshape(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let t=0;t<this.data.length;++t)this.data[t]=1/(1+Math.exp(-this.data[t]));return this}mul(t){return this.clone().mul_(t)}mul_(t){for(let i=0;i<this.data.length;++i)this.data[i]*=t;return this}add(t){return this.clone().add_(t)}add_(t){for(let i=0;i<this.data.length;++i)this.data[i]+=t;return this}clone(){return new Tensor(this.type,this.data.slice(),this.dims.slice())}slice(...t){let i=[],r=[];for(let p=0;p<this.dims.length;++p){let h=t[p];if(h==null)r.push([0,this.dims[p]]),i.push(this.dims[p]);else if(typeof h=="number")h=safeIndex(h,this.dims[p],p),r.push([h,h+1]);else if(Array.isArray(h)&&h.length===2){if(h[0]>h[1])throw new Error(`Invalid slice: ${h}`);let c=[Math.max(h[0],0),Math.min(h[1],this.dims[p])];r.push(c),i.push(c[1]-c[0])}else throw new Error(`Invalid slice: ${h}`)}let o=r.map(([p,h])=>h-p),l=o.reduce((p,h)=>p*h),a=new this.data.constructor(l);const f=this.stride();for(let p=0;p<l;++p){let h=0;for(let c=o.length-1,n=p;c>=0;--c){const e=o[c];h+=(n%e+r[c][0])*f[c],n=Math.floor(n/e)}a[p]=this.data[h]}return new Tensor(this.type,a,i)}transpose(...t){return transpose$1(this,t)}sum(t=null,i=!1){return this.norm(1,t,i)}norm(t="fro",i=null,r=!1){if(t==="fro")t=2;else if(typeof t=="string")throw Error(`Unsupported norm: ${t}`);if(i===null){let a=this.data.reduce((f,p)=>f+p**t,0)**(1/t);return new Tensor(this.type,[a],[])}i=safeIndex(i,this.dims.length);const o=this.dims.slice();o[i]=1;const l=new this.data.constructor(this.data.length/this.dims[i]);for(let a=0;a<this.data.length;++a){let f=0;for(let p=this.dims.length-1,h=a,c=1;p>=0;--p){const n=this.dims[p];if(p!==i){const e=h%n;f+=e*c,c*=o[p]}h=Math.floor(h/n)}l[f]+=this.data[a]**t}if(t!==1)for(let a=0;a<l.length;++a)l[a]=l[a]**(1/t);return r||o.splice(i,1),new Tensor(this.type,l,o)}normalize_(t=2,i=1){i=safeIndex(i,this.dims.length);const r=this.norm(t,i,!0);for(let o=0;o<this.data.length;++o){let l=0;for(let a=this.dims.length-1,f=o,p=1;a>=0;--a){const h=this.dims[a];if(a!==i){const c=f%h;l+=c*p,p*=this.dims[a]}f=Math.floor(f/h)}this.data[o]/=r.data[l]}return this}normalize(t=2,i=1){return this.clone().normalize_(t,i)}stride(){return dimsToStride(this.dims)}squeeze(t=null){return new Tensor(this.type,this.data,calc_squeeze_dims(this.dims,t))}squeeze_(t=null){return this.dims=calc_squeeze_dims(this.dims,t),this}unsqueeze(t=null){return new Tensor(this.type,this.data,calc_unsqueeze_dims(this.dims,t))}unsqueeze_(t=null){return this.dims=calc_unsqueeze_dims(this.dims,t),this}flatten_(t=0,i=-1){i=(i+this.dims.length)%this.dims.length;let r=this.dims.slice(0,t),o=this.dims.slice(t,i+1),l=this.dims.slice(i+1);return this.dims=[...r,o.reduce((a,f)=>a*f,1),...l],this}flatten(t=0,i=-1){return this.clone().flatten_(t,i)}view(...t){let i=-1;for(let r=0;r<t.length;++r)if(t[r]===-1){if(i!==-1)throw new Error("Only one dimension can be inferred");i=r}if(i!==-1){const r=t.reduce((o,l,a)=>a!==i?o*l:o,1);t[i]=this.data.length/r}return new Tensor(this.type,this.data,t)}neg_(){for(let t=0;t<this.data.length;++t)this.data[t]=-this.data[t];return this}neg(){return this.clone().neg_()}clamp_(t,i){for(let r=0;r<this.data.length;++r)this.data[r]=Math.min(Math.max(this.data[r],t),i);return this}clamp(t,i){return this.clone().clamp_(t,i)}round_(){for(let t=0;t<this.data.length;++t)this.data[t]=Math.round(this.data[t]);return this}round(){return this.clone().round_()}to(t){if(this.type===t)return this;if(!DataTypeMap.hasOwnProperty(t))throw new Error(`Unsupported type: ${t}`);return new Tensor(t,DataTypeMap[t].from(this.data),this.dims)}}function reshape(d,t){const i=d.length,r=t.reduce((l,a)=>l*a);if(i!==r)throw Error(`cannot reshape array of size ${i} into shape (${t})`);let o=d;for(let l=t.length-1;l>=0;l--)o=o.reduce((a,f)=>{let p=a[a.length-1];return p.length<t[l]?p.push(f):a.push([f]),a},[[]]);return o[0]}function transpose$1(d,t){const[i,r]=transpose_data(d.data,d.dims,t);return new Tensor(d.type,i,r)}function interpolate(d,[t,i],r="bilinear",o=!1){const l=d.dims.at(-3)??1,a=d.dims.at(-2),f=d.dims.at(-1);let p=interpolate_data(d.data,[l,a,f],[t,i],r,o);return new Tensor(d.type,p,[l,t,i])}function calc_squeeze_dims(d,t){return d=d.slice(),t===null?d=d.filter(i=>i!==1):typeof t=="number"?d[t]===1&&d.splice(t,1):Array.isArray(t)&&(d=d.filter((i,r)=>i!==1||!t.includes(r))),d}function calc_unsqueeze_dims(d,t){return t=safeIndex(t,d.length+1),d=d.slice(),d.splice(t,0,1),d}function safeIndex(d,t,i=null){if(d<-t||d>=t)throw new Error(`IndexError: index ${d} is out of bounds for dimension${i===null?"":" "+i} with size ${t}`);return d<0&&(d=(d%t+t)%t),d}function cat(d,t=0){t=safeIndex(t,d[0].dims.length);const i=d[0].dims.slice();i[t]=d.reduce((a,f)=>a+f.dims[t],0);const r=i.reduce((a,f)=>a*f,1),o=new d[0].data.constructor(r),l=d[0].type;if(t===0){let a=0;for(let f of d)o.set(f.data,a),a+=f.data.length}else{let a=0;for(let f=0;f<d.length;++f){let p=d[f];for(let h=0;h<p.data.length;++h){let c=0;for(let n=p.dims.length-1,e=h,s=1;n>=0;--n){const u=p.dims[n];let m=e%u;n===t&&(m+=a),c+=m*s,s*=i[n],e=Math.floor(e/u)}o[c]=p.data[h]}a+=p.dims[t]}}return new Tensor(l,o,i)}function stack(d,t=0){return cat(d.map(i=>i.unsqueeze(t)),t)}function std_mean(d,t=null,i=1,r=!1){if(t===null){const h=d.data.reduce((s,u)=>s+u,0)/d.data.length,c=Math.sqrt(d.data.reduce((s,u)=>s+(u-h)**2,0)/(d.data.length-i)),n=new Tensor(d.type,[h],[]);return[new Tensor(d.type,[c],[]),n]}t=safeIndex(t,d.dims.length);const o=mean$1(d,t,r),l=d.dims.slice();l[t]=1;const a=new d.data.constructor(d.data.length/d.dims[t]);for(let p=0;p<d.data.length;++p){let h=0;for(let c=d.dims.length-1,n=p,e=1;c>=0;--c){const s=d.dims[c];if(c!==t){const u=n%s;h+=u*e,e*=l[c]}n=Math.floor(n/s)}a[h]+=(d.data[p]-o.data[h])**2}for(let p=0;p<a.length;++p)a[p]=Math.sqrt(a[p]/(d.dims[t]-i));return r||l.splice(t,1),[new Tensor(d.type,a,l),o]}function mean$1(d,t=null,i=!1){if(t===null){let l=d.data.reduce((a,f)=>a+f,0);return new Tensor(d.type,[l/d.data.length],[])}t=safeIndex(t,d.dims.length);const r=d.dims.slice();r[t]=1;const o=new d.data.constructor(d.data.length/d.dims[t]);for(let l=0;l<d.data.length;++l){let a=0;for(let f=d.dims.length-1,p=l,h=1;f>=0;--f){const c=d.dims[f];if(f!==t){const n=p%c;a+=n*h,h*=r[f]}p=Math.floor(p/c)}o[a]+=d.data[l]}if(d.dims[t]!==1)for(let l=0;l<o.length;++l)o[l]=o[l]/d.dims[t];return i||r.splice(t,1),new Tensor(d.type,o,r)}function dynamicTimeWarping(d){const[t,i]=d.dims,r=[t+1,i+1],o=new Tensor("float32",new Float32Array(r[0]*r[1]).fill(1/0),r),l=new Tensor("float32",new Float32Array(r[0]*r[1]).fill(-1),r);o[0].data[0]=0;for(let c=1;c<i+1;++c)for(let n=1;n<t+1;++n){const e=o[n-1][c-1].item(),s=o[n-1][c].item(),u=o[n][c-1].item();let m,b;e<s&&e<u?(m=e,b=0):s<e&&s<u?(m=s,b=1):(m=u,b=2),o[n].data[c]=d[n-1][c-1].item()+m,l[n].data[c]=b}let a=t,f=i;l.data.fill(2,0,r[1]);for(let c=0;c<r[0];++c)l[c].data[0]=1;let p=[],h=[];for(;a>0||f>0;)switch(p.push(a-1),h.push(f-1),l[a][f].item()){case 0:--a,--f;break;case 1:--a;break;case 2:--f;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${a}, ${f}]. Please file a bug report.`)}return p.reverse(),h.reverse(),[p,h]}function dimsToStride(d){const t=new Array(d.length);for(let i=d.length-1,r=1;i>=0;--i)t[i]=r,r*=d[i];return t}function ones$1(d){const t=d.reduce((i,r)=>i*r,1);return new Tensor("int64",new BigInt64Array(t).fill(1n),d)}function ones_like(d){return ones$1(d.dims)}var TOKEN_TYPES=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"});Object.freeze({set:TOKEN_TYPES.Set,for:TOKEN_TYPES.For,in:TOKEN_TYPES.In,if:TOKEN_TYPES.If,else:TOKEN_TYPES.Else,endif:TOKEN_TYPES.EndIf,elif:TOKEN_TYPES.ElseIf,endfor:TOKEN_TYPES.EndFor,and:TOKEN_TYPES.And,or:TOKEN_TYPES.Or,not:TOKEN_TYPES.Not,"not in":TOKEN_TYPES.NotIn,true:TOKEN_TYPES.BooleanLiteral,false:TOKEN_TYPES.BooleanLiteral}),TOKEN_TYPES.OpenStatement,TOKEN_TYPES.CloseStatement,TOKEN_TYPES.OpenExpression,TOKEN_TYPES.CloseExpression,TOKEN_TYPES.OpenParen,TOKEN_TYPES.CloseParen,TOKEN_TYPES.OpenSquareBracket,TOKEN_TYPES.CloseSquareBracket,TOKEN_TYPES.Comma,TOKEN_TYPES.Dot,TOKEN_TYPES.Colon,TOKEN_TYPES.Pipe,TOKEN_TYPES.ComparisonBinaryOperator,TOKEN_TYPES.ComparisonBinaryOperator,TOKEN_TYPES.ComparisonBinaryOperator,TOKEN_TYPES.ComparisonBinaryOperator,TOKEN_TYPES.ComparisonBinaryOperator,TOKEN_TYPES.ComparisonBinaryOperator,TOKEN_TYPES.AdditiveBinaryOperator,TOKEN_TYPES.AdditiveBinaryOperator,TOKEN_TYPES.MultiplicativeBinaryOperator,TOKEN_TYPES.MultiplicativeBinaryOperator,TOKEN_TYPES.MultiplicativeBinaryOperator,TOKEN_TYPES.Equals;const BYTES_TO_UNICODE=(()=>{const d=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},(o,l)=>l+"!".charCodeAt(0)),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},(o,l)=>l+"".charCodeAt(0)),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},(o,l)=>l+"".charCodeAt(0))];let t=d.slice(),i=0;for(let o=0;o<256;++o)d.includes(o)||(d.push(o),t.push(256+i),i+=1);let r=t.map(o=>String.fromCharCode(o));return Object.fromEntries(d.map((o,l)=>[o,r[l]]))})();reverseDictionary(BYTES_TO_UNICODE);function add_token_types(d){if(d.input_ids instanceof Tensor)d.token_type_ids=new Tensor("int64",new BigInt64Array(d.input_ids.data.length),d.input_ids.dims);else if(Array.isArray(d.input_ids))Array.isArray(d.input_ids[0])?d.token_type_ids=d.input_ids.map(t=>new Array(t.length).fill(0)):d.token_type_ids=new Array(d.input_ids.length).fill(0);else throw new Error("Input ids must be a Tensor or an Array");return d}const WHISPER_LANGUAGES=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]];new Map([...WHISPER_LANGUAGES.map(([d,t])=>[t,d]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);async function loadConfig(d,t){return await getModelJSON(d,"config.json",!0,t)}class PretrainedConfig{constructor(t){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,t)}static async from_pretrained(t,{progress_callback:i=null,config:r=null,cache_dir:o=null,local_files_only:l=!1,revision:a="main"}={}){let f=r??await loadConfig(t,{progress_callback:i,config:r,cache_dir:o,local_files_only:l,revision:a});return new this(f)}}class AutoConfig{static async from_pretrained(...t){return PretrainedConfig.from_pretrained(...t)}}class LogitsProcessorList extends Callable{constructor(){super(),this.processors=[]}push(t){this.processors.push(t)}extend(t){this.processors.push(...t)}_call(t,i){for(let r of i)this.processors.forEach(o=>o(t,r))}[Symbol.iterator](){return this.processors.values()}}class LogitsProcessor extends Callable{_call(t,i){throw Error("`_call` should be implemented in a subclass")}}class ForceTokensLogitsProcessor extends LogitsProcessor{constructor(t){super(),this.force_token_map=Object.fromEntries(t??[])}_call(t,i){let r=this.force_token_map[t.length];return exists(r)&&(i.data.fill(-1/0),i.data[r]=0),i}}class ForcedBOSTokenLogitsProcessor extends LogitsProcessor{constructor(t){super(),this.bos_token_id=t}_call(t,i){return t.length===1&&(i.data.fill(-1/0),i.data[this.bos_token_id]=0),i}}class ForcedEOSTokenLogitsProcessor extends LogitsProcessor{constructor(t,i){super(),this.max_length=t,this.forced_eos_token_id=i}_call(t,i){}}class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor{constructor(t,i){super(),this.begin_suppress_tokens=t,this.begin_index=i}_call(t,i){if(t.length===this.begin_index)for(let r of this.begin_suppress_tokens)i.data[r]=-1/0;return i}}class WhisperTimeStampLogitsProcessor extends LogitsProcessor{constructor(t){super(),this.eos_token_id=t.eos_token_id,this.no_timestamps_token_id=t.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(t.forced_decoder_ids||[]).length+2,t.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=t.max_initial_timestamp_index}_call(t,i){if(i.data[this.no_timestamps_token_id]=-1/0,t.length===this.begin_index-1)return i.data.fill(-1/0),i.data[this.timestamp_begin]=0,i;const r=i.data,o=t.slice(this.begin_index),l=o.length>=1&&o[o.length-1]>=this.timestamp_begin,a=o.length<2||o[o.length-2]>=this.timestamp_begin;if(l&&(a?r.subarray(this.timestamp_begin).fill(-1/0):r.subarray(0,this.eos_token_id).fill(-1/0)),t.length===this.begin_index&&this.max_initial_timestamp_index!==null){const c=this.timestamp_begin+this.max_initial_timestamp_index;r.subarray(c+1).fill(-1/0)}const f=log_softmax(r),p=Math.log(f.subarray(this.timestamp_begin).map(Math.exp).reduce((c,n)=>c+n)),h=max$2(f.subarray(0,this.timestamp_begin))[0];return p>h&&r.subarray(0,this.timestamp_begin).fill(-1/0),i}}class NoRepeatNGramLogitsProcessor extends LogitsProcessor{constructor(t){super(),this.no_repeat_ngram_size=t}getNgrams(t){const i=t.length,r=[];for(let l=0;l<i+1-this.no_repeat_ngram_size;++l){const a=[];for(let f=0;f<this.no_repeat_ngram_size;++f)a.push(t[l+f]);r.push(a)}const o=new Map;for(const l of r){const a=l.slice(0,l.length-1),f=JSON.stringify(a),p=o.get(f)??[];p.push(l[l.length-1]),o.set(f,p)}return o}getGeneratedNgrams(t,i){const r=i.slice(i.length+1-this.no_repeat_ngram_size,i.length);return t.get(JSON.stringify(r))??[]}calcBannedNgramTokens(t){const i=[];if(t.length+1<this.no_repeat_ngram_size)return i;{const r=this.getNgrams(t);return this.getGeneratedNgrams(r,t)}}_call(t,i){const r=this.calcBannedNgramTokens(t);for(const o of r)i.data[o]=-1/0;return i}}class RepetitionPenaltyLogitsProcessor extends LogitsProcessor{constructor(t){super(),this.penalty=t}_call(t,i){for(const r of t)i.data[r]<0?i.data[r]*=this.penalty:i.data[r]/=this.penalty;return i}}class MinLengthLogitsProcessor extends LogitsProcessor{constructor(t,i){super(),this.min_length=t,this.eos_token_id=Array.isArray(i)?i:[i]}_call(t,i){if(t.length<this.min_length)for(const r of this.eos_token_id)i.data[r]=-1/0;return i}}class MinNewTokensLengthLogitsProcessor extends LogitsProcessor{constructor(t,i,r){super(),this.prompt_length_to_skip=t,this.min_new_tokens=i,this.eos_token_id=Array.isArray(r)?r:[r]}_call(t,i){if(t.length-this.prompt_length_to_skip<this.min_new_tokens)for(const o of this.eos_token_id)i.data[o]=-1/0;return i}}class NoBadWordsLogitsProcessor extends LogitsProcessor{constructor(t,i){super(),this.bad_words_ids=t,this.eos_token_id=Array.isArray(i)?i:[i]}_call(t,i){for(const r of this.bad_words_ids){let o=!0;for(let l=1;l<=r.length-1&&r.length<t.length;++l)if(r.at(-l-1)!==t.at(-l)){o=!1;break}o&&(i.data[r.at(-1)]=-1/0)}return i}}class GenerationConfig{constructor(t={}){this.max_length=t.max_length??20,this.max_new_tokens=t.max_new_tokens??null,this.min_length=t.min_length??0,this.min_new_tokens=t.min_new_tokens??null,this.early_stopping=t.early_stopping??!1,this.max_time=t.max_time??null,this.do_sample=t.do_sample??!1,this.num_beams=t.num_beams??1,this.num_beam_groups=t.num_beam_groups??1,this.penalty_alpha=t.penalty_alpha??null,this.use_cache=t.use_cache??!0,this.temperature=t.temperature??1,this.top_k=t.top_k??50,this.top_p=t.top_p??1,this.typical_p=t.typical_p??1,this.epsilon_cutoff=t.epsilon_cutoff??0,this.eta_cutoff=t.eta_cutoff??0,this.diversity_penalty=t.diversity_penalty??0,this.repetition_penalty=t.repetition_penalty??1,this.encoder_repetition_penalty=t.encoder_repetition_penalty??1,this.length_penalty=t.length_penalty??1,this.no_repeat_ngram_size=t.no_repeat_ngram_size??0,this.bad_words_ids=t.bad_words_ids??null,this.force_words_ids=t.force_words_ids??null,this.renormalize_logits=t.renormalize_logits??!1,this.constraints=t.constraints??null,this.forced_bos_token_id=t.forced_bos_token_id??null,this.forced_eos_token_id=t.forced_eos_token_id??null,this.remove_invalid_values=t.remove_invalid_values??!1,this.exponential_decay_length_penalty=t.exponential_decay_length_penalty??null,this.suppress_tokens=t.suppress_tokens??null,this.begin_suppress_tokens=t.begin_suppress_tokens??null,this.forced_decoder_ids=t.forced_decoder_ids??null,this.num_return_sequences=t.num_return_sequences??1,this.output_attentions=t.output_attentions??!1,this.output_hidden_states=t.output_hidden_states??!1,this.output_scores=t.output_scores??!1,this.return_dict_in_generate=t.return_dict_in_generate??!1,this.pad_token_id=t.pad_token_id??null,this.bos_token_id=t.bos_token_id??null,this.eos_token_id=t.eos_token_id??null,this.encoder_no_repeat_ngram_size=t.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=t.decoder_start_token_id??null,this.generation_kwargs=t.generation_kwargs??{}}}class Sampler extends Callable{constructor(t){super(),this.generation_config=t}_call(t,i=-1){return this.sample(t,i)}sample(t,i){throw Error("sample should be implemented in subclasses.")}getLogits(t,i){let r=t.dims.at(-1),o=t.data;if(i===-1)o=o.slice(-r);else{let l=i*r;o=o.slice(l,l+r)}return this.generation_config.temperature>0&&(o=o.map(l=>l/this.generation_config.temperature)),o}randomSelect(t){let i=t.reduce((o,l)=>o+l,0),r=Math.random()*i;for(let o=0;o<t.length;++o)if(r-=t[o],r<=0)return o;return 0}static getSampler(t){if(t.do_sample)return new MultinomialSampler(t);if(t.num_beams>1)return new BeamSearchSampler(t);if(t.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${t.num_return_sequences}.`);return new GreedySampler(t)}}class GreedySampler extends Sampler{sample(t,i=-1){let r=this.getLogits(t,i);return[[max$2(r)[1],0]]}}class MultinomialSampler extends Sampler{sample(t,i=-1){let r=t.dims.at(-1);this.generation_config.top_k>0&&(r=Math.min(this.generation_config.top_k,r));const o=this.getLogits(t,i),l=getTopItems(o,r),a=softmax(l.map(f=>f[1]));return Array.from({length:this.generation_config.num_beams},()=>{const f=this.randomSelect(a);return[l[f][0],Math.log(a[f])]})}}class BeamSearchSampler extends Sampler{sample(t,i=-1){let r=t.dims.at(-1);this.generation_config.top_k>0&&(r=Math.min(this.generation_config.top_k,r));const o=this.getLogits(t,i),l=getTopItems(o,r),a=softmax(l.map(f=>f[1]));return Array.from({length:this.generation_config.num_beams},(f,p)=>[l[p][0],Math.log(a[p])])}}const{InferenceSession,Tensor:ONNXTensor,env}=ONNX,MODEL_TYPES={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4},MODEL_TYPE_MAPPING=new Map,MODEL_NAME_TO_CLASS_MAPPING=new Map,MODEL_CLASS_TO_NAME_MAPPING=new Map;async function constructSession(d,t,i){let r=`onnx/${t}${i.quantized?"_quantized":""}.onnx`,o=await getModelFile(d,r,!0,i);try{return await InferenceSession.create(o,{executionProviders})}catch(l){if(executionProviders.length===1&&executionProviders[0]==="wasm")throw l;return console.warn(l),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await InferenceSession.create(o,{executionProviders:["wasm"]})}}function validateInputs(d,t){const i=Object.create(null),r=[];for(const a of d.inputNames){const f=t[a];if(!(f instanceof Tensor)){r.push(a);continue}i[a]=env.wasm.proxy?f.clone():f}if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const o=Object.keys(t).length,l=d.inputNames.length;if(o>l){let a=Object.keys(t).filter(f=>!d.inputNames.includes(f));console.warn(`WARNING: Too many inputs were provided (${o} > ${l}). The following inputs will be ignored: "${a.join(", ")}".`)}return i}async function sessionRun(d,t){const i=validateInputs(d,t);try{let r=await d.run(i);return r=replaceTensors(r),r}catch(r){throw console.error(`An error occurred during model execution: "${r}".`),console.error("Inputs given to model:",i),r}}function replaceTensors(d){for(let t in d)d[t]instanceof ONNXTensor?d[t]=new Tensor(d[t]):typeof d[t]=="object"&&replaceTensors(d[t]);return d}function toI64Tensor(d){if(d instanceof Tensor)return d;if(d.length===0)throw Error("items must be non-empty");if(Array.isArray(d[0])){if(d.some(t=>t.length!==d[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new Tensor("int64",BigInt64Array.from(d.flat().map(t=>BigInt(t))),[d.length,d[0].length])}else return new Tensor("int64",BigInt64Array.from(d.map(t=>BigInt(t))),[1,d.length])}function prepareAttentionMask(d,t){let i=d.config.pad_token_id??null,r=d.config.eos_token_id??null;isIntegralNumber(r)&&(r=[r]);let o=t.indexOf(i)!==-1,l=r===null||!r.includes(i);if(o&&l){let a=BigInt64Array.from(t.data.map(f=>f!=i));return new Tensor("int64",a,t.dims)}else return ones_like(t)}function preparePositionIds(d,t,i){if(!d.inputNames.includes("position_ids"))return;const r=new BigInt64Array(t.attention_mask.data.length);for(let o=0;o<t.attention_mask.dims[0];++o){let l=o*t.attention_mask.dims[1],a=BigInt(0);for(let f=0;f<t.attention_mask.dims[1];++f){const p=l+f;t.attention_mask.data[p]===0n?r[p]=BigInt(1):(r[p]=a,a+=t.attention_mask.data[p])}}t.position_ids=new Tensor("int64",r,t.attention_mask.dims),i&&(t.position_ids=t.position_ids.slice(null,-1).unsqueeze_(-1))}function boolTensor(d){return new Tensor("bool",[d],[1])}async function seq2seqForward(d,t){let{encoder_outputs:i,past_key_values:r}=t;i||(i=(await encoderForward(d,t)).last_hidden_state);let o={input_ids:t.decoder_input_ids,encoder_hidden_states:i};const l=!!r;d.decoder_merged_session.inputNames.includes("use_cache_branch")&&(o.use_cache_branch=boolTensor(l)),d.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(o.encoder_attention_mask=t.attention_mask),preparePositionIds(d.decoder_merged_session,o,l),d.addPastKeyValues(o,r);const a=await sessionRun(d.decoder_merged_session,o);let f=a.logits;r=d.getPastKeyValues(a,r);const p=d.getAttentions(a);return new Seq2SeqLMOutput({logits:f,past_key_values:r,encoder_outputs:i,...p})}function seq2seqStartBeams(d,t,i,r){let o=[],l=0;const a=d.requires_attention_mask??!0;let f=i.decoder_input_ids??i.decoder_start_token_id??i.bos_token_id??i.eos_token_id;f instanceof Tensor?f=f.tolist().flat():Array.isArray(f)||(f=[f]);for(let p of t){p.dims=[1,...p.dims];let h={inputs:p,encoder_outputs:null,prev_model_outputs:null,output_token_ids:f,done:!1,score:0,id:l++};a&&(h.attention_mask=prepareAttentionMask(d,p)),o.push(h)}return o}async function seq2seqRunBeam(d,t){var a;const i=d.main_input_name;let r=t.output_token_ids;t.prev_model_outputs&&(r=r.slice(-1));let o={[i]:t.inputs,decoder_input_ids:toI64Tensor(r),encoder_outputs:t.encoder_outputs,past_key_values:(a=t.prev_model_outputs)==null?void 0:a.past_key_values};t.attention_mask&&(o.attention_mask=t.attention_mask);let l=await d.forward(o);return t.prev_model_outputs=l,t.encoder_outputs=l.encoder_outputs,l}function seq2seqUpdatebeam(d,t){d.output_token_ids=[...d.output_token_ids,t]}async function encoderForward(d,t){const i=Object.create(null);for(const r of d.session.inputNames)i[r]=t[r];return d.session.inputNames.includes("token_type_ids")&&!i.token_type_ids&&add_token_types(i),await sessionRun(d.session,i)}async function decoderForward(d,t){let{input_ids:i,past_key_values:r,attention_mask:o}=t,l={input_ids:i,attention_mask:o??prepareAttentionMask(d,i)};const a=!!r;d.session.inputNames.includes("use_cache_branch")&&(l.use_cache_branch=boolTensor(a)),preparePositionIds(d.session,l,a),d.addPastKeyValues(l,r);let f=await sessionRun(d.session,l),p=f.logits;return r=d.getPastKeyValues(f,r),{logits:p,past_key_values:r}}function decoderStartBeams(d,t,i,r,o){let l=[],a=0;for(let f of t){let p=f.tolist().map(Number);f.dims=[1,...f.dims];let h;o?(h=o[a],h.dims=[1,...h.dims]):h=prepareAttentionMask(d,f);let c={input:f,model_input_ids:f,attention_mask:h,prev_model_outputs:null,output_token_ids:p,num_output_tokens:r,done:!1,score:0,id:a++};l.push(c)}return l}async function decoderRunBeam(d,t){var l;let i=new BigInt64Array(t.output_token_ids.length).fill(1n),r={input_ids:t.model_input_ids,attention_mask:new Tensor("int64",i,[1,i.length]),past_key_values:(l=t.prev_model_outputs)==null?void 0:l.past_key_values},o=await d.forward(r);return t.prev_model_outputs=o,o}function decoderUpdatebeam(d,t){d.output_token_ids=[...d.output_token_ids,t],d.model_input_ids=new Tensor("int64",[BigInt(t)],[1,1])}class PreTrainedModel extends Callable{constructor(i,r){super();Be(this,"main_input_name","input_ids");this.config=i,this.session=r;const o=MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor),l=MODEL_TYPE_MAPPING.get(o);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,l===MODEL_TYPES.DecoderOnly?(this.can_generate=!0,this._runBeam=decoderRunBeam,this._getStartBeams=decoderStartBeams,this._updateBeam=decoderUpdatebeam,this._forward=decoderForward):l===MODEL_TYPES.Seq2Seq||l===MODEL_TYPES.Vision2Seq?(this.can_generate=!0,this._runBeam=seq2seqRunBeam,this._getStartBeams=seq2seqStartBeams,this._updateBeam=seq2seqUpdatebeam,this._forward=seq2seqForward):l===MODEL_TYPES.EncoderDecoder?this._forward=encoderForward:this._forward=encoderForward}async dispose(){const i=[];for(let r of Object.keys(this)){const o=this[r];o instanceof InferenceSession&&i.push(o.handler.dispose())}return await Promise.all(i)}static async from_pretrained(i,{quantized:r=!0,progress_callback:o=null,config:l=null,cache_dir:a=null,local_files_only:f=!1,revision:p="main",model_file_name:h=null}={}){let c={quantized:r,progress_callback:o,config:l,cache_dir:a,local_files_only:f,revision:p,model_file_name:h};const n=MODEL_CLASS_TO_NAME_MAPPING.get(this),e=MODEL_TYPE_MAPPING.get(n);let s;return e===MODEL_TYPES.DecoderOnly?s=await Promise.all([AutoConfig.from_pretrained(i,c),constructSession(i,c.model_file_name??"decoder_model_merged",c),getModelJSON(i,"generation_config.json",!1,c)]):e===MODEL_TYPES.Seq2Seq||e===MODEL_TYPES.Vision2Seq?s=await Promise.all([AutoConfig.from_pretrained(i,c),constructSession(i,"encoder_model",c),constructSession(i,"decoder_model_merged",c),getModelJSON(i,"generation_config.json",!1,c)]):e===MODEL_TYPES.EncoderDecoder?s=await Promise.all([AutoConfig.from_pretrained(i,c),constructSession(i,"encoder_model",c),constructSession(i,"decoder_model_merged",c)]):(e!==MODEL_TYPES.EncoderOnly&&console.warn(`Model type for '${n}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),s=await Promise.all([AutoConfig.from_pretrained(i,c),constructSession(i,c.model_file_name??"model",c)])),new this(...s)}async _call(i){return await this.forward(i)}async forward(i){return await this._forward(this,i)}_get_logits_processor(i,r,o=null){const l=new LogitsProcessorList;if(i.repetition_penalty!==null&&i.repetition_penalty!==1&&l.push(new RepetitionPenaltyLogitsProcessor(i.repetition_penalty)),i.no_repeat_ngram_size!==null&&i.no_repeat_ngram_size>0&&l.push(new NoRepeatNGramLogitsProcessor(i.no_repeat_ngram_size)),i.bad_words_ids!==null&&l.push(new NoBadWordsLogitsProcessor(i.bad_words_ids,i.eos_token_id)),i.min_length!==null&&i.eos_token_id!==null&&i.min_length>0&&l.push(new MinLengthLogitsProcessor(i.min_length,i.eos_token_id)),i.min_new_tokens!==null&&i.eos_token_id!==null&&i.min_new_tokens>0&&l.push(new MinNewTokensLengthLogitsProcessor(r,i.min_new_tokens,i.eos_token_id)),i.forced_bos_token_id!==null&&l.push(new ForcedBOSTokenLogitsProcessor(i.forced_bos_token_id)),i.forced_eos_token_id!==null&&l.push(new ForcedEOSTokenLogitsProcessor(i.max_length,i.forced_eos_token_id)),i.begin_suppress_tokens!==null){let a=r>1||i.forced_bos_token_id===null?r:r+1;i.forced_decoder_ids!==null&&(a+=i.forced_decoder_ids[i.forced_decoder_ids.length-1][0]),l.push(new SuppressTokensAtBeginLogitsProcessor(i.begin_suppress_tokens,a))}return i.forced_decoder_ids!==null&&l.push(new ForceTokensLogitsProcessor(i.forced_decoder_ids)),o!==null&&l.extend(o),l}_get_generation_config(i){let r=new GenerationConfig(this.config);return"generation_config"in this&&Object.assign(r,this.generation_config),i!==null&&Object.assign(r,i),r}async generate(i,r=null,o=null,{inputs_attention_mask:l=null}={}){if(!this.can_generate){let g=`The current model class (${MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;const _=this.config.model_type,y=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(_)??MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES.get(_)??MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES.get(_)??MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(_);throw y&&(g+=` Please use the following class instead: '${y[0]}'`),Error(g)}if(!(i instanceof Tensor)&&!isTypedArray(i)&&!Array.isArray(i))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${i.constructor.name}".`);let a;if(this.config.is_encoder_decoder)a=0;else if(a=i instanceof Tensor?i.dims.at(-1):i.length,a===0)throw Error("Must supply a non-empty array of input token ids.");r=this._get_generation_config(r),o=o??new LogitsProcessorList,o=this._get_logits_processor(r,a,o);let f=r.eos_token_id;f!==null&&!Array.isArray(f)&&(f=[f]);let p=1;const h=p+(r.max_new_tokens??1/0),c=Number.isInteger(r.max_length)&&(r.max_new_tokens??null)===null;let n=Sampler.getSampler(r),e=this.getStartBeams(i,r,p,l);for(;e.some(b=>!b.done)&&p<h;){let b=[];for(let g of e){if(g.done){b.push(g);continue}if(c&&g.output_token_ids.length>=r.max_length){g.done=!0,b.push(g);continue}let _=await this.runBeam(g);r.output_attentions&&this.addAttentionsToBeam(g,_),r.output_scores;let y=_.logits.slice(null,-1,null);o(g.output_token_ids,y);let v=n(y);for(let[w,M]of v){let S={...g};this.updateBeam(S,w),S.score+=M,f&&f.includes(w)&&(S.done=!0),b.push(S)}}++p,b=this.groupBeams(b).map(g=>g.sort((_,y)=>y.score-_.score).slice(0,r.num_beams)),e=b.flat(),r.callback_function&&r.callback_function(e)}const s=this.groupBeams(e),u=b=>s.map(g=>r.num_return_sequences>1?g.slice(0,r.num_return_sequences).map(_=>_[b]):[g[0][b]]).flat(),m=u("output_token_ids");if(r.return_dict_in_generate){const b=u("decoder_attentions"),g=u("cross_attentions");return{sequences:m,decoder_attentions:b,cross_attentions:g}}else return m}addAttentionsToBeam(i,r){if(this.config.is_encoder_decoder){if(!r.cross_attentions||r.cross_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");i.cross_attentions||(i.cross_attentions=[]),i.cross_attentions.push(r.cross_attentions)}if(!r.decoder_attentions||r.decoder_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");i.decoder_attentions||(i.decoder_attentions=[]),i.decoder_attentions.push(r.decoder_attentions)}groupBeams(i){const r=Object.create(null);for(const o of i)r[o.id]===void 0?r[o.id]=[o]:r[o.id].push(o);return Object.values(r)}getPastKeyValues(i,r){const o=Object.create(null);for(const l in i)if(l.startsWith("present")){let a=l.replace("present","past_key_values");r&&l.includes("encoder")?o[a]=r[a]:o[a]=i[l]}return o}getAttentions(i){const r=Object.create(null);for(const o of["cross_attentions","decoder_attentions"]){const l=[];for(const a in i)if(a.startsWith(o)){const f=a.split(".").pop();l[f]=i[a]}r[o]=l}return r}addPastKeyValues(i,r){if(r)Object.assign(i,r);else if(this.config.is_encoder_decoder&&(this.add_encoder_pkv??!0)){let l=[1,this.num_encoder_heads,0,this.encoder_dim_kv],a=[1,this.num_decoder_heads,0,this.decoder_dim_kv];for(let f=0;f<this.num_decoder_layers;++f)i[`past_key_values.${f}.encoder.key`]=new Tensor("float32",[],l),i[`past_key_values.${f}.encoder.value`]=new Tensor("float32",[],l),i[`past_key_values.${f}.decoder.key`]=new Tensor("float32",[],a),i[`past_key_values.${f}.decoder.value`]=new Tensor("float32",[],a)}else if(this.config.model_type==="falcon"){let l=[1*this.num_heads,0,this.dim_kv];for(let a=0;a<this.num_layers;++a)i[`past_key_values.${a}.key`]=new Tensor("float32",[],l),i[`past_key_values.${a}.value`]=new Tensor("float32",[],l)}else if(this.config.multi_query){let l=[1*this.num_heads,0,2*this.dim_kv];for(let a=0;a<this.num_layers;++a)i[`past_key_values.${a}.key_value`]=new Tensor("float32",[],l)}else if(this.config.model_type==="bloom"){let l=[1*this.num_heads,this.dim_kv,0],a=[1*this.num_heads,0,this.dim_kv];for(let f=0;f<this.num_layers;++f)i[`past_key_values.${f}.key`]=new Tensor("float32",[],l),i[`past_key_values.${f}.value`]=new Tensor("float32",[],a)}else{let l=[1,this.num_heads,0,this.dim_kv];for(let a=0;a<this.num_layers;++a)i[`past_key_values.${a}.key`]=new Tensor("float32",[],l),i[`past_key_values.${a}.value`]=new Tensor("float32",[],l)}}getStartBeams(i,r,o,l){return this._getStartBeams(this,i,r,o,l)}async runBeam(i){return await this._runBeam(this,i)}updateBeam(i,r){return this._updateBeam(i,r)}}class ModelOutput{}class BertPreTrainedModel extends PreTrainedModel{}class BertModel extends BertPreTrainedModel{}class BertForMaskedLM extends BertPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class BertForSequenceClassification extends BertPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class BertForTokenClassification extends BertPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class BertForQuestionAnswering extends BertPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class RoFormerPreTrainedModel extends PreTrainedModel{}class RoFormerModel extends RoFormerPreTrainedModel{}class RoFormerForMaskedLM extends RoFormerPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class RoFormerForSequenceClassification extends RoFormerPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class RoFormerForTokenClassification extends RoFormerPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class ConvBertPreTrainedModel extends PreTrainedModel{}class ConvBertModel extends ConvBertPreTrainedModel{}class ConvBertForMaskedLM extends ConvBertPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class ConvBertForSequenceClassification extends ConvBertPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class ConvBertForTokenClassification extends ConvBertPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class ElectraPreTrainedModel extends PreTrainedModel{}class ElectraModel extends ElectraPreTrainedModel{}class ElectraForMaskedLM extends ElectraPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class ElectraForSequenceClassification extends ElectraPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class ElectraForTokenClassification extends ElectraPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class ElectraForQuestionAnswering extends ElectraPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class CamembertPreTrainedModel extends PreTrainedModel{}class CamembertModel extends CamembertPreTrainedModel{}class CamembertForMaskedLM extends CamembertPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class CamembertForSequenceClassification extends CamembertPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class CamembertForTokenClassification extends CamembertPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class CamembertForQuestionAnswering extends CamembertPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class DebertaPreTrainedModel extends PreTrainedModel{}class DebertaModel extends DebertaPreTrainedModel{}class DebertaForMaskedLM extends DebertaPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class DebertaForSequenceClassification extends DebertaPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class DebertaForTokenClassification extends DebertaPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class DebertaForQuestionAnswering extends DebertaPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class DebertaV2PreTrainedModel extends PreTrainedModel{}class DebertaV2Model extends DebertaV2PreTrainedModel{}class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class DistilBertPreTrainedModel extends PreTrainedModel{}class DistilBertModel extends DistilBertPreTrainedModel{}class DistilBertForSequenceClassification extends DistilBertPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class DistilBertForTokenClassification extends DistilBertPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class DistilBertForMaskedLM extends DistilBertPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class EsmPreTrainedModel extends PreTrainedModel{}class EsmModel extends EsmPreTrainedModel{}class EsmForMaskedLM extends EsmPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class EsmForSequenceClassification extends EsmPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class EsmForTokenClassification extends EsmPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class MobileBertPreTrainedModel extends PreTrainedModel{}class MobileBertModel extends MobileBertPreTrainedModel{}class MobileBertForMaskedLM extends MobileBertPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class MobileBertForSequenceClassification extends MobileBertPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class MPNetPreTrainedModel extends PreTrainedModel{}class MPNetModel extends MPNetPreTrainedModel{}class MPNetForMaskedLM extends MPNetPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class MPNetForSequenceClassification extends MPNetPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class MPNetForTokenClassification extends MPNetPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class MPNetForQuestionAnswering extends MPNetPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class SqueezeBertPreTrainedModel extends PreTrainedModel{}class SqueezeBertModel extends SqueezeBertPreTrainedModel{}class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class AlbertPreTrainedModel extends PreTrainedModel{}class AlbertModel extends AlbertPreTrainedModel{}class AlbertForSequenceClassification extends AlbertPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class AlbertForQuestionAnswering extends AlbertPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class AlbertForMaskedLM extends AlbertPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class T5PreTrainedModel extends PreTrainedModel{}class T5Model extends T5PreTrainedModel{}class T5ForConditionalGeneration extends T5PreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class LongT5PreTrainedModel extends PreTrainedModel{}class LongT5Model extends LongT5PreTrainedModel{}class LongT5ForConditionalGeneration extends LongT5PreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class MT5PreTrainedModel extends PreTrainedModel{}class MT5Model extends MT5PreTrainedModel{}class MT5ForConditionalGeneration extends MT5PreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class BartPretrainedModel extends PreTrainedModel{}class BartModel extends BartPretrainedModel{}class BartForConditionalGeneration extends BartPretrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BartForSequenceClassification extends BartPretrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class MBartPreTrainedModel extends PreTrainedModel{}class MBartModel extends MBartPreTrainedModel{}class MBartForConditionalGeneration extends MBartPreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class MBartForSequenceClassification extends MBartPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class MBartForCausalLM extends MBartPreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotPreTrainedModel extends PreTrainedModel{}class BlenderbotModel extends BlenderbotPreTrainedModel{}class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotSmallPreTrainedModel extends PreTrainedModel{}class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel{}class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class RobertaPreTrainedModel extends PreTrainedModel{}class RobertaModel extends RobertaPreTrainedModel{}class RobertaForMaskedLM extends RobertaPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class RobertaForSequenceClassification extends RobertaPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class RobertaForTokenClassification extends RobertaPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class RobertaForQuestionAnswering extends RobertaPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class XLMPreTrainedModel extends PreTrainedModel{}class XLMModel extends XLMPreTrainedModel{}class XLMWithLMHeadModel extends XLMPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class XLMForSequenceClassification extends XLMPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class XLMForTokenClassification extends XLMPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class XLMForQuestionAnswering extends XLMPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class XLMRobertaPreTrainedModel extends PreTrainedModel{}class XLMRobertaModel extends XLMRobertaPreTrainedModel{}class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel{async _call(t){return new MaskedLMOutput(await super._call(t))}}class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel{async _call(t){return new TokenClassifierOutput(await super._call(t))}}class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel{async _call(t){return new QuestionAnsweringModelOutput(await super._call(t))}}class ASTPreTrainedModel extends PreTrainedModel{}class ASTModel extends ASTPreTrainedModel{}class ASTForAudioClassification extends ASTPreTrainedModel{}class WhisperPreTrainedModel extends PreTrainedModel{}class WhisperModel extends WhisperPreTrainedModel{}class WhisperForConditionalGeneration extends WhisperPreTrainedModel{constructor(i,r,o,l){super(i,r);Be(this,"requires_attention_mask",!1);Be(this,"main_input_name","input_features");this.decoder_merged_session=o,this.generation_config=l,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(i,r=null,o=null){if(r=this._get_generation_config(r),r.return_timestamps??(r.return_timestamps=!1),r.return_timestamps&&(o=[new WhisperTimeStampLogitsProcessor(r)]),r.return_token_timestamps&&(r.output_attentions=!0,r.return_dict_in_generate=!0,r.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!r.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const l=await super.generate(i,r,o);return r.return_token_timestamps&&r.alignment_heads&&(l.token_timestamps=this._extract_token_timestamps(l,r.alignment_heads,r.num_frames)),l}_extract_token_timestamps(i,r,o=null,l=.02){if(!i.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let a=this.config.median_filter_width;a===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),a=7);const f=i.cross_attentions.map(c=>{let n=Array.from({length:this.config.decoder_layers},(g,_)=>cat(c.map(y=>y[_]),2)),e=stack(r.map(([g,_])=>o?n[g].slice(null,_,null,[0,o]):n[g].slice(null,_)));e=e.transpose(1,0,2,3);let[s,u]=std_mean(e,-2,0,!0),m=e.clone();for(let g=0;g<m.dims[0];++g){let _=m[g];for(let y=0;y<_.dims[0];++y){let v=_[y];const w=s[g][y][0],M=u[g][y][0];for(let S=0;S<v.dims[0];++S){let O=v[S];for(let x=0;x<O.data.length;++x)O.data[x]=(O.data[x]-M.data[x])/w.data[x];O.data.set(medianFilter(O.data,a))}}}return mean$1(m,1)}),p=[i.sequences.length,i.sequences[0].length],h=new Tensor("float32",new Float32Array(p[0]*p[1]),p);for(let c=0;c<p[0];++c){const n=f[c].neg().squeeze_(0);let[e,s]=dynamicTimeWarping(n),u=Array.from({length:e.length-1},(g,_)=>e[_+1]-e[_]),m=mergeArrays([1],u).map(g=>!!g),b=[];for(let g=0;g<m.length;++g)m[g]&&b.push(s[g]*l);h[c].data.set(b,1)}return h}}class VisionEncoderDecoderModel extends PreTrainedModel{constructor(i,r,o,l){super(i,r);Be(this,"main_input_name","pixel_values");this.decoder_merged_session=o,this.generation_config=l;const a=this.config.encoder,f=this.config.decoder,p=a.model_type;(MODEL_MAPPING_NAMES_ENCODER_ONLY.get(p)??MODEL_MAPPING_NAMES_ENCODER_DECODER.get(p))||console.warn(`Model type for encoder '${p}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);const c=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(f.model_type);if(!c)throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);const n=c[1],e=new n(f,o,l);this.add_encoder_pkv="num_decoder_layers"in e,this.add_encoder_pkv?(this.num_decoder_layers=e.num_decoder_layers,this.num_decoder_heads=e.num_decoder_heads,this.decoder_dim_kv=e.decoder_dim_kv,this.num_encoder_layers=e.num_encoder_layers,this.num_encoder_heads=e.num_encoder_heads,this.encoder_dim_kv=e.encoder_dim_kv):(this.num_layers=e.num_layers,this.num_heads=e.num_heads,this.dim_kv=e.dim_kv)}}class CLIPPreTrainedModel extends PreTrainedModel{}class CLIPModel extends CLIPPreTrainedModel{}class CLIPTextModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(t,i={}){return i.model_file_name??(i.model_file_name="text_model"),super.from_pretrained(t,i)}}class CLIPVisionModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(t,i={}){return i.model_file_name??(i.model_file_name="vision_model"),super.from_pretrained(t,i)}}class SiglipPreTrainedModel extends PreTrainedModel{}class SiglipModel extends SiglipPreTrainedModel{}class SiglipTextModel extends SiglipPreTrainedModel{static async from_pretrained(t,i={}){return i.model_file_name??(i.model_file_name="text_model"),super.from_pretrained(t,i)}}class SiglipVisionModel extends CLIPPreTrainedModel{static async from_pretrained(t,i={}){return i.model_file_name??(i.model_file_name="vision_model"),super.from_pretrained(t,i)}}class ChineseCLIPPreTrainedModel extends PreTrainedModel{}class ChineseCLIPModel extends ChineseCLIPPreTrainedModel{}class CLIPSegPreTrainedModel extends PreTrainedModel{}class CLIPSegModel extends CLIPSegPreTrainedModel{}class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel{}class GPT2PreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPT2Model extends GPT2PreTrainedModel{}class GPT2LMHeadModel extends GPT2PreTrainedModel{}class GPTNeoPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoModel extends GPTNeoPreTrainedModel{}class GPTNeoForCausalLM extends GPTNeoPreTrainedModel{}class GPTNeoXPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoXModel extends GPTNeoXPreTrainedModel{}class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel{}class GPTJPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTJModel extends GPTJPreTrainedModel{}class GPTJForCausalLM extends GPTJPreTrainedModel{}class GPTBigCodePreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTBigCodeModel extends GPTBigCodePreTrainedModel{}class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel{}class CodeGenPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class CodeGenModel extends CodeGenPreTrainedModel{}class CodeGenForCausalLM extends CodeGenPreTrainedModel{}class LlamaPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class LlamaModel extends LlamaPreTrainedModel{}class LlamaForCausalLM extends LlamaPreTrainedModel{}class PhiPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class PhiModel extends PhiPreTrainedModel{}class PhiForCausalLM extends PhiPreTrainedModel{}class BloomPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class BloomModel extends BloomPreTrainedModel{}class BloomForCausalLM extends BloomPreTrainedModel{}class MptPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class MptModel extends MptPreTrainedModel{}class MptForCausalLM extends MptPreTrainedModel{}class OPTPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class OPTModel extends OPTPreTrainedModel{}class OPTForCausalLM extends OPTPreTrainedModel{}class ViTPreTrainedModel extends PreTrainedModel{}class ViTModel extends ViTPreTrainedModel{}class ViTForImageClassification extends ViTPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class VitMattePreTrainedModel extends PreTrainedModel{}class VitMatteForImageMatting extends VitMattePreTrainedModel{async _call(t){return new ImageMattingOutput(await super._call(t))}}class MobileViTPreTrainedModel extends PreTrainedModel{}class MobileViTModel extends MobileViTPreTrainedModel{}class MobileViTForImageClassification extends MobileViTPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class OwlViTPreTrainedModel extends PreTrainedModel{}class OwlViTModel extends OwlViTPreTrainedModel{}class OwlViTForObjectDetection extends OwlViTPreTrainedModel{}class BeitPreTrainedModel extends PreTrainedModel{}class BeitModel extends BeitPreTrainedModel{}class BeitForImageClassification extends BeitPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class DetrPreTrainedModel extends PreTrainedModel{}class DetrModel extends DetrPreTrainedModel{}class DetrForObjectDetection extends DetrPreTrainedModel{async _call(t){return new DetrObjectDetectionOutput(await super._call(t))}}class DetrForSegmentation extends DetrPreTrainedModel{async _call(t){return new DetrSegmentationOutput(await super._call(t))}}class DetrObjectDetectionOutput extends ModelOutput{constructor({logits:t,pred_boxes:i}){super(),this.logits=t,this.pred_boxes=i}}class DetrSegmentationOutput extends ModelOutput{constructor({logits:t,pred_boxes:i,pred_masks:r}){super(),this.logits=t,this.pred_boxes=i,this.pred_masks=r}}class TableTransformerPreTrainedModel extends PreTrainedModel{}class TableTransformerModel extends TableTransformerPreTrainedModel{}class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel{async _call(t){return new TableTransformerObjectDetectionOutput(await super._call(t))}}class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput{}class DeiTPreTrainedModel extends PreTrainedModel{}class DeiTModel extends DeiTPreTrainedModel{}class DeiTForImageClassification extends DeiTPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class ResNetPreTrainedModel extends PreTrainedModel{}class ResNetModel extends ResNetPreTrainedModel{}class ResNetForImageClassification extends ResNetPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class SwinPreTrainedModel extends PreTrainedModel{}class SwinModel extends SwinPreTrainedModel{}class SwinForImageClassification extends SwinPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class Swin2SRPreTrainedModel extends PreTrainedModel{}class Swin2SRModel extends Swin2SRPreTrainedModel{}class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel{}class DPTPreTrainedModel extends PreTrainedModel{}class DPTModel extends DPTPreTrainedModel{}class DPTForDepthEstimation extends DPTPreTrainedModel{}class GLPNPreTrainedModel extends PreTrainedModel{}class GLPNModel extends GLPNPreTrainedModel{}class GLPNForDepthEstimation extends GLPNPreTrainedModel{}class DonutSwinPreTrainedModel extends PreTrainedModel{}class DonutSwinModel extends DonutSwinPreTrainedModel{}class ConvNextPreTrainedModel extends PreTrainedModel{}class ConvNextModel extends ConvNextPreTrainedModel{}class ConvNextForImageClassification extends ConvNextPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class ConvNextV2PreTrainedModel extends PreTrainedModel{}class ConvNextV2Model extends ConvNextV2PreTrainedModel{}class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class Dinov2PreTrainedModel extends PreTrainedModel{}class Dinov2Model extends Dinov2PreTrainedModel{}class Dinov2ForImageClassification extends Dinov2PreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class YolosPreTrainedModel extends PreTrainedModel{}class YolosModel extends YolosPreTrainedModel{}class YolosForObjectDetection extends YolosPreTrainedModel{async _call(t){return new YolosObjectDetectionOutput(await super._call(t))}}class YolosObjectDetectionOutput extends ModelOutput{constructor({logits:t,pred_boxes:i}){super(),this.logits=t,this.pred_boxes=i}}class SamPreTrainedModel extends PreTrainedModel{}class SamModel extends SamPreTrainedModel{async _call(t){return new SamImageSegmentationOutput(await super._call(t))}}class SamImageSegmentationOutput extends ModelOutput{constructor({iou_scores:t,pred_masks:i}){super(),this.iou_scores=t,this.pred_masks=i}}class MarianPreTrainedModel extends PreTrainedModel{}class MarianModel extends MarianPreTrainedModel{}class MarianMTModel extends MarianPreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class M2M100PreTrainedModel extends PreTrainedModel{}class M2M100Model extends M2M100PreTrainedModel{}class M2M100ForConditionalGeneration extends M2M100PreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Wav2Vec2PreTrainedModel extends PreTrainedModel{}class Wav2Vec2Model extends Wav2Vec2PreTrainedModel{}class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel{async _call(t){return new CausalLMOutput(await super._call(t))}}class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class HubertModel extends Wav2Vec2PreTrainedModel{}class HubertForCTC extends Wav2Vec2PreTrainedModel{async _call(t){return new CausalLMOutput(await super._call(t))}}class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class WavLMPreTrainedModel extends PreTrainedModel{}class WavLMModel extends WavLMPreTrainedModel{}class WavLMForCTC extends WavLMPreTrainedModel{async _call(t){return new CausalLMOutput(await super._call(t))}}class WavLMForSequenceClassification extends WavLMPreTrainedModel{async _call(t){return new SequenceClassifierOutput(await super._call(t))}}class SpeechT5PreTrainedModel extends PreTrainedModel{}class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel{}class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel{constructor(t,i,r,o){super(t,i),this.decoder_merged_session=r,this.generation_config=o,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.hidden_size/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.hidden_size/this.num_encoder_heads}async generate_speech(t,i,{threshold:r=.5,minlenratio:o=0,maxlenratio:l=20,vocoder:a=null}={}){const f={input_ids:t},{encoder_outputs:p,encoder_attention_mask:h}=await encoderForward(this,f),c=p.dims[1]/this.config.reduction_factor,n=Math.floor(c*l),e=Math.floor(c*o),s=this.config.num_mel_bins;let u=[],m=null,b=null,g=0;for(;;){++g;const v=boolTensor(!!b);let w;b?w=b.output_sequence_out:w=new Tensor("float32",new Float32Array(s),[1,1,s]);let M={use_cache_branch:v,output_sequence:w,encoder_attention_mask:h,speaker_embeddings:i,encoder_hidden_states:p};this.addPastKeyValues(M,m),b=await sessionRun(this.decoder_merged_session,M),m=this.getPastKeyValues(b,m);const{prob:S,spectrum:O}=b;if(u.push(O),g>=e&&(Array.from(S.data).filter(x=>x>=r).length>0||g>=n))break}const _=cat(u),{waveform:y}=await sessionRun(a.session,{spectrogram:_});return{spectrogram:_,waveform:y}}}class SpeechT5HifiGan extends PreTrainedModel{constructor(){super(...arguments);Be(this,"main_input_name","spectrogram")}}class TrOCRPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_encoder_layers=this.num_decoder_layers=this.config.decoder_layers,this.num_encoder_heads=this.num_decoder_heads=this.config.decoder_attention_heads,this.encoder_dim_kv=this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads}}class TrOCRForCausalLM extends TrOCRPreTrainedModel{}class MistralPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class MistralModel extends MistralPreTrainedModel{}class MistralForCausalLM extends MistralPreTrainedModel{}class FalconPreTrainedModel extends PreTrainedModel{constructor(t,i,r){super(t,i),this.generation_config=r,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class FalconModel extends FalconPreTrainedModel{}class FalconForCausalLM extends FalconPreTrainedModel{}class ClapPreTrainedModel extends PreTrainedModel{}class ClapModel extends ClapPreTrainedModel{}class ClapTextModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(t,i={}){return i.model_file_name??(i.model_file_name="text_model"),super.from_pretrained(t,i)}}class ClapAudioModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(t,i={}){return i.model_file_name??(i.model_file_name="audio_model"),super.from_pretrained(t,i)}}class VitsPreTrainedModel extends PreTrainedModel{}class VitsModel extends VitsPreTrainedModel{async _call(t){return new VitsModelOutput(await super._call(t))}}class SegformerPreTrainedModel extends PreTrainedModel{}class SegformerForImageClassification extends SegformerPreTrainedModel{}class SegformerForSemanticSegmentation extends SegformerPreTrainedModel{}const MODEL_MAPPING_NAMES_ENCODER_ONLY=new Map([["bert",["BertModel",BertModel]],["roformer",["RoFormerModel",RoFormerModel]],["electra",["ElectraModel",ElectraModel]],["esm",["EsmModel",EsmModel]],["convbert",["ConvBertModel",ConvBertModel]],["camembert",["CamembertModel",CamembertModel]],["deberta",["DebertaModel",DebertaModel]],["deberta-v2",["DebertaV2Model",DebertaV2Model]],["mpnet",["MPNetModel",MPNetModel]],["albert",["AlbertModel",AlbertModel]],["distilbert",["DistilBertModel",DistilBertModel]],["roberta",["RobertaModel",RobertaModel]],["xlm",["XLMModel",XLMModel]],["xlm-roberta",["XLMRobertaModel",XLMRobertaModel]],["clap",["ClapModel",ClapModel]],["clip",["CLIPModel",CLIPModel]],["clipseg",["CLIPSegModel",CLIPSegModel]],["chinese_clip",["ChineseCLIPModel",ChineseCLIPModel]],["siglip",["SiglipModel",SiglipModel]],["mobilebert",["MobileBertModel",MobileBertModel]],["squeezebert",["SqueezeBertModel",SqueezeBertModel]],["wav2vec2",["Wav2Vec2Model",Wav2Vec2Model]],["hubert",["HubertModel",HubertModel]],["wavlm",["WavLMModel",WavLMModel]],["audio-spectrogram-transformer",["ASTModel",ASTModel]],["vits",["VitsModel",VitsModel]],["detr",["DetrModel",DetrModel]],["table-transformer",["TableTransformerModel",TableTransformerModel]],["vit",["ViTModel",ViTModel]],["mobilevit",["MobileViTModel",MobileViTModel]],["owlvit",["OwlViTModel",OwlViTModel]],["beit",["BeitModel",BeitModel]],["deit",["DeiTModel",DeiTModel]],["convnext",["ConvNextModel",ConvNextModel]],["convnextv2",["ConvNextV2Model",ConvNextV2Model]],["dinov2",["Dinov2Model",Dinov2Model]],["resnet",["ResNetModel",ResNetModel]],["swin",["SwinModel",SwinModel]],["swin2sr",["Swin2SRModel",Swin2SRModel]],["donut-swin",["DonutSwinModel",DonutSwinModel]],["yolos",["YolosModel",YolosModel]],["dpt",["DPTModel",DPTModel]],["glpn",["GLPNModel",GLPNModel]],["hifigan",["SpeechT5HifiGan",SpeechT5HifiGan]],["sam",["SamModel",SamModel]]]),MODEL_MAPPING_NAMES_ENCODER_DECODER=new Map([["t5",["T5Model",T5Model]],["longt5",["LongT5Model",LongT5Model]],["mt5",["MT5Model",MT5Model]],["bart",["BartModel",BartModel]],["mbart",["MBartModel",MBartModel]],["marian",["MarianModel",MarianModel]],["whisper",["WhisperModel",WhisperModel]],["m2m_100",["M2M100Model",M2M100Model]],["blenderbot",["BlenderbotModel",BlenderbotModel]],["blenderbot-small",["BlenderbotSmallModel",BlenderbotSmallModel]]]),MODEL_MAPPING_NAMES_DECODER_ONLY=new Map([["bloom",["BloomModel",BloomModel]],["gpt2",["GPT2Model",GPT2Model]],["gptj",["GPTJModel",GPTJModel]],["gpt_bigcode",["GPTBigCodeModel",GPTBigCodeModel]],["gpt_neo",["GPTNeoModel",GPTNeoModel]],["gpt_neox",["GPTNeoXModel",GPTNeoXModel]],["codegen",["CodeGenModel",CodeGenModel]],["llama",["LlamaModel",LlamaModel]],["phi",["PhiModel",PhiModel]],["mpt",["MptModel",MptModel]],["opt",["OPTModel",OPTModel]],["mistral",["MistralModel",MistralModel]],["falcon",["FalconModel",FalconModel]]]),MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForSpeechToText",SpeechT5ForSpeechToText]],["whisper",["WhisperForConditionalGeneration",WhisperForConditionalGeneration]]]),MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForTextToSpeech",SpeechT5ForTextToSpeech]]]),MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES=new Map([["vits",["VitsModel",VitsModel]]]),MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForSequenceClassification",BertForSequenceClassification]],["roformer",["RoFormerForSequenceClassification",RoFormerForSequenceClassification]],["electra",["ElectraForSequenceClassification",ElectraForSequenceClassification]],["esm",["EsmForSequenceClassification",EsmForSequenceClassification]],["convbert",["ConvBertForSequenceClassification",ConvBertForSequenceClassification]],["camembert",["CamembertForSequenceClassification",CamembertForSequenceClassification]],["deberta",["DebertaForSequenceClassification",DebertaForSequenceClassification]],["deberta-v2",["DebertaV2ForSequenceClassification",DebertaV2ForSequenceClassification]],["mpnet",["MPNetForSequenceClassification",MPNetForSequenceClassification]],["albert",["AlbertForSequenceClassification",AlbertForSequenceClassification]],["distilbert",["DistilBertForSequenceClassification",DistilBertForSequenceClassification]],["roberta",["RobertaForSequenceClassification",RobertaForSequenceClassification]],["xlm",["XLMForSequenceClassification",XLMForSequenceClassification]],["xlm-roberta",["XLMRobertaForSequenceClassification",XLMRobertaForSequenceClassification]],["bart",["BartForSequenceClassification",BartForSequenceClassification]],["mbart",["MBartForSequenceClassification",MBartForSequenceClassification]],["mobilebert",["MobileBertForSequenceClassification",MobileBertForSequenceClassification]],["squeezebert",["SqueezeBertForSequenceClassification",SqueezeBertForSequenceClassification]]]),MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForTokenClassification",BertForTokenClassification]],["roformer",["RoFormerForTokenClassification",RoFormerForTokenClassification]],["electra",["ElectraForTokenClassification",ElectraForTokenClassification]],["esm",["EsmForTokenClassification",EsmForTokenClassification]],["convbert",["ConvBertForTokenClassification",ConvBertForTokenClassification]],["camembert",["CamembertForTokenClassification",CamembertForTokenClassification]],["deberta",["DebertaForTokenClassification",DebertaForTokenClassification]],["deberta-v2",["DebertaV2ForTokenClassification",DebertaV2ForTokenClassification]],["mpnet",["MPNetForTokenClassification",MPNetForTokenClassification]],["distilbert",["DistilBertForTokenClassification",DistilBertForTokenClassification]],["roberta",["RobertaForTokenClassification",RobertaForTokenClassification]],["xlm",["XLMForTokenClassification",XLMForTokenClassification]],["xlm-roberta",["XLMRobertaForTokenClassification",XLMRobertaForTokenClassification]]]),MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES=new Map([["t5",["T5ForConditionalGeneration",T5ForConditionalGeneration]],["longt5",["LongT5ForConditionalGeneration",LongT5ForConditionalGeneration]],["mt5",["MT5ForConditionalGeneration",MT5ForConditionalGeneration]],["bart",["BartForConditionalGeneration",BartForConditionalGeneration]],["mbart",["MBartForConditionalGeneration",MBartForConditionalGeneration]],["marian",["MarianMTModel",MarianMTModel]],["m2m_100",["M2M100ForConditionalGeneration",M2M100ForConditionalGeneration]],["blenderbot",["BlenderbotForConditionalGeneration",BlenderbotForConditionalGeneration]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",BlenderbotSmallForConditionalGeneration]]]),MODEL_WITH_LM_HEAD_MAPPING_NAMES=new Map([["bloom",["BloomForCausalLM",BloomForCausalLM]],["gpt2",["GPT2LMHeadModel",GPT2LMHeadModel]],["gptj",["GPTJForCausalLM",GPTJForCausalLM]],["gpt_bigcode",["GPTBigCodeForCausalLM",GPTBigCodeForCausalLM]],["gpt_neo",["GPTNeoForCausalLM",GPTNeoForCausalLM]],["gpt_neox",["GPTNeoXForCausalLM",GPTNeoXForCausalLM]],["codegen",["CodeGenForCausalLM",CodeGenForCausalLM]],["llama",["LlamaForCausalLM",LlamaForCausalLM]],["phi",["PhiForCausalLM",PhiForCausalLM]],["mpt",["MptForCausalLM",MptForCausalLM]],["opt",["OPTForCausalLM",OPTForCausalLM]],["mbart",["MBartForCausalLM",MBartForCausalLM]],["mistral",["MistralForCausalLM",MistralForCausalLM]],["falcon",["FalconForCausalLM",FalconForCausalLM]],["trocr",["TrOCRForCausalLM",TrOCRForCausalLM]]]),MODEL_FOR_MASKED_LM_MAPPING_NAMES=new Map([["bert",["BertForMaskedLM",BertForMaskedLM]],["roformer",["RoFormerForMaskedLM",RoFormerForMaskedLM]],["electra",["ElectraForMaskedLM",ElectraForMaskedLM]],["esm",["EsmForMaskedLM",EsmForMaskedLM]],["convbert",["ConvBertForMaskedLM",ConvBertForMaskedLM]],["camembert",["CamembertForMaskedLM",CamembertForMaskedLM]],["deberta",["DebertaForMaskedLM",DebertaForMaskedLM]],["deberta-v2",["DebertaV2ForMaskedLM",DebertaV2ForMaskedLM]],["mpnet",["MPNetForMaskedLM",MPNetForMaskedLM]],["albert",["AlbertForMaskedLM",AlbertForMaskedLM]],["distilbert",["DistilBertForMaskedLM",DistilBertForMaskedLM]],["roberta",["RobertaForMaskedLM",RobertaForMaskedLM]],["xlm",["XLMWithLMHeadModel",XLMWithLMHeadModel]],["xlm-roberta",["XLMRobertaForMaskedLM",XLMRobertaForMaskedLM]],["mobilebert",["MobileBertForMaskedLM",MobileBertForMaskedLM]],["squeezebert",["SqueezeBertForMaskedLM",SqueezeBertForMaskedLM]]]),MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["bert",["BertForQuestionAnswering",BertForQuestionAnswering]],["roformer",["RoFormerForQuestionAnswering",RoFormerForQuestionAnswering]],["electra",["ElectraForQuestionAnswering",ElectraForQuestionAnswering]],["convbert",["ConvBertForQuestionAnswering",ConvBertForQuestionAnswering]],["camembert",["CamembertForQuestionAnswering",CamembertForQuestionAnswering]],["deberta",["DebertaForQuestionAnswering",DebertaForQuestionAnswering]],["deberta-v2",["DebertaV2ForQuestionAnswering",DebertaV2ForQuestionAnswering]],["mpnet",["MPNetForQuestionAnswering",MPNetForQuestionAnswering]],["albert",["AlbertForQuestionAnswering",AlbertForQuestionAnswering]],["distilbert",["DistilBertForQuestionAnswering",DistilBertForQuestionAnswering]],["roberta",["RobertaForQuestionAnswering",RobertaForQuestionAnswering]],["xlm",["XLMForQuestionAnswering",XLMForQuestionAnswering]],["xlm-roberta",["XLMRobertaForQuestionAnswering",XLMRobertaForQuestionAnswering]],["mobilebert",["MobileBertForQuestionAnswering",MobileBertForQuestionAnswering]],["squeezebert",["SqueezeBertForQuestionAnswering",SqueezeBertForQuestionAnswering]]]),MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES=new Map([["vit",["ViTForImageClassification",ViTForImageClassification]],["mobilevit",["MobileViTForImageClassification",MobileViTForImageClassification]],["beit",["BeitForImageClassification",BeitForImageClassification]],["deit",["DeiTForImageClassification",DeiTForImageClassification]],["convnext",["ConvNextForImageClassification",ConvNextForImageClassification]],["convnextv2",["ConvNextV2ForImageClassification",ConvNextV2ForImageClassification]],["dinov2",["Dinov2ForImageClassification",Dinov2ForImageClassification]],["resnet",["ResNetForImageClassification",ResNetForImageClassification]],["swin",["SwinForImageClassification",SwinForImageClassification]],["segformer",["SegformerForImageClassification",SegformerForImageClassification]]]),MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES=new Map([["detr",["DetrForObjectDetection",DetrForObjectDetection]],["table-transformer",["TableTransformerForObjectDetection",TableTransformerForObjectDetection]],["yolos",["YolosForObjectDetection",YolosForObjectDetection]]]),MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES=new Map([["owlvit",["OwlViTForObjectDetection",OwlViTForObjectDetection]]]),MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES=new Map([["detr",["DetrForSegmentation",DetrForSegmentation]],["clipseg",["CLIPSegForImageSegmentation",CLIPSegForImageSegmentation]]]),MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES=new Map([["segformer",["SegformerForSemanticSegmentation",SegformerForSemanticSegmentation]]]),MODEL_FOR_MASK_GENERATION_MAPPING_NAMES=new Map([["sam",["SamModel",SamModel]]]),MODEL_FOR_CTC_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForCTC",Wav2Vec2ForCTC]],["wavlm",["WavLMForCTC",WavLMForCTC]],["hubert",["HubertForCTC",HubertForCTC]]]),MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Wav2Vec2ForSequenceClassification]],["wavlm",["WavLMForSequenceClassification",WavLMForSequenceClassification]],["hubert",["HubertForSequenceClassification",HubertForSequenceClassification]],["audio-spectrogram-transformer",["ASTForAudioClassification",ASTForAudioClassification]]]),MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES=new Map([["vitmatte",["VitMatteForImageMatting",VitMatteForImageMatting]]]),MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Swin2SRForImageSuperResolution]]]),MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES=new Map([["dpt",["DPTForDepthEstimation",DPTForDepthEstimation]],["glpn",["GLPNForDepthEstimation",GLPNForDepthEstimation]]]),MODEL_CLASS_TYPE_MAPPING=[[MODEL_MAPPING_NAMES_ENCODER_ONLY,MODEL_TYPES.EncoderOnly],[MODEL_MAPPING_NAMES_ENCODER_DECODER,MODEL_TYPES.EncoderDecoder],[MODEL_MAPPING_NAMES_DECODER_ONLY,MODEL_TYPES.DecoderOnly],[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_WITH_LM_HEAD_MAPPING_NAMES,MODEL_TYPES.DecoderOnly],[MODEL_FOR_MASKED_LM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Vision2Seq],[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_MASK_GENERATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_CTC_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly]];for(const[d,t]of MODEL_CLASS_TYPE_MAPPING)for(const[i,r]of d.values())MODEL_TYPE_MAPPING.set(i,t),MODEL_CLASS_TO_NAME_MAPPING.set(r,i),MODEL_NAME_TO_CLASS_MAPPING.set(i,r);const CUSTOM_MAPPING=[["CLIPTextModelWithProjection",CLIPTextModelWithProjection,MODEL_TYPES.EncoderOnly],["CLIPVisionModelWithProjection",CLIPVisionModelWithProjection,MODEL_TYPES.EncoderOnly],["SiglipTextModel",SiglipTextModel,MODEL_TYPES.EncoderOnly],["SiglipVisionModel",SiglipVisionModel,MODEL_TYPES.EncoderOnly],["ClapTextModelWithProjection",ClapTextModelWithProjection,MODEL_TYPES.EncoderOnly],["ClapAudioModelWithProjection",ClapAudioModelWithProjection,MODEL_TYPES.EncoderOnly]];for(const[d,t,i]of CUSTOM_MAPPING)MODEL_TYPE_MAPPING.set(d,i),MODEL_CLASS_TO_NAME_MAPPING.set(t,d),MODEL_NAME_TO_CLASS_MAPPING.set(d,t);class Seq2SeqLMOutput extends ModelOutput{constructor({logits:t,past_key_values:i,encoder_outputs:r,decoder_attentions:o=null,cross_attentions:l=null}){super(),this.logits=t,this.past_key_values=i,this.encoder_outputs=r,this.decoder_attentions=o,this.cross_attentions=l}}class SequenceClassifierOutput extends ModelOutput{constructor({logits:t}){super(),this.logits=t}}class TokenClassifierOutput extends ModelOutput{constructor({logits:t}){super(),this.logits=t}}class MaskedLMOutput extends ModelOutput{constructor({logits:t}){super(),this.logits=t}}class QuestionAnsweringModelOutput extends ModelOutput{constructor({start_logits:t,end_logits:i}){super(),this.start_logits=t,this.end_logits=i}}class CausalLMOutput extends ModelOutput{constructor({logits:t}){super(),this.logits=t}}class ImageMattingOutput extends ModelOutput{constructor({alphas:t}){super(),this.alphas=t}}class VitsModelOutput extends ModelOutput{constructor({waveform:t,spectrogram:i}){super(),this.waveform=t,this.spectrogram=i}}const BROWSER_ENV=typeof self<"u",WEBWORKER_ENV=BROWSER_ENV&&self.constructor.name==="DedicatedWorkerGlobalScope";let createCanvasFunction,ImageDataClass,loadImageFunction;if(BROWSER_ENV)createCanvasFunction=(d,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(d,t)},loadImageFunction=self.createImageBitmap,ImageDataClass=self.ImageData;else if(sharp)loadImageFunction=async d=>{const i=(await d.metadata()).channels;let{data:r,info:o}=await d.raw().toBuffer({resolveWithObject:!0});const l=new RawImage(new Uint8ClampedArray(r),o.width,o.height,o.channels);return i!==void 0&&i!==o.channels&&l.convert(i),l};else throw new Error("Unable to load image processing library.");const RESAMPLING_MAPPING={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},CONTENT_TYPE_MAP=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class RawImage{constructor(t,i,r,o){this.data=t,this.width=i,this.height=r,this.channels=o}get size(){return[this.width,this.height]}static async read(t){if(t instanceof RawImage)return t;if(isString(t)||t instanceof URL)return await this.fromURL(t);throw new Error(`Unsupported input type: ${typeof t}`)}static async fromURL(t){let i=await getFile(t);if(i.status!==200)throw new Error(`Unable to read image from "${t}" (${i.status} ${i.statusText})`);let r=await i.blob();return this.fromBlob(r)}static async fromBlob(t){if(BROWSER_ENV){let i=await loadImageFunction(t);const r=createCanvasFunction(i.width,i.height).getContext("2d");return r.drawImage(i,0,0),new this(r.getImageData(0,0,i.width,i.height).data,i.width,i.height,4)}else{let i=sharp(await t.arrayBuffer());return await loadImageFunction(i)}}static fromTensor(t,i="CHW"){if(i==="CHW")t=t.transpose(1,2,0);else if(i!=="HWC")throw new Error(`Unsupported channel format: ${i}`);if(!(t.data instanceof Uint8ClampedArray||t.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${t.type}`);switch(t.dims[2]){case 1:case 2:case 3:case 4:return new RawImage(t.data,t.dims[1],t.dims[0],t.dims[2]);default:throw new Error(`Unsupported number of channels: ${t.dims[2]}`)}}grayscale(){if(this.channels===1)return this;let t=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let i=0,r=0;i<this.data.length;i+=this.channels){const o=this.data[i],l=this.data[i+1],a=this.data[i+2];t[r++]=Math.round(.2989*o+.587*l+.114*a)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(t,this.width,this.height,1)}rgb(){if(this.channels===3)return this;let t=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let i=0,r=0;i<this.data.length;++i)t[r++]=this.data[i],t[r++]=this.data[i],t[r++]=this.data[i];break;case 4:for(let i=0,r=0;i<this.data.length;i+=4)t[r++]=this.data[i],t[r++]=this.data[i+1],t[r++]=this.data[i+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(t,this.width,this.height,3)}rgba(){if(this.channels===4)return this;let t=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let i=0,r=0;i<this.data.length;++i)t[r++]=this.data[i],t[r++]=this.data[i],t[r++]=this.data[i],t[r++]=255;break;case 3:for(let i=0,r=0;i<this.data.length;i+=3)t[r++]=this.data[i],t[r++]=this.data[i+1],t[r++]=this.data[i+2],t[r++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(t,this.width,this.height,4)}async resize(t,i,{resample:r=2}={}){let o=RESAMPLING_MAPPING[r]??r;if(BROWSER_ENV){let l=this.channels,a=this.toCanvas();const f=createCanvasFunction(t,i).getContext("2d");return f.drawImage(a,0,0,t,i),new RawImage(f.getImageData(0,0,t,i).data,t,i,4).convert(l)}else{let l=this.toSharp();switch(o){case"box":case"hamming":(o==="box"||o==="hamming")&&(console.warn(`Resampling method ${o} is not yet supported. Using bilinear instead.`),o="bilinear");case"nearest":case"bilinear":case"bicubic":l=l.affine([t/this.width,0,0,i/this.height],{interpolator:o});break;case"lanczos":l=l.resize({width:t,height:i,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${o} is not supported.`)}return await loadImageFunction(l)}}async pad([t,i,r,o]){if(t=Math.max(t,0),i=Math.max(i,0),r=Math.max(r,0),o=Math.max(o,0),t===0&&i===0&&r===0&&o===0)return this;if(BROWSER_ENV){let l=this.channels,a=this.toCanvas(),f=this.width+t+i,p=this.height+r+o;const h=createCanvasFunction(f,p).getContext("2d");return h.drawImage(a,0,0,this.width,this.height,t,r,f,p),new RawImage(h.getImageData(0,0,f,p).data,f,p,4).convert(l)}else{let l=this.toSharp().extend({left:t,right:i,top:r,bottom:o});return await loadImageFunction(l)}}async crop([t,i,r,o]){if(t=Math.max(t,0),i=Math.max(i,0),r=Math.min(r,this.width-1),o=Math.min(o,this.height-1),t===0&&i===0&&r===this.width-1&&o===this.height-1)return this;const l=r-t+1,a=o-i+1;if(BROWSER_ENV){const f=this.channels,p=this.toCanvas(),h=createCanvasFunction(l,a).getContext("2d");return h.drawImage(p,t,i,l,a,0,0,l,a),new RawImage(h.getImageData(0,0,l,a).data,l,a,4).convert(f)}else{const f=this.toSharp().extract({left:t,top:i,width:l,height:a});return await loadImageFunction(f)}}async center_crop(t,i){if(this.width===t&&this.height===i)return this;let r=(this.width-t)/2,o=(this.height-i)/2;if(BROWSER_ENV){let l=this.channels,a=this.toCanvas();const f=createCanvasFunction(t,i).getContext("2d");let p=0,h=0,c=0,n=0;return r>=0?p=r:c=-r,o>=0?h=o:n=-o,f.drawImage(a,p,h,t,i,c,n,t,i),new RawImage(f.getImageData(0,0,t,i).data,t,i,4).convert(l)}else{let l=this.toSharp();if(r>=0&&o>=0)l=l.extract({left:Math.floor(r),top:Math.floor(o),width:t,height:i});else if(r<=0&&o<=0){let a=Math.floor(-o),f=Math.floor(-r);l=l.extend({top:a,left:f,right:t-this.width-f,bottom:i-this.height-a})}else{let a=[0,0],f=0;o<0?(a[0]=Math.floor(-o),a[1]=i-this.height-a[0]):f=Math.floor(o);let p=[0,0],h=0;r<0?(p[0]=Math.floor(-r),p[1]=t-this.width-p[0]):h=Math.floor(r),l=l.extend({top:a[0],bottom:a[1],left:p[0],right:p[1]}).extract({left:h,top:f,width:t,height:i})}return await loadImageFunction(l)}}async toBlob(t="image/png",i=1){if(!BROWSER_ENV)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:t,quality:i})}toCanvas(){if(!BROWSER_ENV)throw new Error("toCanvas() is only supported in browser environments.");let t=this.clone().rgba(),i=createCanvasFunction(t.width,t.height),r=new ImageDataClass(t.data,t.width,t.height);return i.getContext("2d").putImageData(r,0,0),i}_update(t,i,r,o=null){return this.data=t,this.width=i,this.height=r,o!==null&&(this.channels=o),this}clone(){return new RawImage(this.data.slice(),this.width,this.height,this.channels)}convert(t){if(this.channels===t)return this;switch(t){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(t){if(BROWSER_ENV){if(WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const i=t.split(".").pop().toLowerCase(),r=CONTENT_TYPE_MAP.get(i)??"image/png",o=await this.toBlob(r),l=URL.createObjectURL(o),a=document.createElement("a");a.href=l,a.download=t,a.click(),a.remove()}else{if(env$1.useFS)return await this.toSharp().toFile(t);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(BROWSER_ENV)throw new Error("toSharp() is only supported in server-side environments.");return sharp(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}function hanning(d){if(d<1)return new Float64Array;if(d===1)return new Float64Array([1]);const t=d-1,i=Math.PI/t,r=new Float64Array(d);for(let o=0;o<d;++o){const l=2*o-t;r[o]=.5+.5*Math.cos(i*l)}return r}const HERTZ_TO_MEL_MAPPING={htk:d=>2595*Math.log10(1+d/700),kaldi:d=>1127*Math.log(1+d/700),slaney:(d,t=1e3,i=15,r=27/Math.log(6.4))=>d>=t?i+Math.log(d/t)*r:3*d/200};function hertz_to_mel(d,t="htk"){const i=HERTZ_TO_MEL_MAPPING[t];if(!i)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof d=="number"?i(d):d.map(r=>i(r))}const MEL_TO_HERTZ_MAPPING={htk:d=>700*(10**(d/2595)-1),kaldi:d=>700*(Math.exp(d/1127)-1),slaney:(d,t=1e3,i=15,r=Math.log(6.4)/27)=>d>=i?t*Math.exp(r*(d-i)):200*d/3};function mel_to_hertz(d,t="htk"){const i=MEL_TO_HERTZ_MAPPING[t];if(!i)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof d=="number"?i(d):d.map(r=>i(r))}function _create_triangular_filter_bank(d,t){const i=Float64Array.from({length:t.length-1},(a,f)=>t[f+1]-t[f]),r=Array.from({length:d.length},()=>new Array(t.length));for(let a=0;a<d.length;++a){const f=r[a];for(let p=0;p<t.length;++p)f[p]=t[p]-d[a]}const o=t.length-2,l=Array.from({length:o},()=>new Array(d.length));for(let a=0;a<d.length;++a){const f=r[a];for(let p=0;p<o;++p){const h=-f[p]/i[p],c=f[p+2]/i[p+1];l[p][a]=Math.max(0,Math.min(h,c))}}return l}function linspace(d,t,i){const r=(t-d)/(i-1);return Float64Array.from({length:i},(o,l)=>d+r*l)}function mel_filter_bank(d,t,i,r,o,l=null,a="htk",f=!1){if(l!==null&&l!=="slaney")throw new Error('norm must be one of null or "slaney"');const p=hertz_to_mel(i,a),h=hertz_to_mel(r,a),c=linspace(p,h,t+2);let n=mel_to_hertz(c,a),e;if(f){const u=o/(d*2);e=hertz_to_mel(Float64Array.from({length:d},(m,b)=>b*u),a),n=c}else e=linspace(0,Math.floor(o/2),d);const s=_create_triangular_filter_bank(e,n);if(l!==null&&l==="slaney")for(let u=0;u<t;++u){const m=s[u],b=2/(n[u+2]-n[u]);for(let g=0;g<d;++g)m[g]*=b}return s}function padReflect(d,t,i){const r=new d.constructor(d.length+t+i),o=d.length-1;for(let l=0;l<d.length;++l)r[t+l]=d[l];for(let l=1;l<=t;++l)r[t-l]=d[calculateReflectOffset(l,o)];for(let l=1;l<=i;++l)r[o+t+l]=d[calculateReflectOffset(o-l,o)];return r}function _db_conversion_helper(d,t,i,r,o){if(i<=0)throw new Error("reference must be greater than zero");if(r<=0)throw new Error("min_value must be greater than zero");i=Math.max(r,i);const l=Math.log10(i);for(let a=0;a<d.length;++a)d[a]=t*Math.log10(Math.max(r,d[a])-l);if(o!==null){if(o<=0)throw new Error("db_range must be greater than zero");const a=max$2(d)[0]-o;for(let f=0;f<d.length;++f)d[f]=Math.max(d[f],a)}return d}function amplitude_to_db(d,t=1,i=1e-5,r=null){return _db_conversion_helper(d,20,t,i,r)}function power_to_db(d,t=1,i=1e-10,r=null){return _db_conversion_helper(d,10,t,i,r)}function spectrogram(d,t,i,r,{fft_length:o=null,power:l=1,center:a=!0,pad_mode:f="reflect",onesided:p=!0,preemphasis:h=null,mel_filters:c=null,mel_floor:n=1e-10,log_mel:e=null,reference:s=1,min_value:u=1e-10,db_range:m=null,remove_dc_offset:b=null,max_num_frames:g=null,do_pad:_=!0,transpose:y=!1}={}){const v=t.length;if(o===null&&(o=i),i>o)throw Error(`frame_length (${i}) may not be larger than fft_length (${o})`);if(v!==i)throw new Error(`Length of the window (${v}) must equal frame_length (${i})`);if(r<=0)throw new Error("hop_length must be greater than zero");if(a){if(f!=="reflect")throw new Error(`pad_mode="${f}" not implemented yet.`);const k=Math.floor((o-1)/2)+1;d=padReflect(d,k,k)}const w=Math.floor(1+Math.floor((d.length-i)/r)),M=p?Math.floor(o/2)+1:o;let S=w,O=w;g!==null&&(g>w?_&&(O=g):O=S=g);const x=new FFT(o),T=new Float64Array(o),I=new Float64Array(x.outputBufferSize),F=new Array(S);for(let k=0;k<S;++k){const R=k*r;for(let U=0;U<i;++U)T[U]=d[R+U];if(b){let U=0;for(let Q=0;Q<i;++Q)U+=T[Q];const K=U/i;for(let Q=0;Q<i;++Q)T[Q]-=K}if(h!==null){for(let U=i-1;U>=1;--U)T[U]-=h*T[U-1];T[0]*=1-h}for(let U=0;U<t.length;++U)T[U]*=t[U];x.realTransform(I,T);const X=new Array(M);for(let U=0;U<X.length;++U){const K=U<<1;X[U]=I[K]**2+I[K+1]**2}F[k]=X}if(l!==null&&l!==2){const k=2/l;for(let R=0;R<F.length;++R){const X=F[R];for(let U=0;U<X.length;++U)X[U]**=k}}const C=c.length,N=new Float32Array(C*O),B=y?[O,C]:[C,O];for(let k=0;k<C;++k){const R=c[k];for(let X=0;X<S;++X){const U=F[X];let K=0;for(let Q=0;Q<M;++Q)K+=R[Q]*U[Q];N[y?X*C+k:k*S+X]=Math.max(n,K)}}if(l!==null&&e!==null){const k=Math.min(N.length,S*C);switch(e){case"log":for(let R=0;R<k;++R)N[R]=Math.log(N[R]);break;case"log10":for(let R=0;R<k;++R)N[R]=Math.log10(N[R]);break;case"dB":if(l===1)amplitude_to_db(N,s,u,m);else if(l===2)power_to_db(N,s,u,m);else throw new Error(`Cannot use log_mel option '${e}' with power ${l}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${e}'`)}}return{data:N,dims:B}}function window_function(d,t,{periodic:i=!0,frame_length:r=null,center:o=!0}={}){const l=i?d+1:d;let a;switch(t){case"boxcar":a=new Float64Array(l).fill(1);break;case"hann":case"hann_window":a=hanning(l);break;default:throw new Error(`Unknown window type ${t}.`)}if(i&&(a=a.subarray(0,d)),r===null)return a;if(d>r)throw new Error(`Length of the window (${d}) may not be larger than frame_length (${r})`);return a}function center_to_corners_format([d,t,i,r]){return[d-i/2,t-r/2,d+i/2,t+r/2]}function post_process_object_detection(d,t=.5,i=null,r=!1){const o=d.logits,l=d.pred_boxes,[a,f,p]=o.dims;if(i!==null&&i.length!==a)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let h=[];for(let c=0;c<a;++c){let n=i!==null?i[c]:null,e={boxes:[],classes:[],scores:[]},s=o[c],u=l[c];for(let m=0;m<f;++m){let b=s[m],g=[],_;if(r){_=b.sigmoid().data;for(let y=0;y<_.length;++y)_[y]>t&&g.push(y)}else{let y=max$2(b.data)[1];if(y===p-1)continue;g.push(y),_=softmax(b.data)}for(const y of g){let v=u[m].data;v=center_to_corners_format(v),n!==null&&(v=v.map((w,M)=>w*n[(M+1)%2])),e.boxes.push(v),e.classes.push(y),e.scores.push(_[y])}}h.push(e)}return h}function validate_audio_inputs(d,t){var i;if(!(d instanceof Float32Array||d instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${((i=d==null?void 0:d.constructor)==null?void 0:i.name)??typeof d} instead.If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}class FeatureExtractor extends Callable{constructor(t){super(),this.config=t}}class ImageFeatureExtractor extends FeatureExtractor{constructor(t){super(t),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size)}async thumbnail(t,i,r=2){const o=t.height,l=t.width,a=i.height,f=i.width;let p=Math.min(o,a),h=Math.min(l,f);return p===o&&h===l?t:(o>l?h=Math.floor(l*p/o):l>o&&(p=Math.floor(o*h/l)),await t.resize(h,p,{resample:r}))}async crop_margin(t,i=200){const r=t.clone().grayscale(),o=min$1(r.data)[0],a=max$2(r.data)[0]-o;if(a===0)return t;const f=i/255;let p=r.width,h=r.height,c=0,n=0;for(let e=0;e<r.height;++e){const s=e*r.width;for(let u=0;u<r.width;++u)(r.data[s+u]-o)/a<f&&(p=Math.min(p,u),h=Math.min(h,e),c=Math.max(c,u),n=Math.max(n,e))}return t=await t.crop([p,h,c,n]),t}pad_image(t,i,r,{mode:o="constant",center:l=!1,constant_values:a=0}={}){const[f,p,h]=i;let c,n;if(typeof r=="number"?(c=r,n=r):(c=r.width,n=r.height),c!==f||n!==p){const e=new Float32Array(c*n*h);if(Array.isArray(a))for(let m=0;m<e.length;++m)e[m]=a[m%h];else a!==0&&e.fill(a);const[s,u]=l?[Math.floor((c-f)/2),Math.floor((n-p)/2)]:[0,0];for(let m=0;m<p;++m){const b=(m+u)*c,g=m*f;for(let _=0;_<f;++_){const y=(b+_+s)*h,v=(g+_)*h;for(let w=0;w<h;++w)e[y+w]=t[v+w]}}if(o==="symmetric"){if(l)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const m=p-1,b=f-1;for(let g=0;g<n;++g){const _=g*c,y=calculateReflectOffset(g,m)*f;for(let v=0;v<c;++v){if(g<p&&v<f)continue;const w=(_+v)*h,M=(y+calculateReflectOffset(v,b))*h;for(let S=0;S<h;++S)e[w+S]=t[M+S]}}}t=e,i=[n,c,h]}return[t,i]}rescale(t){for(let i=0;i<t.length;++i)t[i]=this.rescale_factor*t[i]}async preprocess(t,{do_normalize:i=null,do_pad:r=null,do_convert_rgb:o=null,do_convert_grayscale:l=null}={}){this.do_crop_margin&&(t=await this.crop_margin(t));const a=t.width,f=t.height;if(o??this.do_convert_rgb?t=t.rgb():l&&(t=t.grayscale()),this.do_resize){let s,u;if(this.do_thumbnail){const{height:m,width:b}=this.size;s=Math.min(m,b)}else Number.isInteger(this.size)?(s=this.size,u=this.config.max_size??s):this.size!==void 0&&(s=this.size.shortest_edge,u=this.size.longest_edge);if(s!==void 0||u!==void 0){const m=s===void 0?1:Math.max(s/a,s/f),b=a*m,g=f*m,_=u===void 0?1:Math.min(u/b,u/g),y=Math.floor(Number((b*_).toFixed(2))),v=Math.floor(Number((g*_).toFixed(2)));t=await t.resize(y,v,{resample:this.resample})}else if(this.size!==void 0&&this.size.width!==void 0&&this.size.height!==void 0)t=await t.resize(this.size.width,this.size.height,{resample:this.resample});else if(this.size_divisibility!==void 0){const m=Math.floor(a/this.size_divisibility)*this.size_divisibility,b=Math.floor(f/this.size_divisibility)*this.size_divisibility;t=await t.resize(m,b,{resample:this.resample})}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(this.size)}`)}if(this.do_thumbnail&&(t=await this.thumbnail(t,this.size,this.resample)),this.do_center_crop){let s,u;Number.isInteger(this.crop_size)?(s=this.crop_size,u=this.crop_size):(s=this.crop_size.width,u=this.crop_size.height),t=await t.center_crop(s,u)}let p=[t.height,t.width],h=Float32Array.from(t.data),c=[t.height,t.width,t.channels];if(this.do_rescale&&this.rescale(h),i??this.do_normalize){let s=this.image_mean;Array.isArray(this.image_mean)||(s=new Array(t.channels).fill(s));let u=this.image_std;if(Array.isArray(this.image_std)||(u=new Array(t.channels).fill(s)),s.length!==t.channels||u.length!==t.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${s.length}) and \`image_std\` (${u.length}) must match the number of channels in the image (${t.channels}).`);for(let m=0;m<h.length;m+=t.channels)for(let b=0;b<t.channels;++b)h[m+b]=(h[m+b]-this.image_mean[b])/this.image_std[b]}(r??(this.do_pad&&this.pad_size))&&([h,c]=this.pad_image(h,[t.width,t.height,t.channels],this.pad_size));const n=new Tensor("float32",h,c),e=transpose$1(n,[2,0,1]);return{original_size:[f,a],reshaped_input_size:p,pixel_values:e}}async _call(t,...i){Array.isArray(t)||(t=[t]);const r=await Promise.all(t.map(l=>this.preprocess(l)));return{pixel_values:stack(r.map(l=>l.pixel_values),0),original_sizes:r.map(l=>l.original_size),reshaped_input_sizes:r.map(l=>l.reshaped_input_size)}}}class SegformerFeatureExtractor extends ImageFeatureExtractor{post_process_semantic_segmentation(t,i=null){const r=t.logits,o=r.dims[0];if(i!==null&&i.length!==o)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const l=[];for(let a=0;a<o;++a){const f=i!==null?i[a]:null;let p=r[a];f!==null&&(p=interpolate(p,f,"bilinear",!1));const[h,c]=f??p.dims.slice(-2),n=new Tensor("int32",new Int32Array(h*c),[h,c]),e=p[0].data;for(let b=1;b<p.dims[0];++b){const g=p[b].data;for(let _=0;_<g.length;++_)g[_]>e[_]&&(e[_]=g[_],n.data[_]=b)}const s=new Array(p.dims[0]),u=n.data;for(let b=0;b<u.length;++b){const g=u[b];s[g]=g}const m=s.filter(b=>b!==void 0);l.push({segmentation:n,labels:m})}return l}}class BitImageProcessor extends ImageFeatureExtractor{}class DPTFeatureExtractor extends ImageFeatureExtractor{}class GLPNFeatureExtractor extends ImageFeatureExtractor{}class CLIPFeatureExtractor extends ImageFeatureExtractor{}class ChineseCLIPFeatureExtractor extends ImageFeatureExtractor{}class SiglipImageProcessor extends ImageFeatureExtractor{}class ConvNextFeatureExtractor extends ImageFeatureExtractor{}class ConvNextImageProcessor extends ConvNextFeatureExtractor{}class ViTFeatureExtractor extends ImageFeatureExtractor{}class ViTImageProcessor extends ImageFeatureExtractor{}class MobileViTFeatureExtractor extends ImageFeatureExtractor{}class OwlViTFeatureExtractor extends ImageFeatureExtractor{post_process_object_detection(...t){return post_process_object_detection(...t)}}class DeiTFeatureExtractor extends ImageFeatureExtractor{}class BeitFeatureExtractor extends ImageFeatureExtractor{}class DonutFeatureExtractor extends ImageFeatureExtractor{pad_image(t,i,r,o={}){const[l,a,f]=i;let p=this.image_mean;Array.isArray(this.image_mean)||(p=new Array(f).fill(p));let h=this.image_std;Array.isArray(h)||(h=new Array(f).fill(p));const c=p.map((n,e)=>-n/this.image_std[e]);return super.pad_image(t,i,r,{center:!0,constant_values:c,...o})}}class NougatImageProcessor extends DonutFeatureExtractor{}class DetrFeatureExtractor extends ImageFeatureExtractor{async _call(t){const i=await super._call(t),r=[i.pixel_values.dims[0],64,64],o=new Tensor("int64",new BigInt64Array(r.reduce((l,a)=>l*a)).fill(1n),r);return{...i,pixel_mask:o}}post_process_object_detection(...t){return post_process_object_detection(...t)}remove_low_and_no_objects(t,i,r,o){let l=[],a=[],f=[];for(let p=0;p<t.dims[0];++p){let h=t[p],c=i[p],n=max$2(h.data)[1];if(n===o)continue;let s=softmax(h.data)[n];s>r&&(l.push(c),a.push(s),f.push(n))}return[l,a,f]}check_segment_validity(t,i,r,o=.5,l=.8){let a=[],f=0,p=0;for(let c=0;c<t.length;++c)t[c]===r&&(a.push(c),++f),i[r].data[c]>=o&&++p;let h=f>0&&p>0;return h&&(h=f/p>l),[h,a]}compute_segments(t,i,r,o,l,a=null,f=null){let[p,h]=f??t[0].dims,c=new Tensor("int32",new Int32Array(p*h),[p,h]),n=[];if(f!==null)for(let m=0;m<t.length;++m)t[m]=interpolate(t[m],f,"bilinear",!1);let e=new Int32Array(t[0].data.length),s=new Float32Array(t[0].data.length);for(let m=0;m<t.length;++m){let b=i[m];for(let g=0;g<t[m].data.length;++g)t[m].data[g]*=b,t[m].data[g]>s[g]&&(e[g]=m,s[g]=t[m].data[g])}let u=0;for(let m=0;m<r.length;++m){let b=r[m],[g,_]=this.check_segment_validity(e,t,m,o,l);if(g){++u;for(let y of _)c.data[y]=u;n.push({id:u,label_id:b,score:i[m]})}}return[c,n]}post_process_panoptic_segmentation(t,i=.5,r=.5,o=.8,l=null,a=null){l===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),l=new Set);const f=t.logits,h=t.pred_masks.sigmoid();let[c,n,e]=f.dims;if(e-=1,a!==null&&a.length!==c)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let s=[];for(let u=0;u<c;++u){let m=a!==null?a[u]:null,b=f[u],g=h[u],[_,y,v]=this.remove_low_and_no_objects(b,g,i,e);if(v.length===0){let[S,O]=m??g.dims.slice(-2),x=new Tensor("int32",new Int32Array(S*O).fill(-1),[S,O]);s.push({segmentation:x,segments_info:[]});continue}let[w,M]=this.compute_segments(_,y,v,r,o,l,m);s.push({segmentation:w,segments_info:M})}return s}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class YolosFeatureExtractor extends ImageFeatureExtractor{post_process_object_detection(...t){return post_process_object_detection(...t)}}class SamImageProcessor extends ImageFeatureExtractor{async _call(t,i){let{pixel_values:r,original_sizes:o,reshaped_input_sizes:l}=await super._call(t),a=calculateDimensions(i);if(a.length===3)a=[1,...a],i=[i];else if(a.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let p=0;p<i.length;++p){let h=o[p],c=l[p],n=[c[0]/h[0],c[1]/h[1]];for(let e=0;e<i[p].length;++e)for(let s=0;s<i[p][e].length;++s)for(let u=0;u<i[p][e][s].length;++u)i[p][e][s][u]*=n[u]}let f=new Tensor("int64",BigInt64Array.from(i.flat(1/0).map(p=>BigInt(Math.round(p)))),a);return{pixel_values:r,original_sizes:o,reshaped_input_sizes:l,input_points:f}}post_process_masks(t,i,r,{mask_threshold:o=0,binarize:l=!0,pad_size:a=null}={}){let f=[];a=a??this.pad_size;let p=[a.height,a.width];for(let h=0;h<i.length;++h){let c=i[h],n=r[h],e=t[h],s=[];for(let m=0;m<e.dims[0];++m){let b=e[m],g=interpolate(b,p,"bilinear",!1);g=g.slice(null,[0,n[0]],[0,n[1]]),g=interpolate(e,c,"bilinear",!1),l&&(g=new Tensor("bool",Array.from(g.data).map(_=>_>o),g.dims)),g.dims=[1,...g.dims],s.push(g)}let u=cat(s);f.push(u)}return f}}class Swin2SRImageProcessor extends ImageFeatureExtractor{pad_image(t,i,r,o={}){const[l,a,f]=i;return super.pad_image(t,i,{width:l+(r-l%r)%r,height:a+(r-a%r)%r},{mode:"symmetric",center:!1,constant_values:-1,...o})}}class VitMatteImageProcessor extends ImageFeatureExtractor{async _call(t,i){Array.isArray(t)||(t=[t]),Array.isArray(i)||(i=[i]);const r=await Promise.all(t.map(a=>this.preprocess(a))),o=await Promise.all(i.map(a=>this.preprocess(a,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:stack(r.map((a,f)=>cat([a.pixel_values,o[f].pixel_values],0)),0),original_sizes:r.map(a=>a.original_size),reshaped_input_sizes:r.map(a=>a.reshaped_input_size)}}}class WhisperFeatureExtractor extends FeatureExtractor{constructor(t){var i;super(t),(i=this.config).mel_filters??(i.mel_filters=mel_filter_bank(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=window_function(this.config.n_fft,"hann")}_extract_fbank_features(t){const{data:i,dims:r}=spectrogram(t,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),o=max$2(i)[0];for(let l=0;l<i.length;++l)i[l]=(Math.max(i[l],o-8)+4)/4;return{data:i,dims:r}}async _call(t){validate_audio_inputs(t,"WhisperFeatureExtractor");let i;t.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),i=t.slice(0,this.config.n_samples)):(i=new Float32Array(this.config.n_samples),i.set(t));const{data:r,dims:o}=this._extract_fbank_features(i);return{input_features:new Tensor("float32",r,[1,...o])}}}class Wav2Vec2FeatureExtractor extends FeatureExtractor{_zero_mean_unit_var_norm(t){const r=t.reduce((l,a)=>l+a,0)/t.length,o=t.reduce((l,a)=>l+(a-r)**2,0)/t.length;return t.map(l=>(l-r)/Math.sqrt(o+1e-7))}async _call(t){validate_audio_inputs(t,"Wav2Vec2FeatureExtractor"),t instanceof Float64Array&&(t=new Float32Array(t));let i=t;this.config.do_normalize&&(i=this._zero_mean_unit_var_norm(i));const r=[1,i.length];return{input_values:new Tensor("float32",i,r),attention_mask:new Tensor("int64",new BigInt64Array(i.length).fill(1n),r)}}}class ASTFeatureExtractor extends FeatureExtractor{constructor(t){super(t);const i=this.config.sampling_rate,r=mel_filter_bank(256,this.config.num_mel_bins,20,Math.floor(i/2),i,null,"kaldi",!0);for(let o=0;o<r.length;++o)r[o].push(0);this.mel_filters=r,this.window=window_function(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}_extract_fbank_features(t,i){return spectrogram(t,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:i,transpose:!0})}async _call(t){validate_audio_inputs(t,"ASTFeatureExtractor");const i=this._extract_fbank_features(t,this.config.max_length);if(this.config.do_normalize){const r=this.std*2;for(let o=0;o<i.data.length;++o)i.data[o]=(i.data[o]-this.mean)/r}return{input_values:new Tensor("float32",i.data,[1,...i.dims])}}}class ClapFeatureExtractor extends FeatureExtractor{constructor(t){super(t),this.mel_filters=mel_filter_bank(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=mel_filter_bank(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=window_function(this.config.fft_window_size,"hann")}_get_input_mel(t,i,r,o){let l,a=!1;const f=t.length-i;if(f>0)if(r==="rand_trunc"){a=!0;const p=Math.floor(Math.random()*(f+1));t=t.subarray(p,p+i),l=this._extract_fbank_features(t,this.mel_filters_slaney,this.config.nb_max_samples),l.dims=[1,...l.dims]}else throw new Error(`Truncation strategy "${r}" not implemented`);else{if(f<0){let p=new Float64Array(i);if(p.set(t),o==="repeat")for(let h=t.length;h<i;h+=t.length)p.set(t.subarray(0,Math.min(t.length,i-h)),h);else if(o==="repeatpad")for(let h=t.length;h<-f;h+=t.length)p.set(t,h);t=p}if(r==="fusion")throw new Error(`Truncation strategy "${r}" not implemented`);l=this._extract_fbank_features(t,this.mel_filters_slaney,this.config.nb_max_samples),l.dims=[1,...l.dims]}return{...l,longer:a}}_extract_fbank_features(t,i,r=null){return spectrogram(t,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:i,log_mel:"dB",max_num_frames:r,do_pad:!1,transpose:!0})}async _call(t,{max_length:i=null}={}){validate_audio_inputs(t,"ClapFeatureExtractor");const r=this._get_input_mel(t,i??this.config.nb_max_samples,this.config.truncation,this.config.padding);return{input_features:new Tensor("float32",r.data,[1,...r.dims])}}}class SpeechT5FeatureExtractor extends FeatureExtractor{}class Processor extends Callable{constructor(t){super(),this.feature_extractor=t}async _call(t,...i){return await this.feature_extractor(t,...i)}}class SamProcessor extends Processor{async _call(t,i){return await this.feature_extractor(t,i)}post_process_masks(...t){return this.feature_extractor.post_process_masks(...t)}}class WhisperProcessor extends Processor{async _call(t){return await this.feature_extractor(t)}}class Wav2Vec2ProcessorWithLM extends Processor{async _call(t){return await this.feature_extractor(t)}}class SpeechT5Processor extends Processor{async _call(t){return await this.feature_extractor(t)}}class OwlViTProcessor extends Processor{}class AutoProcessor{static async from_pretrained(t,{progress_callback:i=null,config:r=null,cache_dir:o=null,local_files_only:l=!1,revision:a="main"}={}){let f=r??await getModelJSON(t,"preprocessor_config.json",!0,{progress_callback:i,config:r,cache_dir:o,local_files_only:l,revision:a}),p=f.feature_extractor_type??f.image_processor_type,h=this.FEATURE_EXTRACTOR_CLASS_MAPPING[p];if(!h)if(f.size!==void 0)console.warn(`Feature extractor type "${p}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),h=ImageFeatureExtractor;else throw new Error(`Unknown Feature Extractor type: ${p}`);let c=this.PROCESSOR_CLASS_MAPPING[f.processor_class]??Processor,n=new h(f);return new c(n)}}Be(AutoProcessor,"FEATURE_EXTRACTOR_CLASS_MAPPING",{WhisperFeatureExtractor,ViTFeatureExtractor,MobileViTFeatureExtractor,OwlViTFeatureExtractor,CLIPFeatureExtractor,ChineseCLIPFeatureExtractor,SiglipImageProcessor,ConvNextFeatureExtractor,ConvNextImageProcessor,SegformerFeatureExtractor,BitImageProcessor,DPTFeatureExtractor,GLPNFeatureExtractor,BeitFeatureExtractor,DeiTFeatureExtractor,DetrFeatureExtractor,YolosFeatureExtractor,DonutFeatureExtractor,NougatImageProcessor,ViTImageProcessor,VitMatteImageProcessor,SamImageProcessor,Swin2SRImageProcessor,Wav2Vec2FeatureExtractor,SpeechT5FeatureExtractor,ASTFeatureExtractor,ClapFeatureExtractor}),Be(AutoProcessor,"PROCESSOR_CLASS_MAPPING",{WhisperProcessor,Wav2Vec2ProcessorWithLM,SamProcessor,SpeechT5Processor,OwlViTProcessor});var dist={},umap={},heap$2={},utils$5={},__values$3=commonjsGlobal&&commonjsGlobal.__values||function(d){var t=typeof Symbol=="function"&&d[Symbol.iterator],i=0;return t?t.call(d):{next:function(){return d&&i>=d.length&&(d=void 0),{value:d&&d[i++],done:!d}}}};Object.defineProperty(utils$5,"__esModule",{value:!0});function tauRandInt(d,t){return Math.floor(t()*d)}utils$5.tauRandInt=tauRandInt;function tauRand(d){return d()}utils$5.tauRand=tauRand;function norm(d){var t,i,r=0;try{for(var o=__values$3(d),l=o.next();!l.done;l=o.next()){var a=l.value;r+=Math.pow(a,2)}}catch(f){t={error:f}}finally{try{l&&!l.done&&(i=o.return)&&i.call(o)}finally{if(t)throw t.error}}return Math.sqrt(r)}utils$5.norm=norm;function empty(d){for(var t=[],i=0;i<d;i++)t.push(void 0);return t}utils$5.empty=empty;function range(d){return empty(d).map(function(t,i){return i})}utils$5.range=range;function filled(d,t){return empty(d).map(function(){return t})}utils$5.filled=filled;function zeros(d){return filled(d,0)}utils$5.zeros=zeros;function ones(d){return filled(d,1)}utils$5.ones=ones;function linear(d,t,i){return empty(i).map(function(r,o){return d+o*((t-d)/(i-1))})}utils$5.linear=linear;function sum(d){return d.reduce(function(t,i){return t+i})}utils$5.sum=sum;function mean(d){return sum(d)/d.length}utils$5.mean=mean;function max$1(d){for(var t=0,i=0;i<d.length;i++)t=d[i]>t?d[i]:t;return t}utils$5.max=max$1;function max2d(d){for(var t=0,i=0;i<d.length;i++)for(var r=0;r<d[i].length;r++)t=d[i][r]>t?d[i][r]:t;return t}utils$5.max2d=max2d;function rejectionSample$1(d,t,i){for(var r=zeros(d),o=0;o<d;o++)for(var l=!0;l;){for(var a=tauRandInt(t,i),f=!1,p=0;p<o;p++)if(a===r[p]){f=!0;break}f||(l=!1),r[o]=a}return r}utils$5.rejectionSample=rejectionSample$1;function reshape2d(d,t,i){var r=[],o=0;if(d.length!==t*i)throw new Error("Array dimensions must match input length.");for(var l=0;l<t;l++){for(var a=[],f=0;f<i;f++)a.push(d[o]),o+=1;r.push(a)}return r}utils$5.reshape2d=reshape2d;var __importStar$4=commonjsGlobal&&commonjsGlobal.__importStar||function(d){if(d&&d.__esModule)return d;var t={};if(d!=null)for(var i in d)Object.hasOwnProperty.call(d,i)&&(t[i]=d[i]);return t.default=d,t};Object.defineProperty(heap$2,"__esModule",{value:!0});var utils$4=__importStar$4(utils$5);function makeHeap(d,t){var i=function(o){return utils$4.empty(d).map(function(){return utils$4.filled(t,o)})},r=[];return r.push(i(-1)),r.push(i(1/0)),r.push(i(0)),r}heap$2.makeHeap=makeHeap;function rejectionSample(d,t,i){for(var r=utils$4.zeros(d),o=0;o<d;o++){for(var l=!0,a=0;l;){a=utils$4.tauRandInt(t,i);for(var f=!1,p=0;p<o;p++)if(a===r[p]){f=!0;break}f||(l=!1)}r[o]=a}return r}heap$2.rejectionSample=rejectionSample;function heapPush(d,t,i,r,o){t=Math.floor(t);var l=d[0][t],a=d[1][t];if(d[2][t],i>=a[0])return 0;for(var f=0;f<l.length;f++)if(r===l[f])return 0;return uncheckedHeapPush(d,t,i,r,o)}heap$2.heapPush=heapPush;function uncheckedHeapPush(d,t,i,r,o){var l=d[0][t],a=d[1][t],f=d[2][t];if(i>=a[0])return 0;a[0]=i,l[0]=r,f[0]=o;for(var p=0,h=0;;){var c=2*p+1,n=c+1,e=d[0][0].length;if(c>=e)break;if(n>=e)if(a[c]>i)h=c;else break;else if(a[c]>=a[n])if(i<a[c])h=c;else break;else if(i<a[n])h=n;else break;a[p]=a[h],l[p]=l[h],f[p]=f[h],p=h}return a[p]=i,l[p]=r,f[p]=o,1}heap$2.uncheckedHeapPush=uncheckedHeapPush;function buildCandidates(d,t,i,r,o){for(var l=makeHeap(t,r),a=0;a<t;a++)for(var f=0;f<i;f++)if(!(d[0][a][f]<0)){var p=d[0][a][f],h=d[2][a][f],c=utils$4.tauRand(o);heapPush(l,a,c,p,h),heapPush(l,p,c,a,h),d[2][a][f]=0}return l}heap$2.buildCandidates=buildCandidates;function deheapSort(d){for(var t=d[0],i=d[1],r=0;r<t.length;r++)for(var o=t[r],l=i[r],a=0;a<o.length-1;a++){var f=o.length-a-1,p=l.length-a-1,h=o[0];o[0]=o[f],o[f]=h;var c=l[0];l[0]=l[p],l[p]=c,siftDown(l,o,p,0)}return{indices:t,weights:i}}heap$2.deheapSort=deheapSort;function siftDown(d,t,i,r){for(;r*2+1<i;){var o=r*2+1,l=o+1,a=r;if(d[a]<d[o]&&(a=o),l<i&&d[a]<d[l]&&(a=l),a===r)break;var f=d[r];d[r]=d[a],d[a]=f;var p=t[r];t[r]=t[a],t[a]=p,r=a}}function smallestFlagged(d,t){for(var i=d[0][t],r=d[1][t],o=d[2][t],l=1/0,a=-1,f=0;f>i.length;f++)o[f]===1&&r[f]<l&&(l=r[f],a=f);return a>=0?(o[a]=0,Math.floor(i[a])):-1}heap$2.smallestFlagged=smallestFlagged;var matrix$3={},__read$2=commonjsGlobal&&commonjsGlobal.__read||function(d,t){var i=typeof Symbol=="function"&&d[Symbol.iterator];if(!i)return d;var r=i.call(d),o,l=[],a;try{for(;(t===void 0||t-- >0)&&!(o=r.next()).done;)l.push(o.value)}catch(f){a={error:f}}finally{try{o&&!o.done&&(i=r.return)&&i.call(r)}finally{if(a)throw a.error}}return l},__values$2=commonjsGlobal&&commonjsGlobal.__values||function(d){var t=typeof Symbol=="function"&&d[Symbol.iterator],i=0;return t?t.call(d):{next:function(){return d&&i>=d.length&&(d=void 0),{value:d&&d[i++],done:!d}}}},__importStar$3=commonjsGlobal&&commonjsGlobal.__importStar||function(d){if(d&&d.__esModule)return d;var t={};if(d!=null)for(var i in d)Object.hasOwnProperty.call(d,i)&&(t[i]=d[i]);return t.default=d,t};Object.defineProperty(matrix$3,"__esModule",{value:!0});var _a,utils$3=__importStar$3(utils$5),SparseMatrix=function(){function d(t,i,r,o){if(this.entries=new Map,this.nRows=0,this.nCols=0,t.length!==i.length||t.length!==r.length)throw new Error("rows, cols and values arrays must all have the same length");this.nRows=o[0],this.nCols=o[1];for(var l=0;l<r.length;l++){var a=t[l],f=i[l];this.checkDims(a,f);var p=this.makeKey(a,f);this.entries.set(p,{value:r[l],row:a,col:f})}}return d.prototype.makeKey=function(t,i){return t+":"+i},d.prototype.checkDims=function(t,i){var r=t<this.nRows&&i<this.nCols;if(!r)throw new Error("row and/or col specified outside of matrix dimensions")},d.prototype.set=function(t,i,r){this.checkDims(t,i);var o=this.makeKey(t,i);this.entries.has(o)?this.entries.get(o).value=r:this.entries.set(o,{value:r,row:t,col:i})},d.prototype.get=function(t,i,r){r===void 0&&(r=0),this.checkDims(t,i);var o=this.makeKey(t,i);return this.entries.has(o)?this.entries.get(o).value:r},d.prototype.getAll=function(t){t===void 0&&(t=!0);var i=[];return this.entries.forEach(function(r){i.push(r)}),t&&i.sort(function(r,o){return r.row===o.row?r.col-o.col:r.row-o.row}),i},d.prototype.getDims=function(){return[this.nRows,this.nCols]},d.prototype.getRows=function(){return Array.from(this.entries,function(t){var i=__read$2(t,2);i[0];var r=i[1];return r.row})},d.prototype.getCols=function(){return Array.from(this.entries,function(t){var i=__read$2(t,2);i[0];var r=i[1];return r.col})},d.prototype.getValues=function(){return Array.from(this.entries,function(t){var i=__read$2(t,2);i[0];var r=i[1];return r.value})},d.prototype.forEach=function(t){this.entries.forEach(function(i){return t(i.value,i.row,i.col)})},d.prototype.map=function(t){var i=[];this.entries.forEach(function(o){i.push(t(o.value,o.row,o.col))});var r=[this.nRows,this.nCols];return new d(this.getRows(),this.getCols(),i,r)},d.prototype.toArray=function(){var t=this,i=utils$3.empty(this.nRows),r=i.map(function(){return utils$3.zeros(t.nCols)});return this.entries.forEach(function(o){r[o.row][o.col]=o.value}),r},d}();matrix$3.SparseMatrix=SparseMatrix;function transpose(d){var t=[],i=[],r=[];d.forEach(function(l,a,f){t.push(a),i.push(f),r.push(l)});var o=[d.nCols,d.nRows];return new SparseMatrix(i,t,r,o)}matrix$3.transpose=transpose;function identity(d){for(var t=__read$2(d,1),i=t[0],r=new SparseMatrix([],[],[],d),o=0;o<i;o++)r.set(o,o,1);return r}matrix$3.identity=identity;function pairwiseMultiply(d,t){return elementWise(d,t,function(i,r){return i*r})}matrix$3.pairwiseMultiply=pairwiseMultiply;function add(d,t){return elementWise(d,t,function(i,r){return i+r})}matrix$3.add=add;function subtract(d,t){return elementWise(d,t,function(i,r){return i-r})}matrix$3.subtract=subtract;function maximum(d,t){return elementWise(d,t,function(i,r){return i>r?i:r})}matrix$3.maximum=maximum;function multiplyScalar(d,t){return d.map(function(i){return i*t})}matrix$3.multiplyScalar=multiplyScalar;function eliminateZeros(d){for(var t=new Set,i=d.getValues(),r=d.getRows(),o=d.getCols(),l=0;l<i.length;l++)i[l]===0&&t.add(l);var a=function(c,n){return!t.has(n)},f=i.filter(a),p=r.filter(a),h=o.filter(a);return new SparseMatrix(p,h,f,d.getDims())}matrix$3.eliminateZeros=eliminateZeros;function normalize(d,t){t===void 0&&(t="l2");var i,r,o=normFns[t],l=new Map;d.forEach(function(n,e,s){var u=l.get(e)||[];u.push(s),l.set(e,u)});var a=new SparseMatrix([],[],[],d.getDims()),f=function(n){for(var e=l.get(n).sort(),s=e.map(function(b){return d.get(n,b)}),u=o(s),m=0;m<u.length;m++)a.set(n,e[m],u[m])};try{for(var p=__values$2(l.keys()),h=p.next();!h.done;h=p.next()){var c=h.value;f(c)}}catch(n){i={error:n}}finally{try{h&&!h.done&&(r=p.return)&&r.call(p)}finally{if(i)throw i.error}}return a}matrix$3.normalize=normalize;var normFns=(_a={},_a.max=function(d){for(var t=-1/0,i=0;i<d.length;i++)t=d[i]>t?d[i]:t;return d.map(function(r){return r/t})},_a.l1=function(d){for(var t=0,i=0;i<d.length;i++)t+=d[i];return d.map(function(r){return r/t})},_a.l2=function(d){for(var t=0,i=0;i<d.length;i++)t+=Math.pow(d[i],2);return d.map(function(r){return Math.sqrt(Math.pow(r,2)/t)})},_a);function elementWise(d,t,i){for(var r=new Set,o=[],l=[],a=[],f=function(y,v){o.push(y),l.push(v);var w=i(d.get(y,v),t.get(y,v));a.push(w)},p=d.getValues(),h=d.getRows(),c=d.getCols(),n=0;n<p.length;n++){var e=h[n],s=c[n],u=e+":"+s;r.add(u),f(e,s)}for(var m=t.getValues(),b=t.getRows(),g=t.getCols(),n=0;n<m.length;n++){var e=b[n],s=g[n],u=e+":"+s;r.has(u)||f(e,s)}var _=[d.nRows,d.nCols];return new SparseMatrix(o,l,a,_)}function getCSR(d){var t=[];d.forEach(function(n,e,s){t.push({value:n,row:e,col:s})}),t.sort(function(n,e){return n.row===e.row?n.col-e.col:n.row-e.row});for(var i=[],r=[],o=[],l=-1,a=0;a<t.length;a++){var f=t[a],p=f.row,h=f.col,c=f.value;p!==l&&(l=p,o.push(a)),i.push(h),r.push(c)}return{indices:i,values:r,indptr:o}}matrix$3.getCSR=getCSR;var nn_descent={},tree$2={},__read$1=commonjsGlobal&&commonjsGlobal.__read||function(d,t){var i=typeof Symbol=="function"&&d[Symbol.iterator];if(!i)return d;var r=i.call(d),o,l=[],a;try{for(;(t===void 0||t-- >0)&&!(o=r.next()).done;)l.push(o.value)}catch(f){a={error:f}}finally{try{o&&!o.done&&(i=r.return)&&i.call(r)}finally{if(a)throw a.error}}return l},__spread$1=commonjsGlobal&&commonjsGlobal.__spread||function(){for(var d=[],t=0;t<arguments.length;t++)d=d.concat(__read$1(arguments[t]));return d},__values$1=commonjsGlobal&&commonjsGlobal.__values||function(d){var t=typeof Symbol=="function"&&d[Symbol.iterator],i=0;return t?t.call(d):{next:function(){return d&&i>=d.length&&(d=void 0),{value:d&&d[i++],done:!d}}}},__importStar$2=commonjsGlobal&&commonjsGlobal.__importStar||function(d){if(d&&d.__esModule)return d;var t={};if(d!=null)for(var i in d)Object.hasOwnProperty.call(d,i)&&(t[i]=d[i]);return t.default=d,t};Object.defineProperty(tree$2,"__esModule",{value:!0});var utils$2=__importStar$2(utils$5),FlatTree=function(){function d(t,i,r,o){this.hyperplanes=t,this.offsets=i,this.children=r,this.indices=o}return d}();tree$2.FlatTree=FlatTree;function makeForest(d,t,i,r){var o=Math.max(10,t),l=utils$2.range(i).map(function(f,p){return makeTree(d,o,p,r)}),a=l.map(function(f){return flattenTree(f,o)});return a}tree$2.makeForest=makeForest;function makeTree(d,t,i,r){t===void 0&&(t=30);var o=utils$2.range(d.length),l=makeEuclideanTree(d,o,t,i,r);return l}function makeEuclideanTree(d,t,i,r,o){if(i===void 0&&(i=30),t.length>i){var l=euclideanRandomProjectionSplit(d,t,o),a=l.indicesLeft,f=l.indicesRight,p=l.hyperplane,h=l.offset,c=makeEuclideanTree(d,a,i,r+1,o),n=makeEuclideanTree(d,f,i,r+1,o),e={leftChild:c,rightChild:n,isLeaf:!1,hyperplane:p,offset:h};return e}else{var e={indices:t,isLeaf:!0};return e}}function euclideanRandomProjectionSplit(d,t,i){var r=d[0].length,o=utils$2.tauRandInt(t.length,i),l=utils$2.tauRandInt(t.length,i);l+=o===l?1:0,l=l%t.length;for(var a=t[o],f=t[l],p=0,h=utils$2.zeros(r),c=0;c<h.length;c++)h[c]=d[a][c]-d[f][c],p-=h[c]*(d[a][c]+d[f][c])/2;for(var n=0,e=0,s=utils$2.zeros(t.length),c=0;c<t.length;c++){for(var u=p,m=0;m<r;m++)u+=h[m]*d[t[c]][m];u===0?(s[c]=utils$2.tauRandInt(2,i),s[c]===0?n+=1:e+=1):u>0?(s[c]=0,n+=1):(s[c]=1,e+=1)}var b=utils$2.zeros(n),g=utils$2.zeros(e);n=0,e=0;for(var c=0;c<s.length;c++)s[c]===0?(b[n]=t[c],n+=1):(g[e]=t[c],e+=1);return{indicesLeft:b,indicesRight:g,hyperplane:h,offset:p}}function flattenTree(d,t){var i=numNodes(d),r=numLeaves(d),o=utils$2.range(i).map(function(){return utils$2.zeros(d.hyperplane?d.hyperplane.length:0)}),l=utils$2.zeros(i),a=utils$2.range(i).map(function(){return[-1,-1]}),f=utils$2.range(r).map(function(){return utils$2.range(t).map(function(){return-1})});return recursiveFlatten(d,o,l,a,f,0,0),new FlatTree(o,l,a,f)}function recursiveFlatten(d,t,i,r,o,l,a){var f;if(d.isLeaf)return r[l][0]=-a,(f=o[a]).splice.apply(f,__spread$1([0,d.indices.length],d.indices)),a+=1,{nodeNum:l,leafNum:a};t[l]=d.hyperplane,i[l]=d.offset,r[l][0]=l+1;var p=l,h=recursiveFlatten(d.leftChild,t,i,r,o,l+1,a);return l=h.nodeNum,a=h.leafNum,r[p][1]=l+1,h=recursiveFlatten(d.rightChild,t,i,r,o,l+1,a),{nodeNum:h.nodeNum,leafNum:h.leafNum}}function numNodes(d){return d.isLeaf?1:1+numNodes(d.leftChild)+numNodes(d.rightChild)}function numLeaves(d){return d.isLeaf?1:numLeaves(d.leftChild)+numLeaves(d.rightChild)}function makeLeafArray(d){var t,i;if(d.length>0){var r=[];try{for(var o=__values$1(d),l=o.next();!l.done;l=o.next()){var a=l.value;r.push.apply(r,__spread$1(a.indices))}}catch(f){t={error:f}}finally{try{l&&!l.done&&(i=o.return)&&i.call(o)}finally{if(t)throw t.error}}return r}else return[[-1]]}tree$2.makeLeafArray=makeLeafArray;function selectSide(d,t,i,r){for(var o=t,l=0;l<i.length;l++)o+=d[l]*i[l];if(o===0){var a=utils$2.tauRandInt(2,r);return a}else return o>0?0:1}function searchFlatTree(d,t,i){for(var r=0;t.children[r][0]>0;){var o=selectSide(t.hyperplanes[r],t.offsets[r],d,i);o===0?r=t.children[r][0]:r=t.children[r][1]}var l=-1*t.children[r][0];return t.indices[l]}tree$2.searchFlatTree=searchFlatTree;var __values=commonjsGlobal&&commonjsGlobal.__values||function(d){var t=typeof Symbol=="function"&&d[Symbol.iterator],i=0;return t?t.call(d):{next:function(){return d&&i>=d.length&&(d=void 0),{value:d&&d[i++],done:!d}}}},__importStar$1=commonjsGlobal&&commonjsGlobal.__importStar||function(d){if(d&&d.__esModule)return d;var t={};if(d!=null)for(var i in d)Object.hasOwnProperty.call(d,i)&&(t[i]=d[i]);return t.default=d,t};Object.defineProperty(nn_descent,"__esModule",{value:!0});var heap$1=__importStar$1(heap$2),matrix$2=__importStar$1(matrix$3),tree$1=__importStar$1(tree$2),utils$1=__importStar$1(utils$5);function makeNNDescent(d,t){return function(r,o,l,a,f,p,h,c){a===void 0&&(a=10),f===void 0&&(f=50),p===void 0&&(p=.001),h===void 0&&(h=.5),c===void 0&&(c=!0);for(var n=r.length,e=heap$1.makeHeap(r.length,l),s=0;s<r.length;s++)for(var u=heap$1.rejectionSample(l,r.length,t),m=0;m<u.length;m++){var b=d(r[s],r[u[m]]);heap$1.heapPush(e,s,b,u[m],1),heap$1.heapPush(e,u[m],b,s,1)}if(c)for(var g=0;g<o.length;g++)for(var s=0;s<o[g].length&&!(o[g][s]<0);s++)for(var m=s+1;m<o[g].length&&!(o[g][m]<0);m++){var b=d(r[o[g][s]],r[o[g][m]]);heap$1.heapPush(e,o[g][s],b,o[g][m],1),heap$1.heapPush(e,o[g][m],b,o[g][s],1)}for(var g=0;g<a;g++){for(var _=heap$1.buildCandidates(e,n,l,f,t),y=0,s=0;s<n;s++)for(var m=0;m<f;m++){var v=Math.floor(_[0][s][m]);if(!(v<0||utils$1.tauRand(t)<h))for(var w=0;w<f;w++){var M=Math.floor(_[0][s][w]),S=_[2][s][m],O=_[2][s][w];if(!(M<0||!S&&!O)){var b=d(r[v],r[M]);y+=heap$1.heapPush(e,v,b,M,1),y+=heap$1.heapPush(e,M,b,v,1)}}}if(y<=p*l*r.length)break}var x=heap$1.deheapSort(e);return x}}nn_descent.makeNNDescent=makeNNDescent;function makeInitializations(d){function t(r,o,l,a,f){for(var p=0;p<l.length;p++)for(var h=utils$1.rejectionSample(r,o.length,f),c=0;c<h.length;c++)if(!(h[c]<0)){var n=d(o[h[c]],l[p]);heap$1.heapPush(a,p,n,h[c],1)}}function i(r,o,l,a,f){for(var p=0;p<l.length;p++)for(var h=tree$1.searchFlatTree(l[p],r,f),c=0;c<h.length;c++){if(h[c]<0)return;var n=d(o[h[c]],l[p]);heap$1.heapPush(a,p,n,h[c],1)}}return{initFromRandom:t,initFromTree:i}}nn_descent.makeInitializations=makeInitializations;function makeInitializedNNSearch(d){return function(i,r,o,l){for(var a,f,p=matrix$2.getCSR(r),h=p.indices,c=p.indptr,n=0;n<l.length;n++)for(var e=new Set(o[0][n]);;){var s=heap$1.smallestFlagged(o,n);if(s===-1)break;var u=h.slice(c[s],c[s+1]);try{for(var m=__values(u),b=m.next();!b.done;b=m.next()){var g=b.value;if(!(g===s||g===-1||e.has(g))){var _=d(i[g],l[n]);heap$1.uncheckedHeapPush(o,n,_,g,1),e.add(g)}}}catch(y){a={error:y}}finally{try{b&&!b.done&&(f=m.return)&&f.call(m)}finally{if(a)throw a.error}}}return o}}nn_descent.makeInitializedNNSearch=makeInitializedNNSearch;function initializeSearch(d,t,i,r,o,l,a){var f,p,h=heap$1.makeHeap(i.length,r);if(o(r,t,i,h,a),d)try{for(var c=__values(d),n=c.next();!n.done;n=c.next()){var e=n.value;l(e,t,i,h,a)}}catch(s){f={error:s}}finally{try{n&&!n.done&&(p=c.return)&&p.call(c)}finally{if(f)throw f.error}}return h}nn_descent.initializeSearch=initializeSearch;const toString$1=Object.prototype.toString;function isAnyArray$2(d){return toString$1.call(d).endsWith("Array]")}function errorCalculation(d,t,i){let r=0;const o=i(t);for(let l=0;l<d.x.length;l++)r+=Math.abs(d.y[l]-o(d.x[l]));return r}var matrix$1={};const toString=Object.prototype.toString;function isAnyArray$1(d){const t=toString.call(d);return t.endsWith("Array]")&&!t.includes("Big")}var libEsm=Object.freeze({__proto__:null,isAnyArray:isAnyArray$1}),require$$0=getAugmentedNamespace(libEsm);function max(d){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!isAnyArray$1(d))throw new TypeError("input must be an array");if(d.length===0)throw new TypeError("input must not be empty");var i=t.fromIndex,r=i===void 0?0:i,o=t.toIndex,l=o===void 0?d.length:o;if(r<0||r>=d.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(l<=r||l>d.length||!Number.isInteger(l))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var a=d[r],f=r+1;f<l;f++)d[f]>a&&(a=d[f]);return a}function min(d){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!isAnyArray$1(d))throw new TypeError("input must be an array");if(d.length===0)throw new TypeError("input must not be empty");var i=t.fromIndex,r=i===void 0?0:i,o=t.toIndex,l=o===void 0?d.length:o;if(r<0||r>=d.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(l<=r||l>d.length||!Number.isInteger(l))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var a=d[r],f=r+1;f<l;f++)d[f]<a&&(a=d[f]);return a}function rescale$1(d){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(isAnyArray$1(d)){if(d.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var i;if(t.output!==void 0){if(!isAnyArray$1(t.output))throw new TypeError("output option must be an array if specified");i=t.output}else i=new Array(d.length);var r=min(d),o=max(d);if(r===o)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var l=t.min,a=l===void 0?t.autoMinMax?r:0:l,f=t.max,p=f===void 0?t.autoMinMax?o:1:f;if(a>=p)throw new RangeError("min option must be smaller than max option");for(var h=(p-a)/(o-r),c=0;c<d.length;c++)i[c]=(d[c]-r)*h+a;return i}var libEs6=Object.freeze({__proto__:null,default:rescale$1}),require$$1=getAugmentedNamespace(libEs6);Object.defineProperty(matrix$1,"__esModule",{value:!0});var isAnyArray=require$$0,rescale=require$$1;const indent=" ".repeat(2),indentData=" ".repeat(4);function inspectMatrix(){return inspectMatrixWithOptions(this)}function inspectMatrixWithOptions(d,t={}){const{maxRows:i=15,maxColumns:r=10,maxNumSize:o=8,padMinus:l="auto"}=t;return`${d.constructor.name} {
${indent}[
${indentData}${inspectData(d,i,r,o,l)}
${indent}]
${indent}rows: ${d.rows}
${indent}columns: ${d.columns}
}`}function inspectData(d,t,i,r,o){const{rows:l,columns:a}=d,f=Math.min(l,t),p=Math.min(a,i),h=[];if(o==="auto"){o=!1;e:for(let c=0;c<f;c++)for(let n=0;n<p;n++)if(d.get(c,n)<0){o=!0;break e}}for(let c=0;c<f;c++){let n=[];for(let e=0;e<p;e++)n.push(formatNumber(d.get(c,e),r,o));h.push(`${n.join(" ")}`)}return p!==a&&(h[h.length-1]+=` ... ${a-i} more columns`),f!==l&&h.push(`... ${l-t} more rows`),h.join(`
${indentData}`)}function formatNumber(d,t,i){return(d>=0&&i?` ${formatNumber2(d,t-1)}`:formatNumber2(d,t)).padEnd(t)}function formatNumber2(d,t){let i=d.toString();if(i.length<=t)return i;let r=d.toFixed(t);if(r.length>t&&(r=d.toFixed(Math.max(0,t-(r.length-t)))),r.length<=t&&!r.startsWith("0.000")&&!r.startsWith("-0.000"))return r;let o=d.toExponential(t);return o.length>t&&(o=d.toExponential(Math.max(0,t-(o.length-t)))),o.slice(0)}function installMathOperations(d,t){d.prototype.add=function(r){return typeof r=="number"?this.addS(r):this.addM(r)},d.prototype.addS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)+r);return this},d.prototype.addM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)+r.get(o,l));return this},d.add=function(r,o){return new t(r).add(o)},d.prototype.sub=function(r){return typeof r=="number"?this.subS(r):this.subM(r)},d.prototype.subS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)-r);return this},d.prototype.subM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)-r.get(o,l));return this},d.sub=function(r,o){return new t(r).sub(o)},d.prototype.subtract=d.prototype.sub,d.prototype.subtractS=d.prototype.subS,d.prototype.subtractM=d.prototype.subM,d.subtract=d.sub,d.prototype.mul=function(r){return typeof r=="number"?this.mulS(r):this.mulM(r)},d.prototype.mulS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)*r);return this},d.prototype.mulM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)*r.get(o,l));return this},d.mul=function(r,o){return new t(r).mul(o)},d.prototype.multiply=d.prototype.mul,d.prototype.multiplyS=d.prototype.mulS,d.prototype.multiplyM=d.prototype.mulM,d.multiply=d.mul,d.prototype.div=function(r){return typeof r=="number"?this.divS(r):this.divM(r)},d.prototype.divS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)/r);return this},d.prototype.divM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)/r.get(o,l));return this},d.div=function(r,o){return new t(r).div(o)},d.prototype.divide=d.prototype.div,d.prototype.divideS=d.prototype.divS,d.prototype.divideM=d.prototype.divM,d.divide=d.div,d.prototype.mod=function(r){return typeof r=="number"?this.modS(r):this.modM(r)},d.prototype.modS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)%r);return this},d.prototype.modM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)%r.get(o,l));return this},d.mod=function(r,o){return new t(r).mod(o)},d.prototype.modulus=d.prototype.mod,d.prototype.modulusS=d.prototype.modS,d.prototype.modulusM=d.prototype.modM,d.modulus=d.mod,d.prototype.and=function(r){return typeof r=="number"?this.andS(r):this.andM(r)},d.prototype.andS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)&r);return this},d.prototype.andM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)&r.get(o,l));return this},d.and=function(r,o){return new t(r).and(o)},d.prototype.or=function(r){return typeof r=="number"?this.orS(r):this.orM(r)},d.prototype.orS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)|r);return this},d.prototype.orM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)|r.get(o,l));return this},d.or=function(r,o){return new t(r).or(o)},d.prototype.xor=function(r){return typeof r=="number"?this.xorS(r):this.xorM(r)},d.prototype.xorS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)^r);return this},d.prototype.xorM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)^r.get(o,l));return this},d.xor=function(r,o){return new t(r).xor(o)},d.prototype.leftShift=function(r){return typeof r=="number"?this.leftShiftS(r):this.leftShiftM(r)},d.prototype.leftShiftS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)<<r);return this},d.prototype.leftShiftM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)<<r.get(o,l));return this},d.leftShift=function(r,o){return new t(r).leftShift(o)},d.prototype.signPropagatingRightShift=function(r){return typeof r=="number"?this.signPropagatingRightShiftS(r):this.signPropagatingRightShiftM(r)},d.prototype.signPropagatingRightShiftS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)>>r);return this},d.prototype.signPropagatingRightShiftM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)>>r.get(o,l));return this},d.signPropagatingRightShift=function(r,o){return new t(r).signPropagatingRightShift(o)},d.prototype.rightShift=function(r){return typeof r=="number"?this.rightShiftS(r):this.rightShiftM(r)},d.prototype.rightShiftS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)>>>r);return this},d.prototype.rightShiftM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,this.get(o,l)>>>r.get(o,l));return this},d.rightShift=function(r,o){return new t(r).rightShift(o)},d.prototype.zeroFillRightShift=d.prototype.rightShift,d.prototype.zeroFillRightShiftS=d.prototype.rightShiftS,d.prototype.zeroFillRightShiftM=d.prototype.rightShiftM,d.zeroFillRightShift=d.rightShift,d.prototype.not=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,~this.get(r,o));return this},d.not=function(r){return new t(r).not()},d.prototype.abs=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.abs(this.get(r,o)));return this},d.abs=function(r){return new t(r).abs()},d.prototype.acos=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.acos(this.get(r,o)));return this},d.acos=function(r){return new t(r).acos()},d.prototype.acosh=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.acosh(this.get(r,o)));return this},d.acosh=function(r){return new t(r).acosh()},d.prototype.asin=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.asin(this.get(r,o)));return this},d.asin=function(r){return new t(r).asin()},d.prototype.asinh=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.asinh(this.get(r,o)));return this},d.asinh=function(r){return new t(r).asinh()},d.prototype.atan=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.atan(this.get(r,o)));return this},d.atan=function(r){return new t(r).atan()},d.prototype.atanh=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.atanh(this.get(r,o)));return this},d.atanh=function(r){return new t(r).atanh()},d.prototype.cbrt=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.cbrt(this.get(r,o)));return this},d.cbrt=function(r){return new t(r).cbrt()},d.prototype.ceil=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.ceil(this.get(r,o)));return this},d.ceil=function(r){return new t(r).ceil()},d.prototype.clz32=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.clz32(this.get(r,o)));return this},d.clz32=function(r){return new t(r).clz32()},d.prototype.cos=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.cos(this.get(r,o)));return this},d.cos=function(r){return new t(r).cos()},d.prototype.cosh=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.cosh(this.get(r,o)));return this},d.cosh=function(r){return new t(r).cosh()},d.prototype.exp=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.exp(this.get(r,o)));return this},d.exp=function(r){return new t(r).exp()},d.prototype.expm1=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.expm1(this.get(r,o)));return this},d.expm1=function(r){return new t(r).expm1()},d.prototype.floor=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.floor(this.get(r,o)));return this},d.floor=function(r){return new t(r).floor()},d.prototype.fround=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.fround(this.get(r,o)));return this},d.fround=function(r){return new t(r).fround()},d.prototype.log=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.log(this.get(r,o)));return this},d.log=function(r){return new t(r).log()},d.prototype.log1p=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.log1p(this.get(r,o)));return this},d.log1p=function(r){return new t(r).log1p()},d.prototype.log10=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.log10(this.get(r,o)));return this},d.log10=function(r){return new t(r).log10()},d.prototype.log2=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.log2(this.get(r,o)));return this},d.log2=function(r){return new t(r).log2()},d.prototype.round=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.round(this.get(r,o)));return this},d.round=function(r){return new t(r).round()},d.prototype.sign=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.sign(this.get(r,o)));return this},d.sign=function(r){return new t(r).sign()},d.prototype.sin=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.sin(this.get(r,o)));return this},d.sin=function(r){return new t(r).sin()},d.prototype.sinh=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.sinh(this.get(r,o)));return this},d.sinh=function(r){return new t(r).sinh()},d.prototype.sqrt=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.sqrt(this.get(r,o)));return this},d.sqrt=function(r){return new t(r).sqrt()},d.prototype.tan=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.tan(this.get(r,o)));return this},d.tan=function(r){return new t(r).tan()},d.prototype.tanh=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.tanh(this.get(r,o)));return this},d.tanh=function(r){return new t(r).tanh()},d.prototype.trunc=function(){for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.set(r,o,Math.trunc(this.get(r,o)));return this},d.trunc=function(r){return new t(r).trunc()},d.pow=function(r,o){return new t(r).pow(o)},d.prototype.pow=function(r){return typeof r=="number"?this.powS(r):this.powM(r)},d.prototype.powS=function(r){for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,Math.pow(this.get(o,l),r));return this},d.prototype.powM=function(r){if(r=t.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let o=0;o<this.rows;o++)for(let l=0;l<this.columns;l++)this.set(o,l,Math.pow(this.get(o,l),r.get(o,l)));return this}}function checkRowIndex(d,t,i){let r=i?d.rows:d.rows-1;if(t<0||t>r)throw new RangeError("Row index out of range")}function checkColumnIndex(d,t,i){let r=i?d.columns:d.columns-1;if(t<0||t>r)throw new RangeError("Column index out of range")}function checkRowVector(d,t){if(t.to1DArray&&(t=t.to1DArray()),t.length!==d.columns)throw new RangeError("vector size must be the same as the number of columns");return t}function checkColumnVector(d,t){if(t.to1DArray&&(t=t.to1DArray()),t.length!==d.rows)throw new RangeError("vector size must be the same as the number of rows");return t}function checkRowIndices(d,t){if(!isAnyArray.isAnyArray(t))throw new TypeError("row indices must be an array");for(let i=0;i<t.length;i++)if(t[i]<0||t[i]>=d.rows)throw new RangeError("row indices are out of range")}function checkColumnIndices(d,t){if(!isAnyArray.isAnyArray(t))throw new TypeError("column indices must be an array");for(let i=0;i<t.length;i++)if(t[i]<0||t[i]>=d.columns)throw new RangeError("column indices are out of range")}function checkRange(d,t,i,r,o){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",t),checkNumber("endRow",i),checkNumber("startColumn",r),checkNumber("endColumn",o),t>i||r>o||t<0||t>=d.rows||i<0||i>=d.rows||r<0||r>=d.columns||o<0||o>=d.columns)throw new RangeError("Submatrix indices are out of range")}function newArray(d,t=0){let i=[];for(let r=0;r<d;r++)i.push(t);return i}function checkNumber(d,t){if(typeof t!="number")throw new TypeError(`${d} must be a number`)}function checkNonEmpty(d){if(d.isEmpty())throw new Error("Empty matrix has no elements to index")}function sumByRow(d){let t=newArray(d.rows);for(let i=0;i<d.rows;++i)for(let r=0;r<d.columns;++r)t[i]+=d.get(i,r);return t}function sumByColumn(d){let t=newArray(d.columns);for(let i=0;i<d.rows;++i)for(let r=0;r<d.columns;++r)t[r]+=d.get(i,r);return t}function sumAll(d){let t=0;for(let i=0;i<d.rows;i++)for(let r=0;r<d.columns;r++)t+=d.get(i,r);return t}function productByRow(d){let t=newArray(d.rows,1);for(let i=0;i<d.rows;++i)for(let r=0;r<d.columns;++r)t[i]*=d.get(i,r);return t}function productByColumn(d){let t=newArray(d.columns,1);for(let i=0;i<d.rows;++i)for(let r=0;r<d.columns;++r)t[r]*=d.get(i,r);return t}function productAll(d){let t=1;for(let i=0;i<d.rows;i++)for(let r=0;r<d.columns;r++)t*=d.get(i,r);return t}function varianceByRow(d,t,i){const r=d.rows,o=d.columns,l=[];for(let a=0;a<r;a++){let f=0,p=0,h=0;for(let c=0;c<o;c++)h=d.get(a,c)-i[a],f+=h,p+=h*h;t?l.push((p-f*f/o)/(o-1)):l.push((p-f*f/o)/o)}return l}function varianceByColumn(d,t,i){const r=d.rows,o=d.columns,l=[];for(let a=0;a<o;a++){let f=0,p=0,h=0;for(let c=0;c<r;c++)h=d.get(c,a)-i[a],f+=h,p+=h*h;t?l.push((p-f*f/r)/(r-1)):l.push((p-f*f/r)/r)}return l}function varianceAll(d,t,i){const r=d.rows,o=d.columns,l=r*o;let a=0,f=0,p=0;for(let h=0;h<r;h++)for(let c=0;c<o;c++)p=d.get(h,c)-i,a+=p,f+=p*p;return t?(f-a*a/l)/(l-1):(f-a*a/l)/l}function centerByRow(d,t){for(let i=0;i<d.rows;i++)for(let r=0;r<d.columns;r++)d.set(i,r,d.get(i,r)-t[i])}function centerByColumn(d,t){for(let i=0;i<d.rows;i++)for(let r=0;r<d.columns;r++)d.set(i,r,d.get(i,r)-t[r])}function centerAll(d,t){for(let i=0;i<d.rows;i++)for(let r=0;r<d.columns;r++)d.set(i,r,d.get(i,r)-t)}function getScaleByRow(d){const t=[];for(let i=0;i<d.rows;i++){let r=0;for(let o=0;o<d.columns;o++)r+=Math.pow(d.get(i,o),2)/(d.columns-1);t.push(Math.sqrt(r))}return t}function scaleByRow(d,t){for(let i=0;i<d.rows;i++)for(let r=0;r<d.columns;r++)d.set(i,r,d.get(i,r)/t[i])}function getScaleByColumn(d){const t=[];for(let i=0;i<d.columns;i++){let r=0;for(let o=0;o<d.rows;o++)r+=Math.pow(d.get(o,i),2)/(d.rows-1);t.push(Math.sqrt(r))}return t}function scaleByColumn(d,t){for(let i=0;i<d.rows;i++)for(let r=0;r<d.columns;r++)d.set(i,r,d.get(i,r)/t[r])}function getScaleAll(d){const t=d.size-1;let i=0;for(let r=0;r<d.columns;r++)for(let o=0;o<d.rows;o++)i+=Math.pow(d.get(o,r),2)/t;return Math.sqrt(i)}function scaleAll(d,t){for(let i=0;i<d.rows;i++)for(let r=0;r<d.columns;r++)d.set(i,r,d.get(i,r)/t)}class AbstractMatrix{static from1DArray(t,i,r){if(t*i!==r.length)throw new RangeError("data length does not match given dimensions");let l=new Matrix$1(t,i);for(let a=0;a<t;a++)for(let f=0;f<i;f++)l.set(a,f,r[a*i+f]);return l}static rowVector(t){let i=new Matrix$1(1,t.length);for(let r=0;r<t.length;r++)i.set(0,r,t[r]);return i}static columnVector(t){let i=new Matrix$1(t.length,1);for(let r=0;r<t.length;r++)i.set(r,0,t[r]);return i}static zeros(t,i){return new Matrix$1(t,i)}static ones(t,i){return new Matrix$1(t,i).fill(1)}static rand(t,i,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{random:o=Math.random}=r;let l=new Matrix$1(t,i);for(let a=0;a<t;a++)for(let f=0;f<i;f++)l.set(a,f,o());return l}static randInt(t,i,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{min:o=0,max:l=1e3,random:a=Math.random}=r;if(!Number.isInteger(o))throw new TypeError("min must be an integer");if(!Number.isInteger(l))throw new TypeError("max must be an integer");if(o>=l)throw new RangeError("min must be smaller than max");let f=l-o,p=new Matrix$1(t,i);for(let h=0;h<t;h++)for(let c=0;c<i;c++){let n=o+Math.round(a()*f);p.set(h,c,n)}return p}static eye(t,i,r){i===void 0&&(i=t),r===void 0&&(r=1);let o=Math.min(t,i),l=this.zeros(t,i);for(let a=0;a<o;a++)l.set(a,a,r);return l}static diag(t,i,r){let o=t.length;i===void 0&&(i=o),r===void 0&&(r=i);let l=Math.min(o,i,r),a=this.zeros(i,r);for(let f=0;f<l;f++)a.set(f,f,t[f]);return a}static min(t,i){t=this.checkMatrix(t),i=this.checkMatrix(i);let r=t.rows,o=t.columns,l=new Matrix$1(r,o);for(let a=0;a<r;a++)for(let f=0;f<o;f++)l.set(a,f,Math.min(t.get(a,f),i.get(a,f)));return l}static max(t,i){t=this.checkMatrix(t),i=this.checkMatrix(i);let r=t.rows,o=t.columns,l=new this(r,o);for(let a=0;a<r;a++)for(let f=0;f<o;f++)l.set(a,f,Math.max(t.get(a,f),i.get(a,f)));return l}static checkMatrix(t){return AbstractMatrix.isMatrix(t)?t:new Matrix$1(t)}static isMatrix(t){return t!=null&&t.klass==="Matrix"}get size(){return this.rows*this.columns}apply(t){if(typeof t!="function")throw new TypeError("callback must be a function");for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)t.call(this,i,r);return this}to1DArray(){let t=[];for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)t.push(this.get(i,r));return t}to2DArray(){let t=[];for(let i=0;i<this.rows;i++){t.push([]);for(let r=0;r<this.columns;r++)t[i].push(this.get(i,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let i=0;i<=t;i++)if(this.get(t,i)!==this.get(i,t))return!1;return!0}return!1}isDistance(){if(!this.isSymmetric())return!1;for(let t=0;t<this.rows;t++)if(this.get(t,t)!==0)return!1;return!0}isEchelonForm(){let t=0,i=0,r=-1,o=!0,l=!1;for(;t<this.rows&&o;){for(i=0,l=!1;i<this.columns&&l===!1;)this.get(t,i)===0?i++:this.get(t,i)===1&&i>r?(l=!0,r=i):(o=!1,l=!0);t++}return o}isReducedEchelonForm(){let t=0,i=0,r=-1,o=!0,l=!1;for(;t<this.rows&&o;){for(i=0,l=!1;i<this.columns&&l===!1;)this.get(t,i)===0?i++:this.get(t,i)===1&&i>r?(l=!0,r=i):(o=!1,l=!0);for(let a=i+1;a<this.rows;a++)this.get(t,a)!==0&&(o=!1);t++}return o}echelonForm(){let t=this.clone(),i=0,r=0;for(;i<t.rows&&r<t.columns;){let o=i;for(let l=i;l<t.rows;l++)t.get(l,r)>t.get(o,r)&&(o=l);if(t.get(o,r)===0)r++;else{t.swapRows(i,o);let l=t.get(i,r);for(let a=r;a<t.columns;a++)t.set(i,a,t.get(i,a)/l);for(let a=i+1;a<t.rows;a++){let f=t.get(a,r)/t.get(i,r);t.set(a,r,0);for(let p=r+1;p<t.columns;p++)t.set(a,p,t.get(a,p)-t.get(i,p)*f)}i++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),i=t.columns,r=t.rows,o=r-1;for(;o>=0;)if(t.maxRow(o)===0)o--;else{let l=0,a=!1;for(;l<r&&a===!1;)t.get(o,l)===1?a=!0:l++;for(let f=0;f<o;f++){let p=t.get(f,l);for(let h=l;h<i;h++){let c=t.get(f,h)-p*t.get(o,h);t.set(f,h,c)}}o--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{rows:i=1,columns:r=1}=t;if(!Number.isInteger(i)||i<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let o=new Matrix$1(this.rows*i,this.columns*r);for(let l=0;l<i;l++)for(let a=0;a<r;a++)o.setSubMatrix(this,this.rows*l,this.columns*a);return o}fill(t){for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,t);return this}neg(){return this.mulS(-1)}getRow(t){checkRowIndex(this,t);let i=[];for(let r=0;r<this.columns;r++)i.push(this.get(t,r));return i}getRowVector(t){return Matrix$1.rowVector(this.getRow(t))}setRow(t,i){checkRowIndex(this,t),i=checkRowVector(this,i);for(let r=0;r<this.columns;r++)this.set(t,r,i[r]);return this}swapRows(t,i){checkRowIndex(this,t),checkRowIndex(this,i);for(let r=0;r<this.columns;r++){let o=this.get(t,r);this.set(t,r,this.get(i,r)),this.set(i,r,o)}return this}getColumn(t){checkColumnIndex(this,t);let i=[];for(let r=0;r<this.rows;r++)i.push(this.get(r,t));return i}getColumnVector(t){return Matrix$1.columnVector(this.getColumn(t))}setColumn(t,i){checkColumnIndex(this,t),i=checkColumnVector(this,i);for(let r=0;r<this.rows;r++)this.set(r,t,i[r]);return this}swapColumns(t,i){checkColumnIndex(this,t),checkColumnIndex(this,i);for(let r=0;r<this.rows;r++){let o=this.get(r,t);this.set(r,t,this.get(r,i)),this.set(r,i,o)}return this}addRowVector(t){t=checkRowVector(this,t);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,this.get(i,r)+t[r]);return this}subRowVector(t){t=checkRowVector(this,t);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,this.get(i,r)-t[r]);return this}mulRowVector(t){t=checkRowVector(this,t);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,this.get(i,r)*t[r]);return this}divRowVector(t){t=checkRowVector(this,t);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,this.get(i,r)/t[r]);return this}addColumnVector(t){t=checkColumnVector(this,t);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,this.get(i,r)+t[i]);return this}subColumnVector(t){t=checkColumnVector(this,t);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,this.get(i,r)-t[i]);return this}mulColumnVector(t){t=checkColumnVector(this,t);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,this.get(i,r)*t[i]);return this}divColumnVector(t){t=checkColumnVector(this,t);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)this.set(i,r,this.get(i,r)/t[i]);return this}mulRow(t,i){checkRowIndex(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*i);return this}mulColumn(t,i){checkColumnIndex(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*i);return this}max(t){if(this.isEmpty())return NaN;switch(t){case"row":{const i=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)>i[r]&&(i[r]=this.get(r,o));return i}case"column":{const i=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)>i[o]&&(i[o]=this.get(r,o));return i}case void 0:{let i=this.get(0,0);for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)>i&&(i=this.get(r,o));return i}default:throw new Error(`invalid option: ${t}`)}}maxIndex(){checkNonEmpty(this);let t=this.get(0,0),i=[0,0];for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)>t&&(t=this.get(r,o),i[0]=r,i[1]=o);return i}min(t){if(this.isEmpty())return NaN;switch(t){case"row":{const i=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)<i[r]&&(i[r]=this.get(r,o));return i}case"column":{const i=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)<i[o]&&(i[o]=this.get(r,o));return i}case void 0:{let i=this.get(0,0);for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)<i&&(i=this.get(r,o));return i}default:throw new Error(`invalid option: ${t}`)}}minIndex(){checkNonEmpty(this);let t=this.get(0,0),i=[0,0];for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)<t&&(t=this.get(r,o),i[0]=r,i[1]=o);return i}maxRow(t){if(checkRowIndex(this,t),this.isEmpty())return NaN;let i=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>i&&(i=this.get(t,r));return i}maxRowIndex(t){checkRowIndex(this,t),checkNonEmpty(this);let i=this.get(t,0),r=[t,0];for(let o=1;o<this.columns;o++)this.get(t,o)>i&&(i=this.get(t,o),r[1]=o);return r}minRow(t){if(checkRowIndex(this,t),this.isEmpty())return NaN;let i=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<i&&(i=this.get(t,r));return i}minRowIndex(t){checkRowIndex(this,t),checkNonEmpty(this);let i=this.get(t,0),r=[t,0];for(let o=1;o<this.columns;o++)this.get(t,o)<i&&(i=this.get(t,o),r[1]=o);return r}maxColumn(t){if(checkColumnIndex(this,t),this.isEmpty())return NaN;let i=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>i&&(i=this.get(r,t));return i}maxColumnIndex(t){checkColumnIndex(this,t),checkNonEmpty(this);let i=this.get(0,t),r=[0,t];for(let o=1;o<this.rows;o++)this.get(o,t)>i&&(i=this.get(o,t),r[0]=o);return r}minColumn(t){if(checkColumnIndex(this,t),this.isEmpty())return NaN;let i=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<i&&(i=this.get(r,t));return i}minColumnIndex(t){checkColumnIndex(this,t),checkNonEmpty(this);let i=this.get(0,t),r=[0,t];for(let o=1;o<this.rows;o++)this.get(o,t)<i&&(i=this.get(o,t),r[0]=o);return r}diag(){let t=Math.min(this.rows,this.columns),i=[];for(let r=0;r<t;r++)i.push(this.get(r,r));return i}norm(t="frobenius"){switch(t){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${t}`)}}cumulativeSum(){let t=0;for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)t+=this.get(i,r),this.set(i,r,t);return this}dot(t){AbstractMatrix.isMatrix(t)&&(t=t.to1DArray());let i=this.to1DArray();if(i.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let o=0;o<i.length;o++)r+=i[o]*t[o];return r}mmul(t){t=Matrix$1.checkMatrix(t);let i=this.rows,r=this.columns,o=t.columns,l=new Matrix$1(i,o),a=new Float64Array(r);for(let f=0;f<o;f++){for(let p=0;p<r;p++)a[p]=t.get(p,f);for(let p=0;p<i;p++){let h=0;for(let c=0;c<r;c++)h+=this.get(p,c)*a[c];l.set(p,f,h)}}return l}strassen2x2(t){t=Matrix$1.checkMatrix(t);let i=new Matrix$1(2,2);const r=this.get(0,0),o=t.get(0,0),l=this.get(0,1),a=t.get(0,1),f=this.get(1,0),p=t.get(1,0),h=this.get(1,1),c=t.get(1,1),n=(r+h)*(o+c),e=(f+h)*o,s=r*(a-c),u=h*(p-o),m=(r+l)*c,b=(f-r)*(o+a),g=(l-h)*(p+c),_=n+u-m+g,y=s+m,v=e+u,w=n-e+s+b;return i.set(0,0,_),i.set(0,1,y),i.set(1,0,v),i.set(1,1,w),i}strassen3x3(t){t=Matrix$1.checkMatrix(t);let i=new Matrix$1(3,3);const r=this.get(0,0),o=this.get(0,1),l=this.get(0,2),a=this.get(1,0),f=this.get(1,1),p=this.get(1,2),h=this.get(2,0),c=this.get(2,1),n=this.get(2,2),e=t.get(0,0),s=t.get(0,1),u=t.get(0,2),m=t.get(1,0),b=t.get(1,1),g=t.get(1,2),_=t.get(2,0),y=t.get(2,1),v=t.get(2,2),w=(r+o+l-a-f-c-n)*b,M=(r-a)*(-s+b),S=f*(-e+s+m-b-g-_+v),O=(-r+a+f)*(e-s+b),x=(a+f)*(-e+s),T=r*e,I=(-r+h+c)*(e-u+g),F=(-r+h)*(u-g),C=(h+c)*(-e+u),N=(r+o+l-f-p-h-c)*g,B=c*(-e+u+m-b-g-_+y),k=(-l+c+n)*(b+_-y),R=(l-n)*(b-y),X=l*_,U=(c+n)*(-_+y),K=(-l+f+p)*(g+_-v),Q=(l-p)*(g-v),se=(f+p)*(-_+v),te=o*m,ae=p*y,ne=a*u,ce=h*s,oe=n*v,De=T+X+te,$e=w+O+x+T+k+X+U,Te=T+I+C+N+X+K+se,Ne=M+S+O+T+X+K+Q,Fe=M+O+x+T+ae,Ae=X+K+Q+se+ne,Se=T+I+F+B+k+R+X,Ue=k+R+X+U+ce,Ge=T+I+F+C+oe;return i.set(0,0,De),i.set(0,1,$e),i.set(0,2,Te),i.set(1,0,Ne),i.set(1,1,Fe),i.set(1,2,Ae),i.set(2,0,Se),i.set(2,1,Ue),i.set(2,2,Ge),i}mmulStrassen(t){t=Matrix$1.checkMatrix(t);let i=this.clone(),r=i.rows,o=i.columns,l=t.rows,a=t.columns;o!==l&&console.warn(`Multiplying ${r} x ${o} and ${l} x ${a} matrix: dimensions do not match.`);function f(n,e,s){let u=n.rows,m=n.columns;if(u===e&&m===s)return n;{let b=AbstractMatrix.zeros(e,s);return b=b.setSubMatrix(n,0,0),b}}let p=Math.max(r,l),h=Math.max(o,a);i=f(i,p,h),t=f(t,p,h);function c(n,e,s,u){if(s<=512||u<=512)return n.mmul(e);s%2===1&&u%2===1?(n=f(n,s+1,u+1),e=f(e,s+1,u+1)):s%2===1?(n=f(n,s+1,u),e=f(e,s+1,u)):u%2===1&&(n=f(n,s,u+1),e=f(e,s,u+1));let m=parseInt(n.rows/2,10),b=parseInt(n.columns/2,10),g=n.subMatrix(0,m-1,0,b-1),_=e.subMatrix(0,m-1,0,b-1),y=n.subMatrix(0,m-1,b,n.columns-1),v=e.subMatrix(0,m-1,b,e.columns-1),w=n.subMatrix(m,n.rows-1,0,b-1),M=e.subMatrix(m,e.rows-1,0,b-1),S=n.subMatrix(m,n.rows-1,b,n.columns-1),O=e.subMatrix(m,e.rows-1,b,e.columns-1),x=c(AbstractMatrix.add(g,S),AbstractMatrix.add(_,O),m,b),T=c(AbstractMatrix.add(w,S),_,m,b),I=c(g,AbstractMatrix.sub(v,O),m,b),F=c(S,AbstractMatrix.sub(M,_),m,b),C=c(AbstractMatrix.add(g,y),O,m,b),N=c(AbstractMatrix.sub(w,g),AbstractMatrix.add(_,v),m,b),B=c(AbstractMatrix.sub(y,S),AbstractMatrix.add(M,O),m,b),k=AbstractMatrix.add(x,F);k.sub(C),k.add(B);let R=AbstractMatrix.add(I,C),X=AbstractMatrix.add(T,F),U=AbstractMatrix.sub(x,T);U.add(I),U.add(N);let K=AbstractMatrix.zeros(2*k.rows,2*k.columns);return K=K.setSubMatrix(k,0,0),K=K.setSubMatrix(R,k.rows,0),K=K.setSubMatrix(X,0,k.columns),K=K.setSubMatrix(U,k.rows,k.columns),K.subMatrix(0,s-1,0,u-1)}return c(i,t,p,h)}scaleRows(t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{min:i=0,max:r=1}=t;if(!Number.isFinite(i))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(i>=r)throw new RangeError("min must be smaller than max");let o=new Matrix$1(this.rows,this.columns);for(let l=0;l<this.rows;l++){const a=this.getRow(l);a.length>0&&rescale(a,{min:i,max:r,output:a}),o.setRow(l,a)}return o}scaleColumns(t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{min:i=0,max:r=1}=t;if(!Number.isFinite(i))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(i>=r)throw new RangeError("min must be smaller than max");let o=new Matrix$1(this.rows,this.columns);for(let l=0;l<this.columns;l++){const a=this.getColumn(l);a.length&&rescale(a,{min:i,max:r,output:a}),o.setColumn(l,a)}return o}flipRows(){const t=Math.ceil(this.columns/2);for(let i=0;i<this.rows;i++)for(let r=0;r<t;r++){let o=this.get(i,r),l=this.get(i,this.columns-1-r);this.set(i,r,l),this.set(i,this.columns-1-r,o)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let i=0;i<this.columns;i++)for(let r=0;r<t;r++){let o=this.get(r,i),l=this.get(this.rows-1-r,i);this.set(r,i,l),this.set(this.rows-1-r,i,o)}return this}kroneckerProduct(t){t=Matrix$1.checkMatrix(t);let i=this.rows,r=this.columns,o=t.rows,l=t.columns,a=new Matrix$1(i*o,r*l);for(let f=0;f<i;f++)for(let p=0;p<r;p++)for(let h=0;h<o;h++)for(let c=0;c<l;c++)a.set(o*f+h,l*p+c,this.get(f,p)*t.get(h,c));return a}kroneckerSum(t){if(t=Matrix$1.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let i=this.rows,r=t.rows,o=this.kroneckerProduct(Matrix$1.eye(r,r)),l=Matrix$1.eye(i,i).kroneckerProduct(t);return o.add(l)}transpose(){let t=new Matrix$1(this.columns,this.rows);for(let i=0;i<this.rows;i++)for(let r=0;r<this.columns;r++)t.set(r,i,this.get(i,r));return t}sortRows(t=compareNumbers){for(let i=0;i<this.rows;i++)this.setRow(i,this.getRow(i).sort(t));return this}sortColumns(t=compareNumbers){for(let i=0;i<this.columns;i++)this.setColumn(i,this.getColumn(i).sort(t));return this}subMatrix(t,i,r,o){checkRange(this,t,i,r,o);let l=new Matrix$1(i-t+1,o-r+1);for(let a=t;a<=i;a++)for(let f=r;f<=o;f++)l.set(a-t,f-r,this.get(a,f));return l}subMatrixRow(t,i,r){if(i===void 0&&(i=0),r===void 0&&(r=this.columns-1),i>r||i<0||i>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let o=new Matrix$1(t.length,r-i+1);for(let l=0;l<t.length;l++)for(let a=i;a<=r;a++){if(t[l]<0||t[l]>=this.rows)throw new RangeError(`Row index out of range: ${t[l]}`);o.set(l,a-i,this.get(t[l],a))}return o}subMatrixColumn(t,i,r){if(i===void 0&&(i=0),r===void 0&&(r=this.rows-1),i>r||i<0||i>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let o=new Matrix$1(r-i+1,t.length);for(let l=0;l<t.length;l++)for(let a=i;a<=r;a++){if(t[l]<0||t[l]>=this.columns)throw new RangeError(`Column index out of range: ${t[l]}`);o.set(a-i,l,this.get(a,t[l]))}return o}setSubMatrix(t,i,r){if(t=Matrix$1.checkMatrix(t),t.isEmpty())return this;let o=i+t.rows-1,l=r+t.columns-1;checkRange(this,i,o,r,l);for(let a=0;a<t.rows;a++)for(let f=0;f<t.columns;f++)this.set(i+a,r+f,t.get(a,f));return this}selection(t,i){checkRowIndices(this,t),checkColumnIndices(this,i);let r=new Matrix$1(t.length,i.length);for(let o=0;o<t.length;o++){let l=t[o];for(let a=0;a<i.length;a++){let f=i[a];r.set(o,a,this.get(l,f))}}return r}trace(){let t=Math.min(this.rows,this.columns),i=0;for(let r=0;r<t;r++)i+=this.get(r,r);return i}clone(){return this.constructor.copy(this,new Matrix$1(this.rows,this.columns))}static copy(t,i){for(const[r,o,l]of t.entries())i.set(r,o,l);return i}sum(t){switch(t){case"row":return sumByRow(this);case"column":return sumByColumn(this);case void 0:return sumAll(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return productByRow(this);case"column":return productByColumn(this);case void 0:return productAll(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const i=this.sum(t);switch(t){case"row":{for(let r=0;r<this.rows;r++)i[r]/=this.columns;return i}case"column":{for(let r=0;r<this.columns;r++)i[r]/=this.rows;return i}case void 0:return i/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,i={}){if(typeof t=="object"&&(i=t,t=void 0),typeof i!="object")throw new TypeError("options must be an object");const{unbiased:r=!0,mean:o=this.mean(t)}=i;if(typeof r!="boolean")throw new TypeError("unbiased must be a boolean");switch(t){case"row":{if(!isAnyArray.isAnyArray(o))throw new TypeError("mean must be an array");return varianceByRow(this,r,o)}case"column":{if(!isAnyArray.isAnyArray(o))throw new TypeError("mean must be an array");return varianceByColumn(this,r,o)}case void 0:{if(typeof o!="number")throw new TypeError("mean must be a number");return varianceAll(this,r,o)}default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,i){typeof t=="object"&&(i=t,t=void 0);const r=this.variance(t,i);if(t===void 0)return Math.sqrt(r);for(let o=0;o<r.length;o++)r[o]=Math.sqrt(r[o]);return r}center(t,i={}){if(typeof t=="object"&&(i=t,t=void 0),typeof i!="object")throw new TypeError("options must be an object");const{center:r=this.mean(t)}=i;switch(t){case"row":{if(!isAnyArray.isAnyArray(r))throw new TypeError("center must be an array");return centerByRow(this,r),this}case"column":{if(!isAnyArray.isAnyArray(r))throw new TypeError("center must be an array");return centerByColumn(this,r),this}case void 0:{if(typeof r!="number")throw new TypeError("center must be a number");return centerAll(this,r),this}default:throw new Error(`invalid option: ${t}`)}}scale(t,i={}){if(typeof t=="object"&&(i=t,t=void 0),typeof i!="object")throw new TypeError("options must be an object");let r=i.scale;switch(t){case"row":{if(r===void 0)r=getScaleByRow(this);else if(!isAnyArray.isAnyArray(r))throw new TypeError("scale must be an array");return scaleByRow(this,r),this}case"column":{if(r===void 0)r=getScaleByColumn(this);else if(!isAnyArray.isAnyArray(r))throw new TypeError("scale must be an array");return scaleByColumn(this,r),this}case void 0:{if(r===void 0)r=getScaleAll(this);else if(typeof r!="number")throw new TypeError("scale must be a number");return scaleAll(this,r),this}default:throw new Error(`invalid option: ${t}`)}}toString(t){return inspectMatrixWithOptions(this,t)}[Symbol.iterator](){return this.entries()}*entries(){for(let t=0;t<this.rows;t++)for(let i=0;i<this.columns;i++)yield[t,i,this.get(t,i)]}*values(){for(let t=0;t<this.rows;t++)for(let i=0;i<this.columns;i++)yield this.get(t,i)}}AbstractMatrix.prototype.klass="Matrix",typeof Symbol<"u"&&(AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")]=inspectMatrix);function compareNumbers(d,t){return d-t}function isArrayOfNumbers(d){return d.every(t=>typeof t=="number")}AbstractMatrix.random=AbstractMatrix.rand,AbstractMatrix.randomInt=AbstractMatrix.randInt,AbstractMatrix.diagonal=AbstractMatrix.diag,AbstractMatrix.prototype.diagonal=AbstractMatrix.prototype.diag,AbstractMatrix.identity=AbstractMatrix.eye,AbstractMatrix.prototype.negate=AbstractMatrix.prototype.neg,AbstractMatrix.prototype.tensorProduct=AbstractMatrix.prototype.kroneckerProduct;let Matrix$1=(nt=class extends AbstractMatrix{constructor(i,r){super();Ht(this,Ee);Be(this,"data");if(nt.isMatrix(i))Xt(this,Ee,Kt).call(this,i.rows,i.columns),nt.copy(i,this);else if(Number.isInteger(i)&&i>=0)Xt(this,Ee,Kt).call(this,i,r);else if(isAnyArray.isAnyArray(i)){const o=i;if(i=o.length,r=i?o[0].length:0,typeof r!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let l=0;l<i;l++){if(o[l].length!==r)throw new RangeError("Inconsistent array dimensions");if(!isArrayOfNumbers(o[l]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(o[l]))}this.rows=i,this.columns=r}else throw new TypeError("First argument must be a positive number or an array")}set(i,r,o){return this.data[i][r]=o,this}get(i,r){return this.data[i][r]}removeRow(i){return checkRowIndex(this,i),this.data.splice(i,1),this.rows-=1,this}addRow(i,r){return r===void 0&&(r=i,i=this.rows),checkRowIndex(this,i,!0),r=Float64Array.from(checkRowVector(this,r)),this.data.splice(i,0,r),this.rows+=1,this}removeColumn(i){checkColumnIndex(this,i);for(let r=0;r<this.rows;r++){const o=new Float64Array(this.columns-1);for(let l=0;l<i;l++)o[l]=this.data[r][l];for(let l=i+1;l<this.columns;l++)o[l-1]=this.data[r][l];this.data[r]=o}return this.columns-=1,this}addColumn(i,r){typeof r>"u"&&(r=i,i=this.columns),checkColumnIndex(this,i,!0),r=checkColumnVector(this,r);for(let o=0;o<this.rows;o++){const l=new Float64Array(this.columns+1);let a=0;for(;a<i;a++)l[a]=this.data[o][a];for(l[a++]=r[o];a<this.columns+1;a++)l[a]=this.data[o][a-1];this.data[o]=l}return this.columns+=1,this}},Ee=new WeakSet,Kt=function(i,r){if(this.data=[],Number.isInteger(r)&&r>=0)for(let o=0;o<i;o++)this.data.push(new Float64Array(r));else throw new TypeError("nColumns must be a positive integer");this.rows=i,this.columns=r},nt);installMathOperations(AbstractMatrix,Matrix$1);const kt=class extends AbstractMatrix{constructor(i){super();Ht(this,ze,void 0);if(Matrix$1.isMatrix(i)){if(!i.isSymmetric())throw new TypeError("not symmetric data");Vt(this,ze,Matrix$1.copy(i,new Matrix$1(i.rows,i.rows)))}else if(Number.isInteger(i)&&i>=0)Vt(this,ze,new Matrix$1(i,i));else if(Vt(this,ze,new Matrix$1(i)),!this.isSymmetric())throw new TypeError("not symmetric data")}get size(){return Je(this,ze).size}get rows(){return Je(this,ze).rows}get columns(){return Je(this,ze).columns}get diagonalSize(){return this.rows}static isSymmetricMatrix(i){return Matrix$1.isMatrix(i)&&i.klassType==="SymmetricMatrix"}static zeros(i){return new this(i)}static ones(i){return new this(i).fill(1)}clone(){const i=new kt(this.diagonalSize);for(const[r,o,l]of this.upperRightEntries())i.set(r,o,l);return i}toMatrix(){return new Matrix$1(this)}get(i,r){return Je(this,ze).get(i,r)}set(i,r,o){return Je(this,ze).set(i,r,o),Je(this,ze).set(r,i,o),this}removeCross(i){return Je(this,ze).removeRow(i),Je(this,ze).removeColumn(i),this}addCross(i,r){r===void 0&&(r=i,i=this.diagonalSize);const o=r.slice();return o.splice(i,1),Je(this,ze).addRow(i,o),Je(this,ze).addColumn(i,r),this}applyMask(i){if(i.length!==this.diagonalSize)throw new RangeError("Mask size do not match with matrix size");const r=[];for(const[o,l]of i.entries())l||r.push(o);r.reverse();for(const o of r)this.removeCross(o);return this}toCompact(){const{diagonalSize:i}=this,r=new Array(i*(i+1)/2);for(let o=0,l=0,a=0;a<r.length;a++)r[a]=this.get(l,o),++o>=i&&(o=++l);return r}static fromCompact(i){const r=i.length,o=(Math.sqrt(8*r+1)-1)/2;if(!Number.isInteger(o))throw new TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(i)}`);const l=new kt(o);for(let a=0,f=0,p=0;p<r;p++)l.set(a,f,i[p]),++a>=o&&(a=++f);return l}*upperRightEntries(){for(let i=0,r=0;i<this.diagonalSize;void 0){const o=this.get(i,r);yield[i,r,o],++r>=this.diagonalSize&&(r=++i)}}*upperRightValues(){for(let i=0,r=0;i<this.diagonalSize;void 0)yield this.get(i,r),++r>=this.diagonalSize&&(r=++i)}};let SymmetricMatrix=kt;ze=new WeakMap,SymmetricMatrix.prototype.klassType="SymmetricMatrix";class DistanceMatrix extends SymmetricMatrix{static isDistanceMatrix(t){return SymmetricMatrix.isSymmetricMatrix(t)&&t.klassSubType==="DistanceMatrix"}constructor(t){if(super(t),!this.isDistance())throw new TypeError("Provided arguments do no produce a distance matrix")}set(t,i,r){return t===i&&(r=0),super.set(t,i,r)}addCross(t,i){return i===void 0&&(i=t,t=this.diagonalSize),i=i.slice(),i[t]=0,super.addCross(t,i)}toSymmetricMatrix(){return new SymmetricMatrix(this)}clone(){const t=new DistanceMatrix(this.diagonalSize);for(const[i,r,o]of this.upperRightEntries())i!==r&&t.set(i,r,o);return t}toCompact(){const{diagonalSize:t}=this,i=(t-1)*t/2,r=new Array(i);for(let o=1,l=0,a=0;a<r.length;a++)r[a]=this.get(l,o),++o>=t&&(o=++l+1);return r}static fromCompact(t){const i=t.length,r=(Math.sqrt(8*i+1)+1)/2;if(!Number.isInteger(r))throw new TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(t)}`);const o=new this(r);for(let l=1,a=0,f=0;f<i;f++)o.set(l,a,t[f]),++l>=r&&(l=++a+1);return o}}DistanceMatrix.prototype.klassSubType="DistanceMatrix";class BaseView extends AbstractMatrix{constructor(t,i,r){super(),this.matrix=t,this.rows=i,this.columns=r}}class MatrixColumnView extends BaseView{constructor(t,i){checkColumnIndex(t,i),super(t,t.rows,1),this.column=i}set(t,i,r){return this.matrix.set(t,this.column,r),this}get(t){return this.matrix.get(t,this.column)}}class MatrixColumnSelectionView extends BaseView{constructor(t,i){checkColumnIndices(t,i),super(t,t.rows,i.length),this.columnIndices=i}set(t,i,r){return this.matrix.set(t,this.columnIndices[i],r),this}get(t,i){return this.matrix.get(t,this.columnIndices[i])}}class MatrixFlipColumnView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,i,r){return this.matrix.set(t,this.columns-i-1,r),this}get(t,i){return this.matrix.get(t,this.columns-i-1)}}class MatrixFlipRowView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,i,r){return this.matrix.set(this.rows-t-1,i,r),this}get(t,i){return this.matrix.get(this.rows-t-1,i)}}class MatrixRowView extends BaseView{constructor(t,i){checkRowIndex(t,i),super(t,1,t.columns),this.row=i}set(t,i,r){return this.matrix.set(this.row,i,r),this}get(t,i){return this.matrix.get(this.row,i)}}class MatrixRowSelectionView extends BaseView{constructor(t,i){checkRowIndices(t,i),super(t,i.length,t.columns),this.rowIndices=i}set(t,i,r){return this.matrix.set(this.rowIndices[t],i,r),this}get(t,i){return this.matrix.get(this.rowIndices[t],i)}}class MatrixSelectionView extends BaseView{constructor(t,i,r){checkRowIndices(t,i),checkColumnIndices(t,r),super(t,i.length,r.length),this.rowIndices=i,this.columnIndices=r}set(t,i,r){return this.matrix.set(this.rowIndices[t],this.columnIndices[i],r),this}get(t,i){return this.matrix.get(this.rowIndices[t],this.columnIndices[i])}}class MatrixSubView extends BaseView{constructor(t,i,r,o,l){checkRange(t,i,r,o,l),super(t,r-i+1,l-o+1),this.startRow=i,this.startColumn=o}set(t,i,r){return this.matrix.set(this.startRow+t,this.startColumn+i,r),this}get(t,i){return this.matrix.get(this.startRow+t,this.startColumn+i)}}class MatrixTransposeView extends BaseView{constructor(t){super(t,t.columns,t.rows)}set(t,i,r){return this.matrix.set(i,t,r),this}get(t,i){return this.matrix.get(i,t)}}class WrapperMatrix1D extends AbstractMatrix{constructor(t,i={}){const{rows:r=1}=i;if(t.length%r!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=t.length/r,this.data=t}set(t,i,r){let o=this._calculateIndex(t,i);return this.data[o]=r,this}get(t,i){let r=this._calculateIndex(t,i);return this.data[r]}_calculateIndex(t,i){return t*this.columns+i}}class WrapperMatrix2D extends AbstractMatrix{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,i,r){return this.data[t][i]=r,this}get(t,i){return this.data[t][i]}}function wrap(d,t){if(isAnyArray.isAnyArray(d))return d[0]&&isAnyArray.isAnyArray(d[0])?new WrapperMatrix2D(d):new WrapperMatrix1D(d,t);throw new Error("the argument is not an array")}class LuDecomposition{constructor(t){t=WrapperMatrix2D.checkMatrix(t);let i=t.clone(),r=i.rows,o=i.columns,l=new Float64Array(r),a=1,f,p,h,c,n,e,s,u,m;for(f=0;f<r;f++)l[f]=f;for(u=new Float64Array(r),p=0;p<o;p++){for(f=0;f<r;f++)u[f]=i.get(f,p);for(f=0;f<r;f++){for(m=Math.min(f,p),n=0,h=0;h<m;h++)n+=i.get(f,h)*u[h];u[f]-=n,i.set(f,p,u[f])}for(c=p,f=p+1;f<r;f++)Math.abs(u[f])>Math.abs(u[c])&&(c=f);if(c!==p){for(h=0;h<o;h++)e=i.get(c,h),i.set(c,h,i.get(p,h)),i.set(p,h,e);s=l[c],l[c]=l[p],l[p]=s,a=-a}if(p<r&&i.get(p,p)!==0)for(f=p+1;f<r;f++)i.set(f,p,i.get(f,p)/i.get(p,p))}this.LU=i,this.pivotVector=l,this.pivotSign=a}isSingular(){let t=this.LU,i=t.columns;for(let r=0;r<i;r++)if(t.get(r,r)===0)return!0;return!1}solve(t){t=Matrix$1.checkMatrix(t);let i=this.LU;if(i.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let o=t.columns,l=t.subMatrixRow(this.pivotVector,0,o-1),a=i.columns,f,p,h;for(h=0;h<a;h++)for(f=h+1;f<a;f++)for(p=0;p<o;p++)l.set(f,p,l.get(f,p)-l.get(h,p)*i.get(f,h));for(h=a-1;h>=0;h--){for(p=0;p<o;p++)l.set(h,p,l.get(h,p)/i.get(h,h));for(f=0;f<h;f++)for(p=0;p<o;p++)l.set(f,p,l.get(f,p)-l.get(h,p)*i.get(f,h))}return l}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let i=this.pivotSign,r=t.columns;for(let o=0;o<r;o++)i*=t.get(o,o);return i}get lowerTriangularMatrix(){let t=this.LU,i=t.rows,r=t.columns,o=new Matrix$1(i,r);for(let l=0;l<i;l++)for(let a=0;a<r;a++)l>a?o.set(l,a,t.get(l,a)):l===a?o.set(l,a,1):o.set(l,a,0);return o}get upperTriangularMatrix(){let t=this.LU,i=t.rows,r=t.columns,o=new Matrix$1(i,r);for(let l=0;l<i;l++)for(let a=0;a<r;a++)l<=a?o.set(l,a,t.get(l,a)):o.set(l,a,0);return o}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function hypotenuse(d,t){let i=0;return Math.abs(d)>Math.abs(t)?(i=t/d,Math.abs(d)*Math.sqrt(1+i*i)):t!==0?(i=d/t,Math.abs(t)*Math.sqrt(1+i*i)):0}class QrDecomposition{constructor(t){t=WrapperMatrix2D.checkMatrix(t);let i=t.clone(),r=t.rows,o=t.columns,l=new Float64Array(o),a,f,p,h;for(p=0;p<o;p++){let c=0;for(a=p;a<r;a++)c=hypotenuse(c,i.get(a,p));if(c!==0){for(i.get(p,p)<0&&(c=-c),a=p;a<r;a++)i.set(a,p,i.get(a,p)/c);for(i.set(p,p,i.get(p,p)+1),f=p+1;f<o;f++){for(h=0,a=p;a<r;a++)h+=i.get(a,p)*i.get(a,f);for(h=-h/i.get(p,p),a=p;a<r;a++)i.set(a,f,i.get(a,f)+h*i.get(a,p))}}l[p]=-c}this.QR=i,this.Rdiag=l}solve(t){t=Matrix$1.checkMatrix(t);let i=this.QR,r=i.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let o=t.columns,l=t.clone(),a=i.columns,f,p,h,c;for(h=0;h<a;h++)for(p=0;p<o;p++){for(c=0,f=h;f<r;f++)c+=i.get(f,h)*l.get(f,p);for(c=-c/i.get(h,h),f=h;f<r;f++)l.set(f,p,l.get(f,p)+c*i.get(f,h))}for(h=a-1;h>=0;h--){for(p=0;p<o;p++)l.set(h,p,l.get(h,p)/this.Rdiag[h]);for(f=0;f<h;f++)for(p=0;p<o;p++)l.set(f,p,l.get(f,p)-l.get(h,p)*i.get(f,h))}return l.subMatrix(0,a-1,0,o-1)}isFullRank(){let t=this.QR.columns;for(let i=0;i<t;i++)if(this.Rdiag[i]===0)return!1;return!0}get upperTriangularMatrix(){let t=this.QR,i=t.columns,r=new Matrix$1(i,i),o,l;for(o=0;o<i;o++)for(l=0;l<i;l++)o<l?r.set(o,l,t.get(o,l)):o===l?r.set(o,l,this.Rdiag[o]):r.set(o,l,0);return r}get orthogonalMatrix(){let t=this.QR,i=t.rows,r=t.columns,o=new Matrix$1(i,r),l,a,f,p;for(f=r-1;f>=0;f--){for(l=0;l<i;l++)o.set(l,f,0);for(o.set(f,f,1),a=f;a<r;a++)if(t.get(f,f)!==0){for(p=0,l=f;l<i;l++)p+=t.get(l,f)*o.get(l,a);for(p=-p/t.get(f,f),l=f;l<i;l++)o.set(l,a,o.get(l,a)+p*t.get(l,f))}}return o}}class SingularValueDecomposition{constructor(t,i={}){if(t=WrapperMatrix2D.checkMatrix(t),t.isEmpty())throw new Error("Matrix must be non-empty");let r=t.rows,o=t.columns;const{computeLeftSingularVectors:l=!0,computeRightSingularVectors:a=!0,autoTranspose:f=!1}=i;let p=Boolean(l),h=Boolean(a),c=!1,n;if(r<o)if(!f)n=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{n=t.transpose(),r=n.rows,o=n.columns,c=!0;let T=p;p=h,h=T}else n=t.clone();let e=Math.min(r,o),s=Math.min(r+1,o),u=new Float64Array(s),m=new Matrix$1(r,e),b=new Matrix$1(o,o),g=new Float64Array(o),_=new Float64Array(r),y=new Float64Array(s);for(let T=0;T<s;T++)y[T]=T;let v=Math.min(r-1,o),w=Math.max(0,Math.min(o-2,r)),M=Math.max(v,w);for(let T=0;T<M;T++){if(T<v){u[T]=0;for(let I=T;I<r;I++)u[T]=hypotenuse(u[T],n.get(I,T));if(u[T]!==0){n.get(T,T)<0&&(u[T]=-u[T]);for(let I=T;I<r;I++)n.set(I,T,n.get(I,T)/u[T]);n.set(T,T,n.get(T,T)+1)}u[T]=-u[T]}for(let I=T+1;I<o;I++){if(T<v&&u[T]!==0){let F=0;for(let C=T;C<r;C++)F+=n.get(C,T)*n.get(C,I);F=-F/n.get(T,T);for(let C=T;C<r;C++)n.set(C,I,n.get(C,I)+F*n.get(C,T))}g[I]=n.get(T,I)}if(p&&T<v)for(let I=T;I<r;I++)m.set(I,T,n.get(I,T));if(T<w){g[T]=0;for(let I=T+1;I<o;I++)g[T]=hypotenuse(g[T],g[I]);if(g[T]!==0){g[T+1]<0&&(g[T]=0-g[T]);for(let I=T+1;I<o;I++)g[I]/=g[T];g[T+1]+=1}if(g[T]=-g[T],T+1<r&&g[T]!==0){for(let I=T+1;I<r;I++)_[I]=0;for(let I=T+1;I<r;I++)for(let F=T+1;F<o;F++)_[I]+=g[F]*n.get(I,F);for(let I=T+1;I<o;I++){let F=-g[I]/g[T+1];for(let C=T+1;C<r;C++)n.set(C,I,n.get(C,I)+F*_[C])}}if(h)for(let I=T+1;I<o;I++)b.set(I,T,g[I])}}let S=Math.min(o,r+1);if(v<o&&(u[v]=n.get(v,v)),r<S&&(u[S-1]=0),w+1<S&&(g[w]=n.get(w,S-1)),g[S-1]=0,p){for(let T=v;T<e;T++){for(let I=0;I<r;I++)m.set(I,T,0);m.set(T,T,1)}for(let T=v-1;T>=0;T--)if(u[T]!==0){for(let I=T+1;I<e;I++){let F=0;for(let C=T;C<r;C++)F+=m.get(C,T)*m.get(C,I);F=-F/m.get(T,T);for(let C=T;C<r;C++)m.set(C,I,m.get(C,I)+F*m.get(C,T))}for(let I=T;I<r;I++)m.set(I,T,-m.get(I,T));m.set(T,T,1+m.get(T,T));for(let I=0;I<T-1;I++)m.set(I,T,0)}else{for(let I=0;I<r;I++)m.set(I,T,0);m.set(T,T,1)}}if(h)for(let T=o-1;T>=0;T--){if(T<w&&g[T]!==0)for(let I=T+1;I<o;I++){let F=0;for(let C=T+1;C<o;C++)F+=b.get(C,T)*b.get(C,I);F=-F/b.get(T+1,T);for(let C=T+1;C<o;C++)b.set(C,I,b.get(C,I)+F*b.get(C,T))}for(let I=0;I<o;I++)b.set(I,T,0);b.set(T,T,1)}let O=S-1,x=Number.EPSILON;for(;S>0;){let T,I;for(T=S-2;T>=-1&&T!==-1;T--){const F=Number.MIN_VALUE+x*Math.abs(u[T]+Math.abs(u[T+1]));if(Math.abs(g[T])<=F||Number.isNaN(g[T])){g[T]=0;break}}if(T===S-2)I=4;else{let F;for(F=S-1;F>=T&&F!==T;F--){let C=(F!==S?Math.abs(g[F]):0)+(F!==T+1?Math.abs(g[F-1]):0);if(Math.abs(u[F])<=x*C){u[F]=0;break}}F===T?I=3:F===S-1?I=1:(I=2,T=F)}switch(T++,I){case 1:{let F=g[S-2];g[S-2]=0;for(let C=S-2;C>=T;C--){let N=hypotenuse(u[C],F),B=u[C]/N,k=F/N;if(u[C]=N,C!==T&&(F=-k*g[C-1],g[C-1]=B*g[C-1]),h)for(let R=0;R<o;R++)N=B*b.get(R,C)+k*b.get(R,S-1),b.set(R,S-1,-k*b.get(R,C)+B*b.get(R,S-1)),b.set(R,C,N)}break}case 2:{let F=g[T-1];g[T-1]=0;for(let C=T;C<S;C++){let N=hypotenuse(u[C],F),B=u[C]/N,k=F/N;if(u[C]=N,F=-k*g[C],g[C]=B*g[C],p)for(let R=0;R<r;R++)N=B*m.get(R,C)+k*m.get(R,T-1),m.set(R,T-1,-k*m.get(R,C)+B*m.get(R,T-1)),m.set(R,C,N)}break}case 3:{const F=Math.max(Math.abs(u[S-1]),Math.abs(u[S-2]),Math.abs(g[S-2]),Math.abs(u[T]),Math.abs(g[T])),C=u[S-1]/F,N=u[S-2]/F,B=g[S-2]/F,k=u[T]/F,R=g[T]/F,X=((N+C)*(N-C)+B*B)/2,U=C*B*(C*B);let K=0;(X!==0||U!==0)&&(X<0?K=0-Math.sqrt(X*X+U):K=Math.sqrt(X*X+U),K=U/(X+K));let Q=(k+C)*(k-C)+K,se=k*R;for(let te=T;te<S-1;te++){let ae=hypotenuse(Q,se);ae===0&&(ae=Number.MIN_VALUE);let ne=Q/ae,ce=se/ae;if(te!==T&&(g[te-1]=ae),Q=ne*u[te]+ce*g[te],g[te]=ne*g[te]-ce*u[te],se=ce*u[te+1],u[te+1]=ne*u[te+1],h)for(let oe=0;oe<o;oe++)ae=ne*b.get(oe,te)+ce*b.get(oe,te+1),b.set(oe,te+1,-ce*b.get(oe,te)+ne*b.get(oe,te+1)),b.set(oe,te,ae);if(ae=hypotenuse(Q,se),ae===0&&(ae=Number.MIN_VALUE),ne=Q/ae,ce=se/ae,u[te]=ae,Q=ne*g[te]+ce*u[te+1],u[te+1]=-ce*g[te]+ne*u[te+1],se=ce*g[te+1],g[te+1]=ne*g[te+1],p&&te<r-1)for(let oe=0;oe<r;oe++)ae=ne*m.get(oe,te)+ce*m.get(oe,te+1),m.set(oe,te+1,-ce*m.get(oe,te)+ne*m.get(oe,te+1)),m.set(oe,te,ae)}g[S-2]=Q;break}case 4:{if(u[T]<=0&&(u[T]=u[T]<0?-u[T]:0,h))for(let F=0;F<=O;F++)b.set(F,T,-b.get(F,T));for(;T<O&&!(u[T]>=u[T+1]);){let F=u[T];if(u[T]=u[T+1],u[T+1]=F,h&&T<o-1)for(let C=0;C<o;C++)F=b.get(C,T+1),b.set(C,T+1,b.get(C,T)),b.set(C,T,F);if(p&&T<r-1)for(let C=0;C<r;C++)F=m.get(C,T+1),m.set(C,T+1,m.get(C,T)),m.set(C,T,F);T++}S--;break}}}if(c){let T=b;b=m,m=T}this.m=r,this.n=o,this.s=u,this.U=m,this.V=b}solve(t){let i=t,r=this.threshold,o=this.s.length,l=Matrix$1.zeros(o,o);for(let e=0;e<o;e++)Math.abs(this.s[e])<=r?l.set(e,e,0):l.set(e,e,1/this.s[e]);let a=this.U,f=this.rightSingularVectors,p=f.mmul(l),h=f.rows,c=a.rows,n=Matrix$1.zeros(h,c);for(let e=0;e<h;e++)for(let s=0;s<c;s++){let u=0;for(let m=0;m<o;m++)u+=p.get(e,m)*a.get(s,m);n.set(e,s,u)}return n.mmul(i)}solveForDiagonal(t){return this.solve(Matrix$1.diag(t))}inverse(){let t=this.V,i=this.threshold,r=t.rows,o=t.columns,l=new Matrix$1(r,this.s.length);for(let c=0;c<r;c++)for(let n=0;n<o;n++)Math.abs(this.s[n])>i&&l.set(c,n,t.get(c,n)/this.s[n]);let a=this.U,f=a.rows,p=a.columns,h=new Matrix$1(r,f);for(let c=0;c<r;c++)for(let n=0;n<f;n++){let e=0;for(let s=0;s<p;s++)e+=l.get(c,s)*a.get(n,s);h.set(c,n,e)}return h}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,i=0,r=this.s;for(let o=0,l=r.length;o<l;o++)r[o]>t&&i++;return i}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix$1.diag(this.s)}}function inverse$1(d,t=!1){return d=WrapperMatrix2D.checkMatrix(d),t?new SingularValueDecomposition(d).inverse():solve(d,Matrix$1.eye(d.rows))}function solve(d,t,i=!1){return d=WrapperMatrix2D.checkMatrix(d),t=WrapperMatrix2D.checkMatrix(t),i?new SingularValueDecomposition(d).solve(t):d.isSquare()?new LuDecomposition(d).solve(t):new QrDecomposition(d).solve(t)}function determinant(d){if(d=Matrix$1.checkMatrix(d),d.isSquare()){if(d.columns===0)return 1;let t,i,r,o;if(d.columns===2)return t=d.get(0,0),i=d.get(0,1),r=d.get(1,0),o=d.get(1,1),t*o-i*r;if(d.columns===3){let l,a,f;return l=new MatrixSelectionView(d,[1,2],[1,2]),a=new MatrixSelectionView(d,[1,2],[0,2]),f=new MatrixSelectionView(d,[1,2],[0,1]),t=d.get(0,0),i=d.get(0,1),r=d.get(0,2),t*determinant(l)-i*determinant(a)+r*determinant(f)}else return new LuDecomposition(d).determinant}else throw Error("determinant can only be calculated for a square matrix")}function xrange(d,t){let i=[];for(let r=0;r<d;r++)r!==t&&i.push(r);return i}function dependenciesOneRow(d,t,i,r=1e-9,o=1e-9){if(d>o)return new Array(t.rows+1).fill(0);{let l=t.addRow(i,[0]);for(let a=0;a<l.rows;a++)Math.abs(l.get(a,0))<r&&l.set(a,0,0);return l.to1DArray()}}function linearDependencies(d,t={}){const{thresholdValue:i=1e-9,thresholdError:r=1e-9}=t;d=Matrix$1.checkMatrix(d);let o=d.rows,l=new Matrix$1(o,o);for(let a=0;a<o;a++){let f=Matrix$1.columnVector(d.getRow(a)),p=d.subMatrixRow(xrange(o,a)).transpose(),c=new SingularValueDecomposition(p).solve(f),n=Matrix$1.sub(f,p.mmul(c)).abs().max();l.setRow(a,dependenciesOneRow(n,c,a,i,r))}return l}function pseudoInverse(d,t=Number.EPSILON){if(d=Matrix$1.checkMatrix(d),d.isEmpty())return d.transpose();let i=new SingularValueDecomposition(d,{autoTranspose:!0}),r=i.leftSingularVectors,o=i.rightSingularVectors,l=i.diagonal;for(let a=0;a<l.length;a++)Math.abs(l[a])>t?l[a]=1/l[a]:l[a]=0;return o.mmul(Matrix$1.diag(l).mmul(r.transpose()))}function covariance(d,t=d,i={}){d=new Matrix$1(d);let r=!1;if(typeof t=="object"&&!Matrix$1.isMatrix(t)&&!isAnyArray.isAnyArray(t)?(i=t,t=d,r=!0):t=new Matrix$1(t),d.rows!==t.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:o=!0}=i;o&&(d=d.center("column"),r||(t=t.center("column")));const l=d.transpose().mmul(t);for(let a=0;a<l.rows;a++)for(let f=0;f<l.columns;f++)l.set(a,f,l.get(a,f)*(1/(d.rows-1)));return l}function correlation(d,t=d,i={}){d=new Matrix$1(d);let r=!1;if(typeof t=="object"&&!Matrix$1.isMatrix(t)&&!isAnyArray.isAnyArray(t)?(i=t,t=d,r=!0):t=new Matrix$1(t),d.rows!==t.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:o=!0,scale:l=!0}=i;o&&(d.center("column"),r||t.center("column")),l&&(d.scale("column"),r||t.scale("column"));const a=d.standardDeviation("column",{unbiased:!0}),f=r?a:t.standardDeviation("column",{unbiased:!0}),p=d.transpose().mmul(t);for(let h=0;h<p.rows;h++)for(let c=0;c<p.columns;c++)p.set(h,c,p.get(h,c)*(1/(a[h]*f[c]))*(1/(d.rows-1)));return p}class EigenvalueDecomposition{constructor(t,i={}){const{assumeSymmetric:r=!1}=i;if(t=WrapperMatrix2D.checkMatrix(t),!t.isSquare())throw new Error("Matrix is not a square matrix");if(t.isEmpty())throw new Error("Matrix must be non-empty");let o=t.columns,l=new Matrix$1(o,o),a=new Float64Array(o),f=new Float64Array(o),p=t,h,c,n=!1;if(r?n=!0:n=t.isSymmetric(),n){for(h=0;h<o;h++)for(c=0;c<o;c++)l.set(h,c,p.get(h,c));tred2(o,f,a,l),tql2(o,f,a,l)}else{let e=new Matrix$1(o,o),s=new Float64Array(o);for(c=0;c<o;c++)for(h=0;h<o;h++)e.set(h,c,p.get(h,c));orthes(o,e,s,l),hqr2(o,f,a,l,e)}this.n=o,this.e=f,this.d=a,this.V=l}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t=this.n,i=this.e,r=this.d,o=new Matrix$1(t,t),l,a;for(l=0;l<t;l++){for(a=0;a<t;a++)o.set(l,a,0);o.set(l,l,r[l]),i[l]>0?o.set(l,l+1,i[l]):i[l]<0&&o.set(l,l-1,i[l])}return o}}function tred2(d,t,i,r){let o,l,a,f,p,h,c,n;for(p=0;p<d;p++)i[p]=r.get(d-1,p);for(f=d-1;f>0;f--){for(n=0,a=0,h=0;h<f;h++)n=n+Math.abs(i[h]);if(n===0)for(t[f]=i[f-1],p=0;p<f;p++)i[p]=r.get(f-1,p),r.set(f,p,0),r.set(p,f,0);else{for(h=0;h<f;h++)i[h]/=n,a+=i[h]*i[h];for(o=i[f-1],l=Math.sqrt(a),o>0&&(l=-l),t[f]=n*l,a=a-o*l,i[f-1]=o-l,p=0;p<f;p++)t[p]=0;for(p=0;p<f;p++){for(o=i[p],r.set(p,f,o),l=t[p]+r.get(p,p)*o,h=p+1;h<=f-1;h++)l+=r.get(h,p)*i[h],t[h]+=r.get(h,p)*o;t[p]=l}for(o=0,p=0;p<f;p++)t[p]/=a,o+=t[p]*i[p];for(c=o/(a+a),p=0;p<f;p++)t[p]-=c*i[p];for(p=0;p<f;p++){for(o=i[p],l=t[p],h=p;h<=f-1;h++)r.set(h,p,r.get(h,p)-(o*t[h]+l*i[h]));i[p]=r.get(f-1,p),r.set(f,p,0)}}i[f]=a}for(f=0;f<d-1;f++){if(r.set(d-1,f,r.get(f,f)),r.set(f,f,1),a=i[f+1],a!==0){for(h=0;h<=f;h++)i[h]=r.get(h,f+1)/a;for(p=0;p<=f;p++){for(l=0,h=0;h<=f;h++)l+=r.get(h,f+1)*r.get(h,p);for(h=0;h<=f;h++)r.set(h,p,r.get(h,p)-l*i[h])}}for(h=0;h<=f;h++)r.set(h,f+1,0)}for(p=0;p<d;p++)i[p]=r.get(d-1,p),r.set(d-1,p,0);r.set(d-1,d-1,1),t[0]=0}function tql2(d,t,i,r){let o,l,a,f,p,h,c,n,e,s,u,m,b,g,_,y;for(a=1;a<d;a++)t[a-1]=t[a];t[d-1]=0;let v=0,w=0,M=Number.EPSILON;for(h=0;h<d;h++){for(w=Math.max(w,Math.abs(i[h])+Math.abs(t[h])),c=h;c<d&&!(Math.abs(t[c])<=M*w);)c++;if(c>h)do{for(o=i[h],n=(i[h+1]-o)/(2*t[h]),e=hypotenuse(n,1),n<0&&(e=-e),i[h]=t[h]/(n+e),i[h+1]=t[h]*(n+e),s=i[h+1],l=o-i[h],a=h+2;a<d;a++)i[a]-=l;for(v=v+l,n=i[c],u=1,m=u,b=u,g=t[h+1],_=0,y=0,a=c-1;a>=h;a--)for(b=m,m=u,y=_,o=u*t[a],l=u*n,e=hypotenuse(n,t[a]),t[a+1]=_*e,_=t[a]/e,u=n/e,n=u*i[a]-_*o,i[a+1]=l+_*(u*o+_*i[a]),p=0;p<d;p++)l=r.get(p,a+1),r.set(p,a+1,_*r.get(p,a)+u*l),r.set(p,a,u*r.get(p,a)-_*l);n=-_*y*b*g*t[h]/s,t[h]=_*n,i[h]=u*n}while(Math.abs(t[h])>M*w);i[h]=i[h]+v,t[h]=0}for(a=0;a<d-1;a++){for(p=a,n=i[a],f=a+1;f<d;f++)i[f]<n&&(p=f,n=i[f]);if(p!==a)for(i[p]=i[a],i[a]=n,f=0;f<d;f++)n=r.get(f,a),r.set(f,a,r.get(f,p)),r.set(f,p,n)}}function orthes(d,t,i,r){let o=0,l=d-1,a,f,p,h,c,n,e;for(n=o+1;n<=l-1;n++){for(e=0,h=n;h<=l;h++)e=e+Math.abs(t.get(h,n-1));if(e!==0){for(p=0,h=l;h>=n;h--)i[h]=t.get(h,n-1)/e,p+=i[h]*i[h];for(f=Math.sqrt(p),i[n]>0&&(f=-f),p=p-i[n]*f,i[n]=i[n]-f,c=n;c<d;c++){for(a=0,h=l;h>=n;h--)a+=i[h]*t.get(h,c);for(a=a/p,h=n;h<=l;h++)t.set(h,c,t.get(h,c)-a*i[h])}for(h=0;h<=l;h++){for(a=0,c=l;c>=n;c--)a+=i[c]*t.get(h,c);for(a=a/p,c=n;c<=l;c++)t.set(h,c,t.get(h,c)-a*i[c])}i[n]=e*i[n],t.set(n,n-1,e*f)}}for(h=0;h<d;h++)for(c=0;c<d;c++)r.set(h,c,h===c?1:0);for(n=l-1;n>=o+1;n--)if(t.get(n,n-1)!==0){for(h=n+1;h<=l;h++)i[h]=t.get(h,n-1);for(c=n;c<=l;c++){for(f=0,h=n;h<=l;h++)f+=i[h]*r.get(h,c);for(f=f/i[n]/t.get(n,n-1),h=n;h<=l;h++)r.set(h,c,r.get(h,c)+f*i[h])}}}function hqr2(d,t,i,r,o){let l=d-1,a=0,f=d-1,p=Number.EPSILON,h=0,c=0,n=0,e=0,s=0,u=0,m=0,b=0,g,_,y,v,w,M,S,O,x,T,I,F,C,N,B;for(g=0;g<d;g++)for((g<a||g>f)&&(i[g]=o.get(g,g),t[g]=0),_=Math.max(g-1,0);_<d;_++)c=c+Math.abs(o.get(g,_));for(;l>=a;){for(v=l;v>a&&(u=Math.abs(o.get(v-1,v-1))+Math.abs(o.get(v,v)),u===0&&(u=c),!(Math.abs(o.get(v,v-1))<p*u));)v--;if(v===l)o.set(l,l,o.get(l,l)+h),i[l]=o.get(l,l),t[l]=0,l--,b=0;else if(v===l-1){if(S=o.get(l,l-1)*o.get(l-1,l),n=(o.get(l-1,l-1)-o.get(l,l))/2,e=n*n+S,m=Math.sqrt(Math.abs(e)),o.set(l,l,o.get(l,l)+h),o.set(l-1,l-1,o.get(l-1,l-1)+h),O=o.get(l,l),e>=0){for(m=n>=0?n+m:n-m,i[l-1]=O+m,i[l]=i[l-1],m!==0&&(i[l]=O-S/m),t[l-1]=0,t[l]=0,O=o.get(l,l-1),u=Math.abs(O)+Math.abs(m),n=O/u,e=m/u,s=Math.sqrt(n*n+e*e),n=n/s,e=e/s,_=l-1;_<d;_++)m=o.get(l-1,_),o.set(l-1,_,e*m+n*o.get(l,_)),o.set(l,_,e*o.get(l,_)-n*m);for(g=0;g<=l;g++)m=o.get(g,l-1),o.set(g,l-1,e*m+n*o.get(g,l)),o.set(g,l,e*o.get(g,l)-n*m);for(g=a;g<=f;g++)m=r.get(g,l-1),r.set(g,l-1,e*m+n*r.get(g,l)),r.set(g,l,e*r.get(g,l)-n*m)}else i[l-1]=O+n,i[l]=O+n,t[l-1]=m,t[l]=-m;l=l-2,b=0}else{if(O=o.get(l,l),x=0,S=0,v<l&&(x=o.get(l-1,l-1),S=o.get(l,l-1)*o.get(l-1,l)),b===10){for(h+=O,g=a;g<=l;g++)o.set(g,g,o.get(g,g)-O);u=Math.abs(o.get(l,l-1))+Math.abs(o.get(l-1,l-2)),O=x=.75*u,S=-.4375*u*u}if(b===30&&(u=(x-O)/2,u=u*u+S,u>0)){for(u=Math.sqrt(u),x<O&&(u=-u),u=O-S/((x-O)/2+u),g=a;g<=l;g++)o.set(g,g,o.get(g,g)-u);h+=u,O=x=S=.964}for(b=b+1,w=l-2;w>=v&&(m=o.get(w,w),s=O-m,u=x-m,n=(s*u-S)/o.get(w+1,w)+o.get(w,w+1),e=o.get(w+1,w+1)-m-s-u,s=o.get(w+2,w+1),u=Math.abs(n)+Math.abs(e)+Math.abs(s),n=n/u,e=e/u,s=s/u,!(w===v||Math.abs(o.get(w,w-1))*(Math.abs(e)+Math.abs(s))<p*(Math.abs(n)*(Math.abs(o.get(w-1,w-1))+Math.abs(m)+Math.abs(o.get(w+1,w+1))))));)w--;for(g=w+2;g<=l;g++)o.set(g,g-2,0),g>w+2&&o.set(g,g-3,0);for(y=w;y<=l-1&&(N=y!==l-1,y!==w&&(n=o.get(y,y-1),e=o.get(y+1,y-1),s=N?o.get(y+2,y-1):0,O=Math.abs(n)+Math.abs(e)+Math.abs(s),O!==0&&(n=n/O,e=e/O,s=s/O)),O!==0);y++)if(u=Math.sqrt(n*n+e*e+s*s),n<0&&(u=-u),u!==0){for(y!==w?o.set(y,y-1,-u*O):v!==w&&o.set(y,y-1,-o.get(y,y-1)),n=n+u,O=n/u,x=e/u,m=s/u,e=e/n,s=s/n,_=y;_<d;_++)n=o.get(y,_)+e*o.get(y+1,_),N&&(n=n+s*o.get(y+2,_),o.set(y+2,_,o.get(y+2,_)-n*m)),o.set(y,_,o.get(y,_)-n*O),o.set(y+1,_,o.get(y+1,_)-n*x);for(g=0;g<=Math.min(l,y+3);g++)n=O*o.get(g,y)+x*o.get(g,y+1),N&&(n=n+m*o.get(g,y+2),o.set(g,y+2,o.get(g,y+2)-n*s)),o.set(g,y,o.get(g,y)-n),o.set(g,y+1,o.get(g,y+1)-n*e);for(g=a;g<=f;g++)n=O*r.get(g,y)+x*r.get(g,y+1),N&&(n=n+m*r.get(g,y+2),r.set(g,y+2,r.get(g,y+2)-n*s)),r.set(g,y,r.get(g,y)-n),r.set(g,y+1,r.get(g,y+1)-n*e)}}}if(c!==0){for(l=d-1;l>=0;l--)if(n=i[l],e=t[l],e===0)for(v=l,o.set(l,l,1),g=l-1;g>=0;g--){for(S=o.get(g,g)-n,s=0,_=v;_<=l;_++)s=s+o.get(g,_)*o.get(_,l);if(t[g]<0)m=S,u=s;else if(v=g,t[g]===0?o.set(g,l,S!==0?-s/S:-s/(p*c)):(O=o.get(g,g+1),x=o.get(g+1,g),e=(i[g]-n)*(i[g]-n)+t[g]*t[g],M=(O*u-m*s)/e,o.set(g,l,M),o.set(g+1,l,Math.abs(O)>Math.abs(m)?(-s-S*M)/O:(-u-x*M)/m)),M=Math.abs(o.get(g,l)),p*M*M>1)for(_=g;_<=l;_++)o.set(_,l,o.get(_,l)/M)}else if(e<0)for(v=l-1,Math.abs(o.get(l,l-1))>Math.abs(o.get(l-1,l))?(o.set(l-1,l-1,e/o.get(l,l-1)),o.set(l-1,l,-(o.get(l,l)-n)/o.get(l,l-1))):(B=cdiv(0,-o.get(l-1,l),o.get(l-1,l-1)-n,e),o.set(l-1,l-1,B[0]),o.set(l-1,l,B[1])),o.set(l,l-1,0),o.set(l,l,1),g=l-2;g>=0;g--){for(T=0,I=0,_=v;_<=l;_++)T=T+o.get(g,_)*o.get(_,l-1),I=I+o.get(g,_)*o.get(_,l);if(S=o.get(g,g)-n,t[g]<0)m=S,s=T,u=I;else if(v=g,t[g]===0?(B=cdiv(-T,-I,S,e),o.set(g,l-1,B[0]),o.set(g,l,B[1])):(O=o.get(g,g+1),x=o.get(g+1,g),F=(i[g]-n)*(i[g]-n)+t[g]*t[g]-e*e,C=(i[g]-n)*2*e,F===0&&C===0&&(F=p*c*(Math.abs(S)+Math.abs(e)+Math.abs(O)+Math.abs(x)+Math.abs(m))),B=cdiv(O*s-m*T+e*I,O*u-m*I-e*T,F,C),o.set(g,l-1,B[0]),o.set(g,l,B[1]),Math.abs(O)>Math.abs(m)+Math.abs(e)?(o.set(g+1,l-1,(-T-S*o.get(g,l-1)+e*o.get(g,l))/O),o.set(g+1,l,(-I-S*o.get(g,l)-e*o.get(g,l-1))/O)):(B=cdiv(-s-x*o.get(g,l-1),-u-x*o.get(g,l),m,e),o.set(g+1,l-1,B[0]),o.set(g+1,l,B[1]))),M=Math.max(Math.abs(o.get(g,l-1)),Math.abs(o.get(g,l))),p*M*M>1)for(_=g;_<=l;_++)o.set(_,l-1,o.get(_,l-1)/M),o.set(_,l,o.get(_,l)/M)}for(g=0;g<d;g++)if(g<a||g>f)for(_=g;_<d;_++)r.set(g,_,o.get(g,_));for(_=d-1;_>=a;_--)for(g=a;g<=f;g++){for(m=0,y=a;y<=Math.min(_,f);y++)m=m+r.get(g,y)*o.get(y,_);r.set(g,_,m)}}}function cdiv(d,t,i,r){let o,l;return Math.abs(i)>Math.abs(r)?(o=r/i,l=i+o*r,[(d+o*t)/l,(t-o*d)/l]):(o=i/r,l=r+o*i,[(o*d+t)/l,(o*t-d)/l])}class CholeskyDecomposition{constructor(t){if(t=WrapperMatrix2D.checkMatrix(t),!t.isSymmetric())throw new Error("Matrix is not symmetric");let i=t,r=i.rows,o=new Matrix$1(r,r),l=!0,a,f,p;for(f=0;f<r;f++){let h=0;for(p=0;p<f;p++){let c=0;for(a=0;a<p;a++)c+=o.get(p,a)*o.get(f,a);c=(i.get(f,p)-c)/o.get(p,p),o.set(f,p,c),h=h+c*c}for(h=i.get(f,f)-h,l&=h>0,o.set(f,f,Math.sqrt(Math.max(h,0))),p=f+1;p<r;p++)o.set(f,p,0)}this.L=o,this.positiveDefinite=Boolean(l)}isPositiveDefinite(){return this.positiveDefinite}solve(t){t=WrapperMatrix2D.checkMatrix(t);let i=this.L,r=i.rows;if(t.rows!==r)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let o=t.columns,l=t.clone(),a,f,p;for(p=0;p<r;p++)for(f=0;f<o;f++){for(a=0;a<p;a++)l.set(p,f,l.get(p,f)-l.get(a,f)*i.get(p,a));l.set(p,f,l.get(p,f)/i.get(p,p))}for(p=r-1;p>=0;p--)for(f=0;f<o;f++){for(a=p+1;a<r;a++)l.set(p,f,l.get(p,f)-l.get(a,f)*i.get(a,p));l.set(p,f,l.get(p,f)/i.get(p,p))}return l}get lowerTriangularMatrix(){return this.L}}class nipals{constructor(t,i={}){t=WrapperMatrix2D.checkMatrix(t);let{Y:r}=i;const{scaleScores:o=!1,maxIterations:l=1e3,terminationCriteria:a=1e-10}=i;let f;if(r){if(isAnyArray.isAnyArray(r)&&typeof r[0]=="number"?r=Matrix$1.columnVector(r):r=WrapperMatrix2D.checkMatrix(r),r.rows!==t.rows)throw new Error("Y should have the same number of rows as X");f=r.getColumnVector(0)}else f=t.getColumnVector(0);let p=1,h,c,n,e;for(let s=0;s<l&&p>a;s++)n=t.transpose().mmul(f).div(f.transpose().mmul(f).get(0,0)),n=n.div(n.norm()),h=t.mmul(n).div(n.transpose().mmul(n).get(0,0)),s>0&&(p=h.clone().sub(e).pow(2).sum()),e=h.clone(),r?(c=r.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),c=c.div(c.norm()),f=r.mmul(c).div(c.transpose().mmul(c).get(0,0))):f=h;if(r){let s=t.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0));s=s.div(s.norm());let u=t.clone().sub(h.clone().mmul(s.transpose())),m=f.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),b=r.clone().sub(h.clone().mulS(m.get(0,0)).mmul(c.transpose()));this.t=h,this.p=s.transpose(),this.w=n.transpose(),this.q=c,this.u=f,this.s=h.transpose().mmul(h),this.xResidual=u,this.yResidual=b,this.betas=m}else this.w=n.transpose(),this.s=h.transpose().mmul(h).sqrt(),o?this.t=h.clone().div(this.s.get(0,0)):this.t=h,this.xResidual=t.sub(h.mmul(n.transpose()))}}matrix$1.AbstractMatrix=AbstractMatrix,matrix$1.CHO=CholeskyDecomposition,matrix$1.CholeskyDecomposition=CholeskyDecomposition,matrix$1.DistanceMatrix=DistanceMatrix,matrix$1.EVD=EigenvalueDecomposition,matrix$1.EigenvalueDecomposition=EigenvalueDecomposition,matrix$1.LU=LuDecomposition,matrix$1.LuDecomposition=LuDecomposition;var Matrix_1=matrix$1.Matrix=Matrix$1;matrix$1.MatrixColumnSelectionView=MatrixColumnSelectionView,matrix$1.MatrixColumnView=MatrixColumnView,matrix$1.MatrixFlipColumnView=MatrixFlipColumnView,matrix$1.MatrixFlipRowView=MatrixFlipRowView,matrix$1.MatrixRowSelectionView=MatrixRowSelectionView,matrix$1.MatrixRowView=MatrixRowView,matrix$1.MatrixSelectionView=MatrixSelectionView,matrix$1.MatrixSubView=MatrixSubView,matrix$1.MatrixTransposeView=MatrixTransposeView,matrix$1.NIPALS=nipals,matrix$1.Nipals=nipals,matrix$1.QR=QrDecomposition,matrix$1.QrDecomposition=QrDecomposition,matrix$1.SVD=SingularValueDecomposition,matrix$1.SingularValueDecomposition=SingularValueDecomposition,matrix$1.SymmetricMatrix=SymmetricMatrix,matrix$1.WrapperMatrix1D=WrapperMatrix1D,matrix$1.WrapperMatrix2D=WrapperMatrix2D,matrix$1.correlation=correlation,matrix$1.covariance=covariance;var _default=matrix$1.default=Matrix$1;matrix$1.determinant=determinant;var inverse_1=matrix$1.inverse=inverse$1;matrix$1.linearDependencies=linearDependencies,matrix$1.pseudoInverse=pseudoInverse,matrix$1.solve=solve,matrix$1.wrap=wrap;const Matrix=Matrix_1;_default.Matrix&&_default.Matrix;const inverse=inverse_1;function gradientFunction(d,t,i,r,o){const l=i.length,a=d.x.length;let f=new Array(l);for(let p=0;p<l;p++){f[p]=new Array(a);let h=i.slice();h[p]+=r;let c=o(h);for(let n=0;n<a;n++)f[p][n]=t[n]-c(d.x[n])}return new Matrix(f)}function matrixFunction(d,t){const i=d.x.length;let r=new Array(i);for(let o=0;o<i;o++)r[o]=[d.y[o]-t[o]];return new Matrix(r)}function step(d,t,i,r,o){let l=i*r*r,a=Matrix.eye(t.length,t.length,l);const f=o(t);let p=new Float64Array(d.x.length);for(let e=0;e<d.x.length;e++)p[e]=f(d.x[e]);let h=gradientFunction(d,p,t,r,o),c=matrixFunction(d,p),n=inverse(a.add(h.mmul(h.transpose())));return t=new Matrix([t]),t=t.sub(n.mmul(h).mmul(c).mul(r).transpose()),t.to1DArray()}function levenbergMarquardt(d,t,i={}){let{maxIterations:r=100,gradientDifference:o=.1,damping:l=0,errorTolerance:a=.01,minValues:f,maxValues:p,initialValues:h}=i;if(l<=0)throw new Error("The damping option must be a positive number");if(!d.x||!d.y)throw new Error("The data parameter must have x and y elements");if(!isAnyArray$2(d.x)||d.x.length<2||!isAnyArray$2(d.y)||d.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(d.x.length!==d.y.length)throw new Error("The data parameter elements must have the same size");let c=h||new Array(t.length).fill(1),n=c.length;if(p=p||new Array(n).fill(Number.MAX_SAFE_INTEGER),f=f||new Array(n).fill(Number.MIN_SAFE_INTEGER),p.length!==f.length)throw new Error("minValues and maxValues must be the same size");if(!isAnyArray$2(c))throw new Error("initialValues must be an array");let e=errorCalculation(d,c,t),s=e<=a,u;for(u=0;u<r&&!s;u++){c=step(d,c,l,o,t);for(let m=0;m<n;m++)c[m]=Math.min(Math.max(f[m],c[m]),p[m]);if(e=errorCalculation(d,c,t),isNaN(e))break;s=e<=a}return{parameterValues:c,parameterError:e,iterations:u}}var src=Object.freeze({__proto__:null,default:levenbergMarquardt}),require$$5=getAugmentedNamespace(src),__awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(d,t,i,r){return new(i||(i=Promise))(function(o,l){function a(h){try{p(r.next(h))}catch(c){l(c)}}function f(h){try{p(r.throw(h))}catch(c){l(c)}}function p(h){h.done?o(h.value):new i(function(c){c(h.value)}).then(a,f)}p((r=r.apply(d,t||[])).next())})},__generator=commonjsGlobal&&commonjsGlobal.__generator||function(d,t){var i={label:0,sent:function(){if(l[0]&1)throw l[1];return l[1]},trys:[],ops:[]},r,o,l,a;return a={next:f(0),throw:f(1),return:f(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function f(h){return function(c){return p([h,c])}}function p(h){if(r)throw new TypeError("Generator is already executing.");for(;i;)try{if(r=1,o&&(l=h[0]&2?o.return:h[0]?o.throw||((l=o.return)&&l.call(o),0):o.next)&&!(l=l.call(o,h[1])).done)return l;switch(o=0,l&&(h=[h[0]&2,l.value]),h[0]){case 0:case 1:l=h;break;case 4:return i.label++,{value:h[1],done:!1};case 5:i.label++,o=h[1],h=[0];continue;case 7:h=i.ops.pop(),i.trys.pop();continue;default:if(l=i.trys,!(l=l.length>0&&l[l.length-1])&&(h[0]===6||h[0]===2)){i=0;continue}if(h[0]===3&&(!l||h[1]>l[0]&&h[1]<l[3])){i.label=h[1];break}if(h[0]===6&&i.label<l[1]){i.label=l[1],l=h;break}if(l&&i.label<l[2]){i.label=l[2],i.ops.push(h);break}l[2]&&i.ops.pop(),i.trys.pop();continue}h=t.call(d,i)}catch(c){h=[6,c],o=0}finally{r=l=0}if(h[0]&5)throw h[1];return{value:h[0]?h[1]:void 0,done:!0}}},__read=commonjsGlobal&&commonjsGlobal.__read||function(d,t){var i=typeof Symbol=="function"&&d[Symbol.iterator];if(!i)return d;var r=i.call(d),o,l=[],a;try{for(;(t===void 0||t-- >0)&&!(o=r.next()).done;)l.push(o.value)}catch(f){a={error:f}}finally{try{o&&!o.done&&(i=r.return)&&i.call(r)}finally{if(a)throw a.error}}return l},__spread=commonjsGlobal&&commonjsGlobal.__spread||function(){for(var d=[],t=0;t<arguments.length;t++)d=d.concat(__read(arguments[t]));return d},__importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(d){if(d&&d.__esModule)return d;var t={};if(d!=null)for(var i in d)Object.hasOwnProperty.call(d,i)&&(t[i]=d[i]);return t.default=d,t},__importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(d){return d&&d.__esModule?d:{default:d}};Object.defineProperty(umap,"__esModule",{value:!0});var heap=__importStar(heap$2),matrix=__importStar(matrix$3),nnDescent=__importStar(nn_descent),tree=__importStar(tree$2),utils=__importStar(utils$5),ml_levenberg_marquardt_1=__importDefault(require$$5),SMOOTH_K_TOLERANCE=1e-5,MIN_K_DIST_SCALE=.001,UMAP$1=function(){function d(t){t===void 0&&(t={});var i=this;this.learningRate=1,this.localConnectivity=1,this.minDist=.1,this.nComponents=2,this.nEpochs=0,this.nNeighbors=15,this.negativeSampleRate=5,this.random=Math.random,this.repulsionStrength=1,this.setOpMixRatio=1,this.spread=1,this.transformQueueSize=4,this.targetMetric="categorical",this.targetWeight=.5,this.targetNNeighbors=this.nNeighbors,this.distanceFn=euclidean,this.isInitialized=!1,this.rpForest=[],this.embedding=[],this.optimizationState=new OptimizationState;var r=function(o){t[o]!==void 0&&(i[o]=t[o])};r("distanceFn"),r("learningRate"),r("localConnectivity"),r("minDist"),r("nComponents"),r("nEpochs"),r("nNeighbors"),r("negativeSampleRate"),r("random"),r("repulsionStrength"),r("setOpMixRatio"),r("spread"),r("transformQueueSize")}return d.prototype.fit=function(t){return this.initializeFit(t),this.optimizeLayout(),this.embedding},d.prototype.fitAsync=function(t,i){return i===void 0&&(i=function(){return!0}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){switch(r.label){case 0:return this.initializeFit(t),[4,this.optimizeLayoutAsync(i)];case 1:return r.sent(),[2,this.embedding]}})})},d.prototype.setSupervisedProjection=function(t,i){i===void 0&&(i={}),this.Y=t,this.targetMetric=i.targetMetric||this.targetMetric,this.targetWeight=i.targetWeight||this.targetWeight,this.targetNNeighbors=i.targetNNeighbors||this.targetNNeighbors},d.prototype.setPrecomputedKNN=function(t,i){this.knnIndices=t,this.knnDistances=i},d.prototype.initializeFit=function(t){if(t.length<=this.nNeighbors)throw new Error("Not enough data points ("+t.length+") to create nNeighbors: "+this.nNeighbors+".  Add more data points or adjust the configuration.");if(this.X===t&&this.isInitialized)return this.getNEpochs();if(this.X=t,!this.knnIndices&&!this.knnDistances){var i=this.nearestNeighbors(t);this.knnIndices=i.knnIndices,this.knnDistances=i.knnDistances}this.graph=this.fuzzySimplicialSet(t,this.nNeighbors,this.setOpMixRatio),this.makeSearchFns(),this.searchGraph=this.makeSearchGraph(t),this.processGraphForSupervisedProjection();var r=this.initializeSimplicialSetEmbedding(),o=r.head,l=r.tail,a=r.epochsPerSample;return this.optimizationState.head=o,this.optimizationState.tail=l,this.optimizationState.epochsPerSample=a,this.initializeOptimization(),this.prepareForOptimizationLoop(),this.isInitialized=!0,this.getNEpochs()},d.prototype.makeSearchFns=function(){var t=nnDescent.makeInitializations(this.distanceFn),i=t.initFromTree,r=t.initFromRandom;this.initFromTree=i,this.initFromRandom=r,this.search=nnDescent.makeInitializedNNSearch(this.distanceFn)},d.prototype.makeSearchGraph=function(t){for(var i=this.knnIndices,r=this.knnDistances,o=[t.length,t.length],l=new matrix.SparseMatrix([],[],[],o),a=0;a<i.length;a++)for(var f=i[a],p=r[a],h=0;h<f.length;h++){var c=f[h],n=p[h];n>0&&l.set(a,c,n)}var e=matrix.transpose(l);return matrix.maximum(l,e)},d.prototype.transform=function(t){var i=this,r=this.X;if(r===void 0||r.length===0)throw new Error("No data has been fit.");var o=Math.floor(this.nNeighbors*this.transformQueueSize);o=Math.min(r.length,o);var l=nnDescent.initializeSearch(this.rpForest,r,t,o,this.initFromRandom,this.initFromTree,this.random),a=this.search(r,this.searchGraph,l,t),f=heap.deheapSort(a),p=f.indices,h=f.weights;p=p.map(function(B){return B.slice(0,i.nNeighbors)}),h=h.map(function(B){return B.slice(0,i.nNeighbors)});var c=Math.max(0,this.localConnectivity-1),n=this.smoothKNNDistance(h,this.nNeighbors,c),e=n.sigmas,s=n.rhos,u=this.computeMembershipStrengths(p,h,e,s),m=u.rows,b=u.cols,g=u.vals,_=[t.length,r.length],y=new matrix.SparseMatrix(m,b,g,_),v=matrix.normalize(y,"l1"),w=matrix.getCSR(v),M=t.length,S=utils.reshape2d(w.indices,M,this.nNeighbors),O=utils.reshape2d(w.values,M,this.nNeighbors),x=initTransform(S,O,this.embedding),T=this.nEpochs?this.nEpochs/3:y.nRows<=1e4?100:30,I=y.getValues().reduce(function(B,k){return k>B?k:B},0);y=y.map(function(B){return B<I/T?0:B}),y=matrix.eliminateZeros(y);var F=this.makeEpochsPerSample(y.getValues(),T),C=y.getRows(),N=y.getCols();return this.assignOptimizationStateParameters({headEmbedding:x,tailEmbedding:this.embedding,head:C,tail:N,currentEpoch:0,nEpochs:T,nVertices:y.getDims()[1],epochsPerSample:F}),this.prepareForOptimizationLoop(),this.optimizeLayout()},d.prototype.processGraphForSupervisedProjection=function(){var t=this,i=t.Y,r=t.X;if(i){if(i.length!==r.length)throw new Error("Length of X and y must be equal");if(this.targetMetric==="categorical"){var o=this.targetWeight<1,l=o?2.5*(1/(1-this.targetWeight)):1e12;this.graph=this.categoricalSimplicialSetIntersection(this.graph,i,l)}}},d.prototype.step=function(){var t=this.optimizationState.currentEpoch;return t<this.getNEpochs()&&this.optimizeLayoutStep(t),this.optimizationState.currentEpoch},d.prototype.getEmbedding=function(){return this.embedding},d.prototype.nearestNeighbors=function(t){var i=this,r=i.distanceFn,o=i.nNeighbors,l=function(u){return Math.log(u)/Math.log(2)},a=nnDescent.makeNNDescent(r,this.random),f=function(u){return u===.5?0:Math.round(u)},p=5+Math.floor(f(Math.pow(t.length,.5)/20)),h=Math.max(5,Math.floor(Math.round(l(t.length))));this.rpForest=tree.makeForest(t,o,p,this.random);var c=tree.makeLeafArray(this.rpForest),n=a(t,c,o,h),e=n.indices,s=n.weights;return{knnIndices:e,knnDistances:s}},d.prototype.fuzzySimplicialSet=function(t,i,r){r===void 0&&(r=1);var o=this,l=o.knnIndices,a=l===void 0?[]:l,f=o.knnDistances,p=f===void 0?[]:f,h=o.localConnectivity,c=this.smoothKNNDistance(p,i,h),n=c.sigmas,e=c.rhos,s=this.computeMembershipStrengths(a,p,n,e),u=s.rows,m=s.cols,b=s.vals,g=[t.length,t.length],_=new matrix.SparseMatrix(u,m,b,g),y=matrix.transpose(_),v=matrix.pairwiseMultiply(_,y),w=matrix.subtract(matrix.add(_,y),v),M=matrix.multiplyScalar(w,r),S=matrix.multiplyScalar(v,1-r),O=matrix.add(M,S);return O},d.prototype.categoricalSimplicialSetIntersection=function(t,i,r,o){o===void 0&&(o=1);var l=fastIntersection(t,i,o,r);return l=matrix.eliminateZeros(l),resetLocalConnectivity(l)},d.prototype.smoothKNNDistance=function(t,i,r,o,l){r===void 0&&(r=1),o===void 0&&(o=64),l===void 0&&(l=1);for(var a=Math.log(i)/Math.log(2)*l,f=utils.zeros(t.length),p=utils.zeros(t.length),h=0;h<t.length;h++){var c=0,n=1/0,e=1,s=t[h],u=s.filter(function(S){return S>0});if(u.length>=r){var m=Math.floor(r),b=r-m;m>0?(f[h]=u[m-1],b>SMOOTH_K_TOLERANCE&&(f[h]+=b*(u[m]-u[m-1]))):f[h]=b*u[0]}else u.length>0&&(f[h]=utils.max(u));for(var g=0;g<o;g++){for(var _=0,y=1;y<t[h].length;y++){var v=t[h][y]-f[h];v>0?_+=Math.exp(-(v/e)):_+=1}if(Math.abs(_-a)<SMOOTH_K_TOLERANCE)break;_>a?(n=e,e=(c+n)/2):(c=e,n===1/0?e*=2:e=(c+n)/2)}if(p[h]=e,f[h]>0){var w=utils.mean(s);p[h]<MIN_K_DIST_SCALE*w&&(p[h]=MIN_K_DIST_SCALE*w)}else{var M=utils.mean(t.map(utils.mean));p[h]<MIN_K_DIST_SCALE*M&&(p[h]=MIN_K_DIST_SCALE*M)}}return{sigmas:p,rhos:f}},d.prototype.computeMembershipStrengths=function(t,i,r,o){for(var l=t.length,a=t[0].length,f=utils.zeros(l*a),p=utils.zeros(l*a),h=utils.zeros(l*a),c=0;c<l;c++)for(var n=0;n<a;n++){var e=0;t[c][n]!==-1&&(t[c][n]===c?e=0:i[c][n]-o[c]<=0?e=1:e=Math.exp(-((i[c][n]-o[c])/r[c])),f[c*a+n]=c,p[c*a+n]=t[c][n],h[c*a+n]=e)}return{rows:f,cols:p,vals:h}},d.prototype.initializeSimplicialSetEmbedding=function(){for(var t=this,i=this.getNEpochs(),r=this.nComponents,o=this.graph.getValues(),l=0,a=0;a<o.length;a++){var f=o[a];l<o[a]&&(l=f)}var p=this.graph.map(function(m){return m<l/i?0:m});this.embedding=utils.zeros(p.nRows).map(function(){return utils.zeros(r).map(function(){return utils.tauRand(t.random)*20+-10})});for(var h=[],c=[],n=[],e=p.getAll(),a=0;a<e.length;a++){var s=e[a];s.value&&(h.push(s.value),n.push(s.row),c.push(s.col))}var u=this.makeEpochsPerSample(h,i);return{head:c,tail:n,epochsPerSample:u}},d.prototype.makeEpochsPerSample=function(t,i){var r=utils.filled(t.length,-1),o=utils.max(t),l=t.map(function(a){return a/o*i});return l.forEach(function(a,f){a>0&&(r[f]=i/l[f])}),r},d.prototype.assignOptimizationStateParameters=function(t){Object.assign(this.optimizationState,t)},d.prototype.prepareForOptimizationLoop=function(){var t=this,i=t.repulsionStrength,r=t.learningRate,o=t.negativeSampleRate,l=this.optimizationState,a=l.epochsPerSample,f=l.headEmbedding,p=l.tailEmbedding,h=f[0].length,c=f.length===p.length,n=a.map(function(u){return u/o}),e=__spread(n),s=__spread(a);this.assignOptimizationStateParameters({epochOfNextSample:s,epochOfNextNegativeSample:e,epochsPerNegativeSample:n,moveOther:c,initialAlpha:r,alpha:r,gamma:i,dim:h})},d.prototype.initializeOptimization=function(){var t=this.embedding,i=this.embedding,r=this.optimizationState,o=r.head,l=r.tail,a=r.epochsPerSample,f=this.getNEpochs(),p=this.graph.nCols,h=findABParams(this.spread,this.minDist),c=h.a,n=h.b;this.assignOptimizationStateParameters({headEmbedding:t,tailEmbedding:i,head:o,tail:l,epochsPerSample:a,a:c,b:n,nEpochs:f,nVertices:p})},d.prototype.optimizeLayoutStep=function(t){for(var i=this.optimizationState,r=i.head,o=i.tail,l=i.headEmbedding,a=i.tailEmbedding,f=i.epochsPerSample,p=i.epochOfNextSample,h=i.epochOfNextNegativeSample,c=i.epochsPerNegativeSample,n=i.moveOther,e=i.initialAlpha,s=i.alpha,u=i.gamma,m=i.a,b=i.b,g=i.dim,_=i.nEpochs,y=i.nVertices,v=4,w=0;w<f.length;w++)if(!(p[w]>t)){var M=r[w],S=o[w],O=l[M],x=a[S],T=rDist(O,x),I=0;T>0&&(I=-2*m*b*Math.pow(T,b-1),I/=m*Math.pow(T,b)+1);for(var F=0;F<g;F++){var C=clip(I*(O[F]-x[F]),v);O[F]+=C*s,n&&(x[F]+=-C*s)}p[w]+=f[w];for(var N=Math.floor((t-h[w])/c[w]),B=0;B<N;B++){var k=utils.tauRandInt(y,this.random),R=a[k],X=rDist(O,R),U=0;if(X>0)U=2*u*b,U/=(.001+X)*(m*Math.pow(X,b)+1);else if(M===k)continue;for(var F=0;F<g;F++){var C=4;U>0&&(C=clip(U*(O[F]-R[F]),v)),O[F]+=C*s}}h[w]+=N*c[w]}return i.alpha=e*(1-t/_),i.currentEpoch+=1,l},d.prototype.optimizeLayoutAsync=function(t){var i=this;return t===void 0&&(t=function(){return!0}),new Promise(function(r,o){var l=function(){return __awaiter(i,void 0,void 0,function(){var a,f,p,h,c,n;return __generator(this,function(e){try{if(a=this.optimizationState,f=a.nEpochs,p=a.currentEpoch,this.embedding=this.optimizeLayoutStep(p),h=this.optimizationState.currentEpoch,c=t(h)===!1,n=h===f,!c&&!n)setTimeout(function(){return l()},0);else return[2,r(n)]}catch(s){o(s)}return[2]})})};setTimeout(function(){return l()},0)})},d.prototype.optimizeLayout=function(t){t===void 0&&(t=function(){return!0});for(var i=!1,r=[];!i;){var o=this.optimizationState,l=o.nEpochs,a=o.currentEpoch;r=this.optimizeLayoutStep(a);var f=this.optimizationState.currentEpoch,p=t(f)===!1;i=f===l||p}return r},d.prototype.getNEpochs=function(){var t=this.graph;if(this.nEpochs>0)return this.nEpochs;var i=t.nRows;return i<=2500?500:i<=5e3?400:i<=7500?300:200},d}();umap.UMAP=UMAP$1;function euclidean(d,t){for(var i=0,r=0;r<d.length;r++)i+=Math.pow(d[r]-t[r],2);return Math.sqrt(i)}umap.euclidean=euclidean;function cosine(d,t){for(var i=0,r=0,o=0,l=0;l<d.length;l++)i+=d[l]*t[l],r+=Math.pow(d[l],2),o+=Math.pow(t[l],2);return r===0&&o===0?0:r===0||o===0?1:1-i/Math.sqrt(r*o)}umap.cosine=cosine;var OptimizationState=function(){function d(){this.currentEpoch=0,this.headEmbedding=[],this.tailEmbedding=[],this.head=[],this.tail=[],this.epochsPerSample=[],this.epochOfNextSample=[],this.epochOfNextNegativeSample=[],this.epochsPerNegativeSample=[],this.moveOther=!0,this.initialAlpha=1,this.alpha=1,this.gamma=1,this.a=1.5769434603113077,this.b=.8950608779109733,this.dim=2,this.nEpochs=500,this.nVertices=0}return d}();function clip(d,t){return d>t?t:d<-t?-t:d}function rDist(d,t){for(var i=0,r=0;r<d.length;r++)i+=Math.pow(d[r]-t[r],2);return i}function findABParams(d,t){var i=function(e){var s=__read(e,2),u=s[0],m=s[1];return function(b){return 1/(1+u*Math.pow(b,2*m))}},r=utils.linear(0,d*3,300).map(function(e){return e<t?1:e}),o=utils.zeros(r.length).map(function(e,s){var u=r[s]>=t;return u?Math.exp(-(r[s]-t)/d):e}),l=[.5,.5],a={x:r,y:o},f={damping:1.5,initialValues:l,gradientDifference:.1,maxIterations:100,errorTolerance:.01},p=ml_levenberg_marquardt_1.default(a,i,f).parameterValues,h=__read(p,2),c=h[0],n=h[1];return{a:c,b:n}}umap.findABParams=findABParams;function fastIntersection(d,t,i,r){return i===void 0&&(i=1),r===void 0&&(r=5),d.map(function(o,l,a){return t[l]===-1||t[a]===-1?o*Math.exp(-i):t[l]!==t[a]?o*Math.exp(-r):o})}umap.fastIntersection=fastIntersection;function resetLocalConnectivity(d){d=matrix.normalize(d,"max");var t=matrix.transpose(d),i=matrix.pairwiseMultiply(t,d);return d=matrix.add(d,matrix.subtract(t,i)),matrix.eliminateZeros(d)}umap.resetLocalConnectivity=resetLocalConnectivity;function initTransform(d,t,i){for(var r=utils.zeros(d.length).map(function(p){return utils.zeros(i[0].length)}),o=0;o<d.length;o++)for(var l=0;l<d[0].length;l++)for(var a=0;a<i[0].length;a++){var f=d[o][l];r[o][a]+=t[o][l]*i[f][a]}return r}umap.initTransform=initTransform,Object.defineProperty(dist,"__esModule",{value:!0});var umap_1=umap,UMAP=dist.UMAP=umap_1.UMAP;class FeatureExtractionPipeline{static async getInstance(t=null){return this.instance===null&&(this.instance=await CLIPVisionModelWithProjection.from_pretrained("Xenova/clip-vit-base-patch16",{progress_callback:t}),this.processor=await AutoProcessor.from_pretrained("Xenova/clip-vit-base-patch16")),[this.instance,this.processor]}}Be(FeatureExtractionPipeline,"task","feature-extraction"),Be(FeatureExtractionPipeline,"model","Xenova/vit-base-patch16-224-in21k"),Be(FeatureExtractionPipeline,"instance",null),Be(FeatureExtractionPipeline,"processor",null),self.addEventListener("message",async d=>{const[t,i]=await FeatureExtractionPipeline.getInstance(n=>{self.postMessage(n),console.log(n)}),r=performance.now(),o=await Promise.all(d.data.input.map(async n=>{const e=await RawImage.read(`/${n}`),s=await i(e);return(await t(s)).image_embeds.data})),l=performance.now();console.log("time",(l-r)/1e3);const f=await new UMAP({nComponents:2}).fitAsync(o),h=await new UMAP({nComponents:3}).fitAsync(o),c={embeddings2d:f,embeddings3d:h};console.log(c),self.postMessage({status:"complete",output:c})})})();
